
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Inspector
 * 
 */
export type Inspector = $Result.DefaultSelection<Prisma.$InspectorPayload>
/**
 * Model Owner
 * 
 */
export type Owner = $Result.DefaultSelection<Prisma.$OwnerPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model InspectionItem
 * 
 */
export type InspectionItem = $Result.DefaultSelection<Prisma.$InspectionItemPayload>
/**
 * Model InspectionSession
 * 
 */
export type InspectionSession = $Result.DefaultSelection<Prisma.$InspectionSessionPayload>
/**
 * Model InspectionResult
 * 
 */
export type InspectionResult = $Result.DefaultSelection<Prisma.$InspectionResultPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model ReinspectionLink
 * 
 */
export type ReinspectionLink = $Result.DefaultSelection<Prisma.$ReinspectionLinkPayload>
/**
 * Model MediaRef
 * 
 */
export type MediaRef = $Result.DefaultSelection<Prisma.$MediaRefPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Insurer
 * 
 */
export type Insurer = $Result.DefaultSelection<Prisma.$InsurerPayload>
/**
 * Model InsurerUser
 * 
 */
export type InsurerUser = $Result.DefaultSelection<Prisma.$InsurerUserPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model ApiUsageLog
 * 
 */
export type ApiUsageLog = $Result.DefaultSelection<Prisma.$ApiUsageLogPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  INSPECTOR: 'INSPECTOR',
  CASHIER: 'CASHIER',
  INSURER_USER: 'INSURER_USER',
  AGENT: 'AGENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const InspectorStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  EXPIRED: 'EXPIRED'
};

export type InspectorStatus = (typeof InspectorStatus)[keyof typeof InspectorStatus]


export const VehicleCategory: {
  PRIVATE: 'PRIVATE',
  PSV: 'PSV',
  COMMERCIAL: 'COMMERCIAL',
  SCHOOL: 'SCHOOL',
  DRIVING_SCHOOL: 'DRIVING_SCHOOL',
  GOVERNMENT: 'GOVERNMENT',
  TRAILER: 'TRAILER',
  MOTORCYCLE: 'MOTORCYCLE',
  THREE_WHEELER: 'THREE_WHEELER'
};

export type VehicleCategory = (typeof VehicleCategory)[keyof typeof VehicleCategory]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const ItemGroup: {
  BRAKES: 'BRAKES',
  STRUCTURE: 'STRUCTURE',
  EMISSIONS: 'EMISSIONS',
  SUSPENSION_STEERING: 'SUSPENSION_STEERING',
  LIGHTING_ELECTRICAL: 'LIGHTING_ELECTRICAL',
  TYRES: 'TYRES',
  COMPLIANCE_DEVICES: 'COMPLIANCE_DEVICES',
  OTHER: 'OTHER'
};

export type ItemGroup = (typeof ItemGroup)[keyof typeof ItemGroup]


export const InspectionType: {
  ANNUAL: 'ANNUAL',
  PRIVATE_OVER_4YRS: 'PRIVATE_OVER_4YRS',
  SCHOOL: 'SCHOOL',
  PRE_REGISTRATION: 'PRE_REGISTRATION',
  ACCIDENT: 'ACCIDENT',
  CHANGE_OF_PARTICULARS: 'CHANGE_OF_PARTICULARS',
  POLICE: 'POLICE',
  RE_REGISTRATION: 'RE_REGISTRATION',
  SALVAGE_B: 'SALVAGE_B'
};

export type InspectionType = (typeof InspectionType)[keyof typeof InspectionType]


export const InspectionStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  ABORTED: 'ABORTED'
};

export type InspectionStatus = (typeof InspectionStatus)[keyof typeof InspectionStatus]


export const DefectSeverity: {
  NONE: 'NONE',
  MINOR: 'MINOR',
  MAJOR: 'MAJOR',
  DANGEROUS: 'DANGEROUS'
};

export type DefectSeverity = (typeof DefectSeverity)[keyof typeof DefectSeverity]


export const ResultSeverity: {
  INFO: 'INFO',
  MINOR: 'MINOR',
  MAJOR: 'MAJOR',
  DANGEROUS: 'DANGEROUS'
};

export type ResultSeverity = (typeof ResultSeverity)[keyof typeof ResultSeverity]


export const MediaType: {
  PHOTO_FRONT: 'PHOTO_FRONT',
  PHOTO_REAR: 'PHOTO_REAR',
  PHOTO_ODOMETER: 'PHOTO_ODOMETER',
  PHOTO_UNDERBODY: 'PHOTO_UNDERBODY',
  VIDEO_CLIP: 'VIDEO_CLIP',
  OTHER: 'OTHER'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const InsurerStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  INACTIVE: 'INACTIVE'
};

export type InsurerStatus = (typeof InsurerStatus)[keyof typeof InsurerStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type InspectorStatus = $Enums.InspectorStatus

export const InspectorStatus: typeof $Enums.InspectorStatus

export type VehicleCategory = $Enums.VehicleCategory

export const VehicleCategory: typeof $Enums.VehicleCategory

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type ItemGroup = $Enums.ItemGroup

export const ItemGroup: typeof $Enums.ItemGroup

export type InspectionType = $Enums.InspectionType

export const InspectionType: typeof $Enums.InspectionType

export type InspectionStatus = $Enums.InspectionStatus

export const InspectionStatus: typeof $Enums.InspectionStatus

export type DefectSeverity = $Enums.DefectSeverity

export const DefectSeverity: typeof $Enums.DefectSeverity

export type ResultSeverity = $Enums.ResultSeverity

export const ResultSeverity: typeof $Enums.ResultSeverity

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type InsurerStatus = $Enums.InsurerStatus

export const InsurerStatus: typeof $Enums.InsurerStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.inspector`: Exposes CRUD operations for the **Inspector** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inspectors
    * const inspectors = await prisma.inspector.findMany()
    * ```
    */
  get inspector(): Prisma.InspectorDelegate<ExtArgs>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): Prisma.OwnerDelegate<ExtArgs>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.inspectionItem`: Exposes CRUD operations for the **InspectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InspectionItems
    * const inspectionItems = await prisma.inspectionItem.findMany()
    * ```
    */
  get inspectionItem(): Prisma.InspectionItemDelegate<ExtArgs>;

  /**
   * `prisma.inspectionSession`: Exposes CRUD operations for the **InspectionSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InspectionSessions
    * const inspectionSessions = await prisma.inspectionSession.findMany()
    * ```
    */
  get inspectionSession(): Prisma.InspectionSessionDelegate<ExtArgs>;

  /**
   * `prisma.inspectionResult`: Exposes CRUD operations for the **InspectionResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InspectionResults
    * const inspectionResults = await prisma.inspectionResult.findMany()
    * ```
    */
  get inspectionResult(): Prisma.InspectionResultDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.reinspectionLink`: Exposes CRUD operations for the **ReinspectionLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReinspectionLinks
    * const reinspectionLinks = await prisma.reinspectionLink.findMany()
    * ```
    */
  get reinspectionLink(): Prisma.ReinspectionLinkDelegate<ExtArgs>;

  /**
   * `prisma.mediaRef`: Exposes CRUD operations for the **MediaRef** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaRefs
    * const mediaRefs = await prisma.mediaRef.findMany()
    * ```
    */
  get mediaRef(): Prisma.MediaRefDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.insurer`: Exposes CRUD operations for the **Insurer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insurers
    * const insurers = await prisma.insurer.findMany()
    * ```
    */
  get insurer(): Prisma.InsurerDelegate<ExtArgs>;

  /**
   * `prisma.insurerUser`: Exposes CRUD operations for the **InsurerUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsurerUsers
    * const insurerUsers = await prisma.insurerUser.findMany()
    * ```
    */
  get insurerUser(): Prisma.InsurerUserDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.apiUsageLog`: Exposes CRUD operations for the **ApiUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiUsageLogs
    * const apiUsageLogs = await prisma.apiUsageLog.findMany()
    * ```
    */
  get apiUsageLog(): Prisma.ApiUsageLogDelegate<ExtArgs>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Inspector: 'Inspector',
    Owner: 'Owner',
    Vehicle: 'Vehicle',
    Booking: 'Booking',
    InspectionItem: 'InspectionItem',
    InspectionSession: 'InspectionSession',
    InspectionResult: 'InspectionResult',
    Certificate: 'Certificate',
    ReinspectionLink: 'ReinspectionLink',
    MediaRef: 'MediaRef',
    AuditLog: 'AuditLog',
    Insurer: 'Insurer',
    InsurerUser: 'InsurerUser',
    ApiKey: 'ApiKey',
    ApiUsageLog: 'ApiUsageLog',
    Agent: 'Agent',
    Referral: 'Referral'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "inspector" | "owner" | "vehicle" | "booking" | "inspectionItem" | "inspectionSession" | "inspectionResult" | "certificate" | "reinspectionLink" | "mediaRef" | "auditLog" | "insurer" | "insurerUser" | "apiKey" | "apiUsageLog" | "agent" | "referral"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Inspector: {
        payload: Prisma.$InspectorPayload<ExtArgs>
        fields: Prisma.InspectorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>
          }
          findFirst: {
            args: Prisma.InspectorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>
          }
          findMany: {
            args: Prisma.InspectorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>[]
          }
          create: {
            args: Prisma.InspectorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>
          }
          createMany: {
            args: Prisma.InspectorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>[]
          }
          delete: {
            args: Prisma.InspectorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>
          }
          update: {
            args: Prisma.InspectorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>
          }
          deleteMany: {
            args: Prisma.InspectorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InspectorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectorPayload>
          }
          aggregate: {
            args: Prisma.InspectorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspector>
          }
          groupBy: {
            args: Prisma.InspectorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectorCountArgs<ExtArgs>
            result: $Utils.Optional<InspectorCountAggregateOutputType> | number
          }
        }
      }
      Owner: {
        payload: Prisma.$OwnerPayload<ExtArgs>
        fields: Prisma.OwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findFirst: {
            args: Prisma.OwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findMany: {
            args: Prisma.OwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          create: {
            args: Prisma.OwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          createMany: {
            args: Prisma.OwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          delete: {
            args: Prisma.OwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          update: {
            args: Prisma.OwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          aggregate: {
            args: Prisma.OwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwner>
          }
          groupBy: {
            args: Prisma.OwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      InspectionItem: {
        payload: Prisma.$InspectionItemPayload<ExtArgs>
        fields: Prisma.InspectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>
          }
          findFirst: {
            args: Prisma.InspectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>
          }
          findMany: {
            args: Prisma.InspectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>[]
          }
          create: {
            args: Prisma.InspectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>
          }
          createMany: {
            args: Prisma.InspectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>[]
          }
          delete: {
            args: Prisma.InspectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>
          }
          update: {
            args: Prisma.InspectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>
          }
          deleteMany: {
            args: Prisma.InspectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InspectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionItemPayload>
          }
          aggregate: {
            args: Prisma.InspectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspectionItem>
          }
          groupBy: {
            args: Prisma.InspectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<InspectionItemCountAggregateOutputType> | number
          }
        }
      }
      InspectionSession: {
        payload: Prisma.$InspectionSessionPayload<ExtArgs>
        fields: Prisma.InspectionSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectionSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectionSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>
          }
          findFirst: {
            args: Prisma.InspectionSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectionSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>
          }
          findMany: {
            args: Prisma.InspectionSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>[]
          }
          create: {
            args: Prisma.InspectionSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>
          }
          createMany: {
            args: Prisma.InspectionSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectionSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>[]
          }
          delete: {
            args: Prisma.InspectionSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>
          }
          update: {
            args: Prisma.InspectionSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>
          }
          deleteMany: {
            args: Prisma.InspectionSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectionSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InspectionSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionSessionPayload>
          }
          aggregate: {
            args: Prisma.InspectionSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspectionSession>
          }
          groupBy: {
            args: Prisma.InspectionSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectionSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectionSessionCountArgs<ExtArgs>
            result: $Utils.Optional<InspectionSessionCountAggregateOutputType> | number
          }
        }
      }
      InspectionResult: {
        payload: Prisma.$InspectionResultPayload<ExtArgs>
        fields: Prisma.InspectionResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InspectionResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InspectionResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>
          }
          findFirst: {
            args: Prisma.InspectionResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InspectionResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>
          }
          findMany: {
            args: Prisma.InspectionResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>[]
          }
          create: {
            args: Prisma.InspectionResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>
          }
          createMany: {
            args: Prisma.InspectionResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InspectionResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>[]
          }
          delete: {
            args: Prisma.InspectionResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>
          }
          update: {
            args: Prisma.InspectionResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>
          }
          deleteMany: {
            args: Prisma.InspectionResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InspectionResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InspectionResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InspectionResultPayload>
          }
          aggregate: {
            args: Prisma.InspectionResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInspectionResult>
          }
          groupBy: {
            args: Prisma.InspectionResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<InspectionResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.InspectionResultCountArgs<ExtArgs>
            result: $Utils.Optional<InspectionResultCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      ReinspectionLink: {
        payload: Prisma.$ReinspectionLinkPayload<ExtArgs>
        fields: Prisma.ReinspectionLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReinspectionLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReinspectionLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>
          }
          findFirst: {
            args: Prisma.ReinspectionLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReinspectionLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>
          }
          findMany: {
            args: Prisma.ReinspectionLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>[]
          }
          create: {
            args: Prisma.ReinspectionLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>
          }
          createMany: {
            args: Prisma.ReinspectionLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReinspectionLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>[]
          }
          delete: {
            args: Prisma.ReinspectionLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>
          }
          update: {
            args: Prisma.ReinspectionLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>
          }
          deleteMany: {
            args: Prisma.ReinspectionLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReinspectionLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReinspectionLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReinspectionLinkPayload>
          }
          aggregate: {
            args: Prisma.ReinspectionLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReinspectionLink>
          }
          groupBy: {
            args: Prisma.ReinspectionLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReinspectionLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReinspectionLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ReinspectionLinkCountAggregateOutputType> | number
          }
        }
      }
      MediaRef: {
        payload: Prisma.$MediaRefPayload<ExtArgs>
        fields: Prisma.MediaRefFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaRefFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaRefFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>
          }
          findFirst: {
            args: Prisma.MediaRefFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaRefFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>
          }
          findMany: {
            args: Prisma.MediaRefFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>[]
          }
          create: {
            args: Prisma.MediaRefCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>
          }
          createMany: {
            args: Prisma.MediaRefCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaRefCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>[]
          }
          delete: {
            args: Prisma.MediaRefDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>
          }
          update: {
            args: Prisma.MediaRefUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>
          }
          deleteMany: {
            args: Prisma.MediaRefDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaRefUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaRefUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaRefPayload>
          }
          aggregate: {
            args: Prisma.MediaRefAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaRef>
          }
          groupBy: {
            args: Prisma.MediaRefGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaRefGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaRefCountArgs<ExtArgs>
            result: $Utils.Optional<MediaRefCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Insurer: {
        payload: Prisma.$InsurerPayload<ExtArgs>
        fields: Prisma.InsurerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsurerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsurerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>
          }
          findFirst: {
            args: Prisma.InsurerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsurerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>
          }
          findMany: {
            args: Prisma.InsurerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>[]
          }
          create: {
            args: Prisma.InsurerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>
          }
          createMany: {
            args: Prisma.InsurerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsurerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>[]
          }
          delete: {
            args: Prisma.InsurerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>
          }
          update: {
            args: Prisma.InsurerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>
          }
          deleteMany: {
            args: Prisma.InsurerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsurerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsurerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerPayload>
          }
          aggregate: {
            args: Prisma.InsurerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsurer>
          }
          groupBy: {
            args: Prisma.InsurerGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsurerGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsurerCountArgs<ExtArgs>
            result: $Utils.Optional<InsurerCountAggregateOutputType> | number
          }
        }
      }
      InsurerUser: {
        payload: Prisma.$InsurerUserPayload<ExtArgs>
        fields: Prisma.InsurerUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsurerUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsurerUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>
          }
          findFirst: {
            args: Prisma.InsurerUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsurerUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>
          }
          findMany: {
            args: Prisma.InsurerUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>[]
          }
          create: {
            args: Prisma.InsurerUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>
          }
          createMany: {
            args: Prisma.InsurerUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsurerUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>[]
          }
          delete: {
            args: Prisma.InsurerUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>
          }
          update: {
            args: Prisma.InsurerUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>
          }
          deleteMany: {
            args: Prisma.InsurerUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsurerUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsurerUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurerUserPayload>
          }
          aggregate: {
            args: Prisma.InsurerUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsurerUser>
          }
          groupBy: {
            args: Prisma.InsurerUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsurerUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsurerUserCountArgs<ExtArgs>
            result: $Utils.Optional<InsurerUserCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      ApiUsageLog: {
        payload: Prisma.$ApiUsageLogPayload<ExtArgs>
        fields: Prisma.ApiUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          findFirst: {
            args: Prisma.ApiUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          findMany: {
            args: Prisma.ApiUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>[]
          }
          create: {
            args: Prisma.ApiUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          createMany: {
            args: Prisma.ApiUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>[]
          }
          delete: {
            args: Prisma.ApiUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          update: {
            args: Prisma.ApiUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.ApiUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiUsageLogPayload>
          }
          aggregate: {
            args: Prisma.ApiUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiUsageLog>
          }
          groupBy: {
            args: Prisma.ApiUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<ApiUsageLogCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    vehicles: number
    bookings: number
    sessions: number
    auditLogs: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    vehicles?: boolean | TenantCountOutputTypeCountVehiclesArgs
    bookings?: boolean | TenantCountOutputTypeCountBookingsArgs
    sessions?: boolean | TenantCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionSessionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type InspectorCountOutputType
   */

  export type InspectorCountOutputType = {
    sessions: number
  }

  export type InspectorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | InspectorCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * InspectorCountOutputType without action
   */
  export type InspectorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectorCountOutputType
     */
    select?: InspectorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InspectorCountOutputType without action
   */
  export type InspectorCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionSessionWhereInput
  }


  /**
   * Count Type OwnerCountOutputType
   */

  export type OwnerCountOutputType = {
    vehicles: number
  }

  export type OwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | OwnerCountOutputTypeCountVehiclesArgs
  }

  // Custom InputTypes
  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCountOutputType
     */
    select?: OwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    bookings: number
    sessions: number
    referrals: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | VehicleCountOutputTypeCountBookingsArgs
    sessions?: boolean | VehicleCountOutputTypeCountSessionsArgs
    referrals?: boolean | VehicleCountOutputTypeCountReferralsArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionSessionWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    sessions: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | BookingCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionSessionWhereInput
  }


  /**
   * Count Type InspectionItemCountOutputType
   */

  export type InspectionItemCountOutputType = {
    results: number
  }

  export type InspectionItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | InspectionItemCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * InspectionItemCountOutputType without action
   */
  export type InspectionItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItemCountOutputType
     */
    select?: InspectionItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InspectionItemCountOutputType without action
   */
  export type InspectionItemCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResultWhereInput
  }


  /**
   * Count Type InspectionSessionCountOutputType
   */

  export type InspectionSessionCountOutputType = {
    results: number
    mediaRefs: number
    originalReinspections: number
    referrals: number
  }

  export type InspectionSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | InspectionSessionCountOutputTypeCountResultsArgs
    mediaRefs?: boolean | InspectionSessionCountOutputTypeCountMediaRefsArgs
    originalReinspections?: boolean | InspectionSessionCountOutputTypeCountOriginalReinspectionsArgs
    referrals?: boolean | InspectionSessionCountOutputTypeCountReferralsArgs
  }

  // Custom InputTypes
  /**
   * InspectionSessionCountOutputType without action
   */
  export type InspectionSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSessionCountOutputType
     */
    select?: InspectionSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InspectionSessionCountOutputType without action
   */
  export type InspectionSessionCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResultWhereInput
  }

  /**
   * InspectionSessionCountOutputType without action
   */
  export type InspectionSessionCountOutputTypeCountMediaRefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaRefWhereInput
  }

  /**
   * InspectionSessionCountOutputType without action
   */
  export type InspectionSessionCountOutputTypeCountOriginalReinspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReinspectionLinkWhereInput
  }

  /**
   * InspectionSessionCountOutputType without action
   */
  export type InspectionSessionCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }


  /**
   * Count Type InsurerCountOutputType
   */

  export type InsurerCountOutputType = {
    users: number
    apiKeys: number
    apiUsageLogs: number
    agents: number
  }

  export type InsurerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | InsurerCountOutputTypeCountUsersArgs
    apiKeys?: boolean | InsurerCountOutputTypeCountApiKeysArgs
    apiUsageLogs?: boolean | InsurerCountOutputTypeCountApiUsageLogsArgs
    agents?: boolean | InsurerCountOutputTypeCountAgentsArgs
  }

  // Custom InputTypes
  /**
   * InsurerCountOutputType without action
   */
  export type InsurerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerCountOutputType
     */
    select?: InsurerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsurerCountOutputType without action
   */
  export type InsurerCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurerUserWhereInput
  }

  /**
   * InsurerCountOutputType without action
   */
  export type InsurerCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * InsurerCountOutputType without action
   */
  export type InsurerCountOutputTypeCountApiUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageLogWhereInput
  }

  /**
   * InsurerCountOutputType without action
   */
  export type InsurerCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    referrals: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | AgentCountOutputTypeCountReferralsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    id: number | null
    cluster: number | null
  }

  export type TenantSumAggregateOutputType = {
    id: number | null
    cluster: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: number | null
    name: string | null
    county: string | null
    cluster: number | null
    createdAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: number | null
    name: string | null
    county: string | null
    cluster: number | null
    createdAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    county: number
    cluster: number
    createdAt: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    id?: true
    cluster?: true
  }

  export type TenantSumAggregateInputType = {
    id?: true
    cluster?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    county?: true
    cluster?: true
    createdAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    county?: true
    cluster?: true
    createdAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    county?: true
    cluster?: true
    createdAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: number
    name: string
    county: string | null
    cluster: number | null
    createdAt: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    county?: boolean
    cluster?: boolean
    createdAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    vehicles?: boolean | Tenant$vehiclesArgs<ExtArgs>
    bookings?: boolean | Tenant$bookingsArgs<ExtArgs>
    sessions?: boolean | Tenant$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    county?: boolean
    cluster?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    county?: boolean
    cluster?: boolean
    createdAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    vehicles?: boolean | Tenant$vehiclesArgs<ExtArgs>
    bookings?: boolean | Tenant$bookingsArgs<ExtArgs>
    sessions?: boolean | Tenant$sessionsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      sessions: Prisma.$InspectionSessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      county: string | null
      cluster: number | null
      createdAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    vehicles<T extends Tenant$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Tenant$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Tenant$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'Int'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly county: FieldRef<"Tenant", 'String'>
    readonly cluster: FieldRef<"Tenant", 'Int'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.vehicles
   */
  export type Tenant$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Tenant.bookings
   */
  export type Tenant$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Tenant.sessions
   */
  export type Tenant$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    where?: InspectionSessionWhereInput
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    cursor?: InspectionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    tenantId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    tenantId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    tenantId: number | null
    fullName: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    tenantId: number | null
    fullName: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    fullName: number
    email: number
    phone: number
    passwordHash: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    tenantId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    tenantId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    fullName?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    fullName?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    fullName?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    tenantId: number | null
    fullName: string
    email: string | null
    phone: string | null
    passwordHash: string
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    inspector?: boolean | User$inspectorArgs<ExtArgs>
    insurerUser?: boolean | User$insurerUserArgs<ExtArgs>
    agent?: boolean | User$agentArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    inspector?: boolean | User$inspectorArgs<ExtArgs>
    insurerUser?: boolean | User$insurerUserArgs<ExtArgs>
    agent?: boolean | User$agentArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      inspector: Prisma.$InspectorPayload<ExtArgs> | null
      insurerUser: Prisma.$InsurerUserPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: number | null
      fullName: string
      email: string | null
      phone: string | null
      passwordHash: string
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inspector<T extends User$inspectorArgs<ExtArgs> = {}>(args?: Subset<T, User$inspectorArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    insurerUser<T extends User$insurerUserArgs<ExtArgs> = {}>(args?: Subset<T, User$insurerUserArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    agent<T extends User$agentArgs<ExtArgs> = {}>(args?: Subset<T, User$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly tenantId: FieldRef<"User", 'Int'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.inspector
   */
  export type User$inspectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    where?: InspectorWhereInput
  }

  /**
   * User.insurerUser
   */
  export type User$insurerUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    where?: InsurerUserWhereInput
  }

  /**
   * User.agent
   */
  export type User$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Inspector
   */

  export type AggregateInspector = {
    _count: InspectorCountAggregateOutputType | null
    _avg: InspectorAvgAggregateOutputType | null
    _sum: InspectorSumAggregateOutputType | null
    _min: InspectorMinAggregateOutputType | null
    _max: InspectorMaxAggregateOutputType | null
  }

  export type InspectorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    yearsExperience: number | null
  }

  export type InspectorSumAggregateOutputType = {
    id: number | null
    userId: number | null
    yearsExperience: number | null
  }

  export type InspectorMinAggregateOutputType = {
    id: number | null
    userId: number | null
    licenceNo: string | null
    licenceExpiry: Date | null
    qualification: string | null
    yearsExperience: number | null
    status: $Enums.InspectorStatus | null
  }

  export type InspectorMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    licenceNo: string | null
    licenceExpiry: Date | null
    qualification: string | null
    yearsExperience: number | null
    status: $Enums.InspectorStatus | null
  }

  export type InspectorCountAggregateOutputType = {
    id: number
    userId: number
    licenceNo: number
    licenceExpiry: number
    qualification: number
    yearsExperience: number
    status: number
    _all: number
  }


  export type InspectorAvgAggregateInputType = {
    id?: true
    userId?: true
    yearsExperience?: true
  }

  export type InspectorSumAggregateInputType = {
    id?: true
    userId?: true
    yearsExperience?: true
  }

  export type InspectorMinAggregateInputType = {
    id?: true
    userId?: true
    licenceNo?: true
    licenceExpiry?: true
    qualification?: true
    yearsExperience?: true
    status?: true
  }

  export type InspectorMaxAggregateInputType = {
    id?: true
    userId?: true
    licenceNo?: true
    licenceExpiry?: true
    qualification?: true
    yearsExperience?: true
    status?: true
  }

  export type InspectorCountAggregateInputType = {
    id?: true
    userId?: true
    licenceNo?: true
    licenceExpiry?: true
    qualification?: true
    yearsExperience?: true
    status?: true
    _all?: true
  }

  export type InspectorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inspector to aggregate.
     */
    where?: InspectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspectors to fetch.
     */
    orderBy?: InspectorOrderByWithRelationInput | InspectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inspectors
    **/
    _count?: true | InspectorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InspectorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InspectorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectorMaxAggregateInputType
  }

  export type GetInspectorAggregateType<T extends InspectorAggregateArgs> = {
        [P in keyof T & keyof AggregateInspector]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspector[P]>
      : GetScalarType<T[P], AggregateInspector[P]>
  }




  export type InspectorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectorWhereInput
    orderBy?: InspectorOrderByWithAggregationInput | InspectorOrderByWithAggregationInput[]
    by: InspectorScalarFieldEnum[] | InspectorScalarFieldEnum
    having?: InspectorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectorCountAggregateInputType | true
    _avg?: InspectorAvgAggregateInputType
    _sum?: InspectorSumAggregateInputType
    _min?: InspectorMinAggregateInputType
    _max?: InspectorMaxAggregateInputType
  }

  export type InspectorGroupByOutputType = {
    id: number
    userId: number
    licenceNo: string
    licenceExpiry: Date
    qualification: string | null
    yearsExperience: number | null
    status: $Enums.InspectorStatus
    _count: InspectorCountAggregateOutputType | null
    _avg: InspectorAvgAggregateOutputType | null
    _sum: InspectorSumAggregateOutputType | null
    _min: InspectorMinAggregateOutputType | null
    _max: InspectorMaxAggregateOutputType | null
  }

  type GetInspectorGroupByPayload<T extends InspectorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectorGroupByOutputType[P]>
            : GetScalarType<T[P], InspectorGroupByOutputType[P]>
        }
      >
    >


  export type InspectorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenceNo?: boolean
    licenceExpiry?: boolean
    qualification?: boolean
    yearsExperience?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Inspector$sessionsArgs<ExtArgs>
    _count?: boolean | InspectorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspector"]>

  export type InspectorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenceNo?: boolean
    licenceExpiry?: boolean
    qualification?: boolean
    yearsExperience?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspector"]>

  export type InspectorSelectScalar = {
    id?: boolean
    userId?: boolean
    licenceNo?: boolean
    licenceExpiry?: boolean
    qualification?: boolean
    yearsExperience?: boolean
    status?: boolean
  }

  export type InspectorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | Inspector$sessionsArgs<ExtArgs>
    _count?: boolean | InspectorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InspectorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InspectorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inspector"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sessions: Prisma.$InspectionSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      licenceNo: string
      licenceExpiry: Date
      qualification: string | null
      yearsExperience: number | null
      status: $Enums.InspectorStatus
    }, ExtArgs["result"]["inspector"]>
    composites: {}
  }

  type InspectorGetPayload<S extends boolean | null | undefined | InspectorDefaultArgs> = $Result.GetResult<Prisma.$InspectorPayload, S>

  type InspectorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InspectorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InspectorCountAggregateInputType | true
    }

  export interface InspectorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inspector'], meta: { name: 'Inspector' } }
    /**
     * Find zero or one Inspector that matches the filter.
     * @param {InspectorFindUniqueArgs} args - Arguments to find a Inspector
     * @example
     * // Get one Inspector
     * const inspector = await prisma.inspector.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectorFindUniqueArgs>(args: SelectSubset<T, InspectorFindUniqueArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inspector that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InspectorFindUniqueOrThrowArgs} args - Arguments to find a Inspector
     * @example
     * // Get one Inspector
     * const inspector = await prisma.inspector.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectorFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inspector that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorFindFirstArgs} args - Arguments to find a Inspector
     * @example
     * // Get one Inspector
     * const inspector = await prisma.inspector.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectorFindFirstArgs>(args?: SelectSubset<T, InspectorFindFirstArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inspector that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorFindFirstOrThrowArgs} args - Arguments to find a Inspector
     * @example
     * // Get one Inspector
     * const inspector = await prisma.inspector.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectorFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inspectors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inspectors
     * const inspectors = await prisma.inspector.findMany()
     * 
     * // Get first 10 Inspectors
     * const inspectors = await prisma.inspector.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectorWithIdOnly = await prisma.inspector.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectorFindManyArgs>(args?: SelectSubset<T, InspectorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inspector.
     * @param {InspectorCreateArgs} args - Arguments to create a Inspector.
     * @example
     * // Create one Inspector
     * const Inspector = await prisma.inspector.create({
     *   data: {
     *     // ... data to create a Inspector
     *   }
     * })
     * 
     */
    create<T extends InspectorCreateArgs>(args: SelectSubset<T, InspectorCreateArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inspectors.
     * @param {InspectorCreateManyArgs} args - Arguments to create many Inspectors.
     * @example
     * // Create many Inspectors
     * const inspector = await prisma.inspector.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectorCreateManyArgs>(args?: SelectSubset<T, InspectorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inspectors and returns the data saved in the database.
     * @param {InspectorCreateManyAndReturnArgs} args - Arguments to create many Inspectors.
     * @example
     * // Create many Inspectors
     * const inspector = await prisma.inspector.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inspectors and only return the `id`
     * const inspectorWithIdOnly = await prisma.inspector.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectorCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inspector.
     * @param {InspectorDeleteArgs} args - Arguments to delete one Inspector.
     * @example
     * // Delete one Inspector
     * const Inspector = await prisma.inspector.delete({
     *   where: {
     *     // ... filter to delete one Inspector
     *   }
     * })
     * 
     */
    delete<T extends InspectorDeleteArgs>(args: SelectSubset<T, InspectorDeleteArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inspector.
     * @param {InspectorUpdateArgs} args - Arguments to update one Inspector.
     * @example
     * // Update one Inspector
     * const inspector = await prisma.inspector.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectorUpdateArgs>(args: SelectSubset<T, InspectorUpdateArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inspectors.
     * @param {InspectorDeleteManyArgs} args - Arguments to filter Inspectors to delete.
     * @example
     * // Delete a few Inspectors
     * const { count } = await prisma.inspector.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectorDeleteManyArgs>(args?: SelectSubset<T, InspectorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inspectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inspectors
     * const inspector = await prisma.inspector.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectorUpdateManyArgs>(args: SelectSubset<T, InspectorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inspector.
     * @param {InspectorUpsertArgs} args - Arguments to update or create a Inspector.
     * @example
     * // Update or create a Inspector
     * const inspector = await prisma.inspector.upsert({
     *   create: {
     *     // ... data to create a Inspector
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inspector we want to update
     *   }
     * })
     */
    upsert<T extends InspectorUpsertArgs>(args: SelectSubset<T, InspectorUpsertArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inspectors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorCountArgs} args - Arguments to filter Inspectors to count.
     * @example
     * // Count the number of Inspectors
     * const count = await prisma.inspector.count({
     *   where: {
     *     // ... the filter for the Inspectors we want to count
     *   }
     * })
    **/
    count<T extends InspectorCountArgs>(
      args?: Subset<T, InspectorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inspector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectorAggregateArgs>(args: Subset<T, InspectorAggregateArgs>): Prisma.PrismaPromise<GetInspectorAggregateType<T>>

    /**
     * Group by Inspector.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectorGroupByArgs['orderBy'] }
        : { orderBy?: InspectorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inspector model
   */
  readonly fields: InspectorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inspector.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends Inspector$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Inspector$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inspector model
   */ 
  interface InspectorFieldRefs {
    readonly id: FieldRef<"Inspector", 'Int'>
    readonly userId: FieldRef<"Inspector", 'Int'>
    readonly licenceNo: FieldRef<"Inspector", 'String'>
    readonly licenceExpiry: FieldRef<"Inspector", 'DateTime'>
    readonly qualification: FieldRef<"Inspector", 'String'>
    readonly yearsExperience: FieldRef<"Inspector", 'Int'>
    readonly status: FieldRef<"Inspector", 'InspectorStatus'>
  }
    

  // Custom InputTypes
  /**
   * Inspector findUnique
   */
  export type InspectorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * Filter, which Inspector to fetch.
     */
    where: InspectorWhereUniqueInput
  }

  /**
   * Inspector findUniqueOrThrow
   */
  export type InspectorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * Filter, which Inspector to fetch.
     */
    where: InspectorWhereUniqueInput
  }

  /**
   * Inspector findFirst
   */
  export type InspectorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * Filter, which Inspector to fetch.
     */
    where?: InspectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspectors to fetch.
     */
    orderBy?: InspectorOrderByWithRelationInput | InspectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inspectors.
     */
    cursor?: InspectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inspectors.
     */
    distinct?: InspectorScalarFieldEnum | InspectorScalarFieldEnum[]
  }

  /**
   * Inspector findFirstOrThrow
   */
  export type InspectorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * Filter, which Inspector to fetch.
     */
    where?: InspectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspectors to fetch.
     */
    orderBy?: InspectorOrderByWithRelationInput | InspectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inspectors.
     */
    cursor?: InspectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspectors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inspectors.
     */
    distinct?: InspectorScalarFieldEnum | InspectorScalarFieldEnum[]
  }

  /**
   * Inspector findMany
   */
  export type InspectorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * Filter, which Inspectors to fetch.
     */
    where?: InspectorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inspectors to fetch.
     */
    orderBy?: InspectorOrderByWithRelationInput | InspectorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inspectors.
     */
    cursor?: InspectorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inspectors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inspectors.
     */
    skip?: number
    distinct?: InspectorScalarFieldEnum | InspectorScalarFieldEnum[]
  }

  /**
   * Inspector create
   */
  export type InspectorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * The data needed to create a Inspector.
     */
    data: XOR<InspectorCreateInput, InspectorUncheckedCreateInput>
  }

  /**
   * Inspector createMany
   */
  export type InspectorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inspectors.
     */
    data: InspectorCreateManyInput | InspectorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inspector createManyAndReturn
   */
  export type InspectorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Inspectors.
     */
    data: InspectorCreateManyInput | InspectorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inspector update
   */
  export type InspectorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * The data needed to update a Inspector.
     */
    data: XOR<InspectorUpdateInput, InspectorUncheckedUpdateInput>
    /**
     * Choose, which Inspector to update.
     */
    where: InspectorWhereUniqueInput
  }

  /**
   * Inspector updateMany
   */
  export type InspectorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inspectors.
     */
    data: XOR<InspectorUpdateManyMutationInput, InspectorUncheckedUpdateManyInput>
    /**
     * Filter which Inspectors to update
     */
    where?: InspectorWhereInput
  }

  /**
   * Inspector upsert
   */
  export type InspectorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * The filter to search for the Inspector to update in case it exists.
     */
    where: InspectorWhereUniqueInput
    /**
     * In case the Inspector found by the `where` argument doesn't exist, create a new Inspector with this data.
     */
    create: XOR<InspectorCreateInput, InspectorUncheckedCreateInput>
    /**
     * In case the Inspector was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectorUpdateInput, InspectorUncheckedUpdateInput>
  }

  /**
   * Inspector delete
   */
  export type InspectorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    /**
     * Filter which Inspector to delete.
     */
    where: InspectorWhereUniqueInput
  }

  /**
   * Inspector deleteMany
   */
  export type InspectorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inspectors to delete
     */
    where?: InspectorWhereInput
  }

  /**
   * Inspector.sessions
   */
  export type Inspector$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    where?: InspectionSessionWhereInput
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    cursor?: InspectionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * Inspector without action
   */
  export type InspectorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
  }


  /**
   * Model Owner
   */

  export type AggregateOwner = {
    _count: OwnerCountAggregateOutputType | null
    _avg: OwnerAvgAggregateOutputType | null
    _sum: OwnerSumAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  export type OwnerAvgAggregateOutputType = {
    id: number | null
  }

  export type OwnerSumAggregateOutputType = {
    id: number | null
  }

  export type OwnerMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    idNo: string | null
    phone: string | null
    email: string | null
    address: string | null
  }

  export type OwnerMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    idNo: string | null
    phone: string | null
    email: string | null
    address: string | null
  }

  export type OwnerCountAggregateOutputType = {
    id: number
    fullName: number
    idNo: number
    phone: number
    email: number
    address: number
    _all: number
  }


  export type OwnerAvgAggregateInputType = {
    id?: true
  }

  export type OwnerSumAggregateInputType = {
    id?: true
  }

  export type OwnerMinAggregateInputType = {
    id?: true
    fullName?: true
    idNo?: true
    phone?: true
    email?: true
    address?: true
  }

  export type OwnerMaxAggregateInputType = {
    id?: true
    fullName?: true
    idNo?: true
    phone?: true
    email?: true
    address?: true
  }

  export type OwnerCountAggregateInputType = {
    id?: true
    fullName?: true
    idNo?: true
    phone?: true
    email?: true
    address?: true
    _all?: true
  }

  export type OwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owner to aggregate.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners
    **/
    _count?: true | OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerMaxAggregateInputType
  }

  export type GetOwnerAggregateType<T extends OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwner[P]>
      : GetScalarType<T[P], AggregateOwner[P]>
  }




  export type OwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithAggregationInput | OwnerOrderByWithAggregationInput[]
    by: OwnerScalarFieldEnum[] | OwnerScalarFieldEnum
    having?: OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCountAggregateInputType | true
    _avg?: OwnerAvgAggregateInputType
    _sum?: OwnerSumAggregateInputType
    _min?: OwnerMinAggregateInputType
    _max?: OwnerMaxAggregateInputType
  }

  export type OwnerGroupByOutputType = {
    id: number
    fullName: string
    idNo: string | null
    phone: string | null
    email: string | null
    address: string | null
    _count: OwnerCountAggregateOutputType | null
    _avg: OwnerAvgAggregateOutputType | null
    _sum: OwnerSumAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  type GetOwnerGroupByPayload<T extends OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerGroupByOutputType[P]>
        }
      >
    >


  export type OwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    idNo?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    vehicles?: boolean | Owner$vehiclesArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    idNo?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectScalar = {
    id?: boolean
    fullName?: boolean
    idNo?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
  }

  export type OwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | Owner$vehiclesArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owner"
    objects: {
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      idNo: string | null
      phone: string | null
      email: string | null
      address: string | null
    }, ExtArgs["result"]["owner"]>
    composites: {}
  }

  type OwnerGetPayload<S extends boolean | null | undefined | OwnerDefaultArgs> = $Result.GetResult<Prisma.$OwnerPayload, S>

  type OwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerCountAggregateInputType | true
    }

  export interface OwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owner'], meta: { name: 'Owner' } }
    /**
     * Find zero or one Owner that matches the filter.
     * @param {OwnerFindUniqueArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerFindUniqueArgs>(args: SelectSubset<T, OwnerFindUniqueArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Owner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerFindUniqueOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerFindFirstArgs>(args?: SelectSubset<T, OwnerFindFirstArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owner.findMany()
     * 
     * // Get first 10 Owners
     * const owners = await prisma.owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerFindManyArgs>(args?: SelectSubset<T, OwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Owner.
     * @param {OwnerCreateArgs} args - Arguments to create a Owner.
     * @example
     * // Create one Owner
     * const Owner = await prisma.owner.create({
     *   data: {
     *     // ... data to create a Owner
     *   }
     * })
     * 
     */
    create<T extends OwnerCreateArgs>(args: SelectSubset<T, OwnerCreateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Owners.
     * @param {OwnerCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerCreateManyArgs>(args?: SelectSubset<T, OwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Owners and returns the data saved in the database.
     * @param {OwnerCreateManyAndReturnArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Owners and only return the `id`
     * const ownerWithIdOnly = await prisma.owner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Owner.
     * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
     * @example
     * // Delete one Owner
     * const Owner = await prisma.owner.delete({
     *   where: {
     *     // ... filter to delete one Owner
     *   }
     * })
     * 
     */
    delete<T extends OwnerDeleteArgs>(args: SelectSubset<T, OwnerDeleteArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Owner.
     * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
     * @example
     * // Update one Owner
     * const owner = await prisma.owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerUpdateArgs>(args: SelectSubset<T, OwnerUpdateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Owners.
     * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDeleteManyArgs>(args?: SelectSubset<T, OwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerUpdateManyArgs>(args: SelectSubset<T, OwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owner.
     * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
     * @example
     * // Update or create a Owner
     * const owner = await prisma.owner.upsert({
     *   create: {
     *     // ... data to create a Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owner we want to update
     *   }
     * })
     */
    upsert<T extends OwnerUpsertArgs>(args: SelectSubset<T, OwnerUpsertArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owner.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
    **/
    count<T extends OwnerCountArgs>(
      args?: Subset<T, OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerAggregateArgs>(args: Subset<T, OwnerAggregateArgs>): Prisma.PrismaPromise<GetOwnerAggregateType<T>>

    /**
     * Group by Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerGroupByArgs['orderBy'] }
        : { orderBy?: OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owner model
   */
  readonly fields: OwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicles<T extends Owner$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Owner$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owner model
   */ 
  interface OwnerFieldRefs {
    readonly id: FieldRef<"Owner", 'Int'>
    readonly fullName: FieldRef<"Owner", 'String'>
    readonly idNo: FieldRef<"Owner", 'String'>
    readonly phone: FieldRef<"Owner", 'String'>
    readonly email: FieldRef<"Owner", 'String'>
    readonly address: FieldRef<"Owner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Owner findUnique
   */
  export type OwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findUniqueOrThrow
   */
  export type OwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findFirst
   */
  export type OwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findFirstOrThrow
   */
  export type OwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findMany
   */
  export type OwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owners to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner create
   */
  export type OwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Owner.
     */
    data: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
  }

  /**
   * Owner createMany
   */
  export type OwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner createManyAndReturn
   */
  export type OwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner update
   */
  export type OwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Owner.
     */
    data: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
    /**
     * Choose, which Owner to update.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner updateMany
   */
  export type OwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner upsert
   */
  export type OwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Owner to update in case it exists.
     */
    where: OwnerWhereUniqueInput
    /**
     * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
     */
    create: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
    /**
     * In case the Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
  }

  /**
   * Owner delete
   */
  export type OwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter which Owner to delete.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner deleteMany
   */
  export type OwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners to delete
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner.vehicles
   */
  export type Owner$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Owner without action
   */
  export type OwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    id: number | null
    tenantId: number | null
    ownerId: number | null
    yearOfMfg: number | null
    tareWeightKg: number | null
    engineCc: number | null
    evBatteryKwh: number | null
  }

  export type VehicleSumAggregateOutputType = {
    id: number | null
    tenantId: number | null
    ownerId: number | null
    yearOfMfg: number | null
    tareWeightKg: number | null
    engineCc: number | null
    evBatteryKwh: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: number | null
    tenantId: number | null
    ownerId: number | null
    registrationNo: string | null
    vin: string | null
    engineNo: string | null
    make: string | null
    model: string | null
    yearOfMfg: number | null
    category: $Enums.VehicleCategory | null
    tareWeightKg: number | null
    engineCc: number | null
    evBatteryKwh: number | null
    telematicsImei: string | null
    speedGovernorSerial: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: number | null
    tenantId: number | null
    ownerId: number | null
    registrationNo: string | null
    vin: string | null
    engineNo: string | null
    make: string | null
    model: string | null
    yearOfMfg: number | null
    category: $Enums.VehicleCategory | null
    tareWeightKg: number | null
    engineCc: number | null
    evBatteryKwh: number | null
    telematicsImei: string | null
    speedGovernorSerial: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    tenantId: number
    ownerId: number
    registrationNo: number
    vin: number
    engineNo: number
    make: number
    model: number
    yearOfMfg: number
    category: number
    tareWeightKg: number
    engineCc: number
    evBatteryKwh: number
    telematicsImei: number
    speedGovernorSerial: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    id?: true
    tenantId?: true
    ownerId?: true
    yearOfMfg?: true
    tareWeightKg?: true
    engineCc?: true
    evBatteryKwh?: true
  }

  export type VehicleSumAggregateInputType = {
    id?: true
    tenantId?: true
    ownerId?: true
    yearOfMfg?: true
    tareWeightKg?: true
    engineCc?: true
    evBatteryKwh?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    tenantId?: true
    ownerId?: true
    registrationNo?: true
    vin?: true
    engineNo?: true
    make?: true
    model?: true
    yearOfMfg?: true
    category?: true
    tareWeightKg?: true
    engineCc?: true
    evBatteryKwh?: true
    telematicsImei?: true
    speedGovernorSerial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    ownerId?: true
    registrationNo?: true
    vin?: true
    engineNo?: true
    make?: true
    model?: true
    yearOfMfg?: true
    category?: true
    tareWeightKg?: true
    engineCc?: true
    evBatteryKwh?: true
    telematicsImei?: true
    speedGovernorSerial?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    tenantId?: true
    ownerId?: true
    registrationNo?: true
    vin?: true
    engineNo?: true
    make?: true
    model?: true
    yearOfMfg?: true
    category?: true
    tareWeightKg?: true
    engineCc?: true
    evBatteryKwh?: true
    telematicsImei?: true
    speedGovernorSerial?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: number
    tenantId: number
    ownerId: number | null
    registrationNo: string
    vin: string | null
    engineNo: string | null
    make: string | null
    model: string | null
    yearOfMfg: number | null
    category: $Enums.VehicleCategory
    tareWeightKg: number | null
    engineCc: number | null
    evBatteryKwh: number | null
    telematicsImei: string | null
    speedGovernorSerial: string | null
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    ownerId?: boolean
    registrationNo?: boolean
    vin?: boolean
    engineNo?: boolean
    make?: boolean
    model?: boolean
    yearOfMfg?: boolean
    category?: boolean
    tareWeightKg?: boolean
    engineCc?: boolean
    evBatteryKwh?: boolean
    telematicsImei?: boolean
    speedGovernorSerial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | Vehicle$ownerArgs<ExtArgs>
    bookings?: boolean | Vehicle$bookingsArgs<ExtArgs>
    sessions?: boolean | Vehicle$sessionsArgs<ExtArgs>
    referrals?: boolean | Vehicle$referralsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    ownerId?: boolean
    registrationNo?: boolean
    vin?: boolean
    engineNo?: boolean
    make?: boolean
    model?: boolean
    yearOfMfg?: boolean
    category?: boolean
    tareWeightKg?: boolean
    engineCc?: boolean
    evBatteryKwh?: boolean
    telematicsImei?: boolean
    speedGovernorSerial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | Vehicle$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    ownerId?: boolean
    registrationNo?: boolean
    vin?: boolean
    engineNo?: boolean
    make?: boolean
    model?: boolean
    yearOfMfg?: boolean
    category?: boolean
    tareWeightKg?: boolean
    engineCc?: boolean
    evBatteryKwh?: boolean
    telematicsImei?: boolean
    speedGovernorSerial?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | Vehicle$ownerArgs<ExtArgs>
    bookings?: boolean | Vehicle$bookingsArgs<ExtArgs>
    sessions?: boolean | Vehicle$sessionsArgs<ExtArgs>
    referrals?: boolean | Vehicle$referralsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    owner?: boolean | Vehicle$ownerArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      owner: Prisma.$OwnerPayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      sessions: Prisma.$InspectionSessionPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: number
      ownerId: number | null
      registrationNo: string
      vin: string | null
      engineNo: string | null
      make: string | null
      model: string | null
      yearOfMfg: number | null
      category: $Enums.VehicleCategory
      tareWeightKg: number | null
      engineCc: number | null
      evBatteryKwh: number | null
      telematicsImei: string | null
      speedGovernorSerial: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends Vehicle$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$ownerArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bookings<T extends Vehicle$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Vehicle$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findMany"> | Null>
    referrals<T extends Vehicle$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */ 
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'Int'>
    readonly tenantId: FieldRef<"Vehicle", 'Int'>
    readonly ownerId: FieldRef<"Vehicle", 'Int'>
    readonly registrationNo: FieldRef<"Vehicle", 'String'>
    readonly vin: FieldRef<"Vehicle", 'String'>
    readonly engineNo: FieldRef<"Vehicle", 'String'>
    readonly make: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly yearOfMfg: FieldRef<"Vehicle", 'Int'>
    readonly category: FieldRef<"Vehicle", 'VehicleCategory'>
    readonly tareWeightKg: FieldRef<"Vehicle", 'Int'>
    readonly engineCc: FieldRef<"Vehicle", 'Int'>
    readonly evBatteryKwh: FieldRef<"Vehicle", 'Int'>
    readonly telematicsImei: FieldRef<"Vehicle", 'String'>
    readonly speedGovernorSerial: FieldRef<"Vehicle", 'String'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
  }

  /**
   * Vehicle.owner
   */
  export type Vehicle$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    where?: OwnerWhereInput
  }

  /**
   * Vehicle.bookings
   */
  export type Vehicle$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Vehicle.sessions
   */
  export type Vehicle$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    where?: InspectionSessionWhereInput
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    cursor?: InspectionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * Vehicle.referrals
   */
  export type Vehicle$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
    bookingRef: string | null
    bookingFeePaid: boolean | null
    bookingFeeReceiptNo: string | null
    bookedForDate: Date | null
    status: $Enums.BookingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
    bookingRef: string | null
    bookingFeePaid: boolean | null
    bookingFeeReceiptNo: string | null
    bookedForDate: Date | null
    status: $Enums.BookingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    tenantId: number
    vehicleId: number
    bookingRef: number
    bookingFeePaid: number
    bookingFeeReceiptNo: number
    bookedForDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingRef?: true
    bookingFeePaid?: true
    bookingFeeReceiptNo?: true
    bookedForDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingRef?: true
    bookingFeePaid?: true
    bookingFeeReceiptNo?: true
    bookedForDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingRef?: true
    bookingFeePaid?: true
    bookingFeeReceiptNo?: true
    bookedForDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    tenantId: number
    vehicleId: number
    bookingRef: string | null
    bookingFeePaid: boolean
    bookingFeeReceiptNo: string | null
    bookedForDate: Date | null
    status: $Enums.BookingStatus
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    vehicleId?: boolean
    bookingRef?: boolean
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: boolean
    bookedForDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    sessions?: boolean | Booking$sessionsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    vehicleId?: boolean
    bookingRef?: boolean
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: boolean
    bookedForDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    vehicleId?: boolean
    bookingRef?: boolean
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: boolean
    bookedForDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    sessions?: boolean | Booking$sessionsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      sessions: Prisma.$InspectionSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: number
      vehicleId: number
      bookingRef: string | null
      bookingFeePaid: boolean
      bookingFeeReceiptNo: string | null
      bookedForDate: Date | null
      status: $Enums.BookingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends Booking$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly tenantId: FieldRef<"Booking", 'Int'>
    readonly vehicleId: FieldRef<"Booking", 'Int'>
    readonly bookingRef: FieldRef<"Booking", 'String'>
    readonly bookingFeePaid: FieldRef<"Booking", 'Boolean'>
    readonly bookingFeeReceiptNo: FieldRef<"Booking", 'String'>
    readonly bookedForDate: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.sessions
   */
  export type Booking$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    where?: InspectionSessionWhereInput
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    cursor?: InspectionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model InspectionItem
   */

  export type AggregateInspectionItem = {
    _count: InspectionItemCountAggregateOutputType | null
    _avg: InspectionItemAvgAggregateOutputType | null
    _sum: InspectionItemSumAggregateOutputType | null
    _min: InspectionItemMinAggregateOutputType | null
    _max: InspectionItemMaxAggregateOutputType | null
  }

  export type InspectionItemAvgAggregateOutputType = {
    id: number | null
    weightPct: number | null
  }

  export type InspectionItemSumAggregateOutputType = {
    id: number | null
    weightPct: number | null
  }

  export type InspectionItemMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    group: $Enums.ItemGroup | null
    weightPct: number | null
  }

  export type InspectionItemMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    group: $Enums.ItemGroup | null
    weightPct: number | null
  }

  export type InspectionItemCountAggregateOutputType = {
    id: number
    code: number
    name: number
    group: number
    weightPct: number
    requiredForCategories: number
    _all: number
  }


  export type InspectionItemAvgAggregateInputType = {
    id?: true
    weightPct?: true
  }

  export type InspectionItemSumAggregateInputType = {
    id?: true
    weightPct?: true
  }

  export type InspectionItemMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    group?: true
    weightPct?: true
  }

  export type InspectionItemMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    group?: true
    weightPct?: true
  }

  export type InspectionItemCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    group?: true
    weightPct?: true
    requiredForCategories?: true
    _all?: true
  }

  export type InspectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionItem to aggregate.
     */
    where?: InspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionItems to fetch.
     */
    orderBy?: InspectionItemOrderByWithRelationInput | InspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InspectionItems
    **/
    _count?: true | InspectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InspectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InspectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectionItemMaxAggregateInputType
  }

  export type GetInspectionItemAggregateType<T extends InspectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInspectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspectionItem[P]>
      : GetScalarType<T[P], AggregateInspectionItem[P]>
  }




  export type InspectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionItemWhereInput
    orderBy?: InspectionItemOrderByWithAggregationInput | InspectionItemOrderByWithAggregationInput[]
    by: InspectionItemScalarFieldEnum[] | InspectionItemScalarFieldEnum
    having?: InspectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectionItemCountAggregateInputType | true
    _avg?: InspectionItemAvgAggregateInputType
    _sum?: InspectionItemSumAggregateInputType
    _min?: InspectionItemMinAggregateInputType
    _max?: InspectionItemMaxAggregateInputType
  }

  export type InspectionItemGroupByOutputType = {
    id: number
    code: string
    name: string
    group: $Enums.ItemGroup
    weightPct: number
    requiredForCategories: JsonValue | null
    _count: InspectionItemCountAggregateOutputType | null
    _avg: InspectionItemAvgAggregateOutputType | null
    _sum: InspectionItemSumAggregateOutputType | null
    _min: InspectionItemMinAggregateOutputType | null
    _max: InspectionItemMaxAggregateOutputType | null
  }

  type GetInspectionItemGroupByPayload<T extends InspectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], InspectionItemGroupByOutputType[P]>
        }
      >
    >


  export type InspectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    group?: boolean
    weightPct?: boolean
    requiredForCategories?: boolean
    results?: boolean | InspectionItem$resultsArgs<ExtArgs>
    _count?: boolean | InspectionItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionItem"]>

  export type InspectionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    group?: boolean
    weightPct?: boolean
    requiredForCategories?: boolean
  }, ExtArgs["result"]["inspectionItem"]>

  export type InspectionItemSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    group?: boolean
    weightPct?: boolean
    requiredForCategories?: boolean
  }

  export type InspectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | InspectionItem$resultsArgs<ExtArgs>
    _count?: boolean | InspectionItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InspectionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InspectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InspectionItem"
    objects: {
      results: Prisma.$InspectionResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      group: $Enums.ItemGroup
      weightPct: number
      requiredForCategories: Prisma.JsonValue | null
    }, ExtArgs["result"]["inspectionItem"]>
    composites: {}
  }

  type InspectionItemGetPayload<S extends boolean | null | undefined | InspectionItemDefaultArgs> = $Result.GetResult<Prisma.$InspectionItemPayload, S>

  type InspectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InspectionItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InspectionItemCountAggregateInputType | true
    }

  export interface InspectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InspectionItem'], meta: { name: 'InspectionItem' } }
    /**
     * Find zero or one InspectionItem that matches the filter.
     * @param {InspectionItemFindUniqueArgs} args - Arguments to find a InspectionItem
     * @example
     * // Get one InspectionItem
     * const inspectionItem = await prisma.inspectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectionItemFindUniqueArgs>(args: SelectSubset<T, InspectionItemFindUniqueArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InspectionItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InspectionItemFindUniqueOrThrowArgs} args - Arguments to find a InspectionItem
     * @example
     * // Get one InspectionItem
     * const inspectionItem = await prisma.inspectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InspectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemFindFirstArgs} args - Arguments to find a InspectionItem
     * @example
     * // Get one InspectionItem
     * const inspectionItem = await prisma.inspectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectionItemFindFirstArgs>(args?: SelectSubset<T, InspectionItemFindFirstArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InspectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemFindFirstOrThrowArgs} args - Arguments to find a InspectionItem
     * @example
     * // Get one InspectionItem
     * const inspectionItem = await prisma.inspectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InspectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InspectionItems
     * const inspectionItems = await prisma.inspectionItem.findMany()
     * 
     * // Get first 10 InspectionItems
     * const inspectionItems = await prisma.inspectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectionItemWithIdOnly = await prisma.inspectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectionItemFindManyArgs>(args?: SelectSubset<T, InspectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InspectionItem.
     * @param {InspectionItemCreateArgs} args - Arguments to create a InspectionItem.
     * @example
     * // Create one InspectionItem
     * const InspectionItem = await prisma.inspectionItem.create({
     *   data: {
     *     // ... data to create a InspectionItem
     *   }
     * })
     * 
     */
    create<T extends InspectionItemCreateArgs>(args: SelectSubset<T, InspectionItemCreateArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InspectionItems.
     * @param {InspectionItemCreateManyArgs} args - Arguments to create many InspectionItems.
     * @example
     * // Create many InspectionItems
     * const inspectionItem = await prisma.inspectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectionItemCreateManyArgs>(args?: SelectSubset<T, InspectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InspectionItems and returns the data saved in the database.
     * @param {InspectionItemCreateManyAndReturnArgs} args - Arguments to create many InspectionItems.
     * @example
     * // Create many InspectionItems
     * const inspectionItem = await prisma.inspectionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InspectionItems and only return the `id`
     * const inspectionItemWithIdOnly = await prisma.inspectionItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InspectionItem.
     * @param {InspectionItemDeleteArgs} args - Arguments to delete one InspectionItem.
     * @example
     * // Delete one InspectionItem
     * const InspectionItem = await prisma.inspectionItem.delete({
     *   where: {
     *     // ... filter to delete one InspectionItem
     *   }
     * })
     * 
     */
    delete<T extends InspectionItemDeleteArgs>(args: SelectSubset<T, InspectionItemDeleteArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InspectionItem.
     * @param {InspectionItemUpdateArgs} args - Arguments to update one InspectionItem.
     * @example
     * // Update one InspectionItem
     * const inspectionItem = await prisma.inspectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectionItemUpdateArgs>(args: SelectSubset<T, InspectionItemUpdateArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InspectionItems.
     * @param {InspectionItemDeleteManyArgs} args - Arguments to filter InspectionItems to delete.
     * @example
     * // Delete a few InspectionItems
     * const { count } = await prisma.inspectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectionItemDeleteManyArgs>(args?: SelectSubset<T, InspectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InspectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InspectionItems
     * const inspectionItem = await prisma.inspectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectionItemUpdateManyArgs>(args: SelectSubset<T, InspectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InspectionItem.
     * @param {InspectionItemUpsertArgs} args - Arguments to update or create a InspectionItem.
     * @example
     * // Update or create a InspectionItem
     * const inspectionItem = await prisma.inspectionItem.upsert({
     *   create: {
     *     // ... data to create a InspectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InspectionItem we want to update
     *   }
     * })
     */
    upsert<T extends InspectionItemUpsertArgs>(args: SelectSubset<T, InspectionItemUpsertArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InspectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemCountArgs} args - Arguments to filter InspectionItems to count.
     * @example
     * // Count the number of InspectionItems
     * const count = await prisma.inspectionItem.count({
     *   where: {
     *     // ... the filter for the InspectionItems we want to count
     *   }
     * })
    **/
    count<T extends InspectionItemCountArgs>(
      args?: Subset<T, InspectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InspectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectionItemAggregateArgs>(args: Subset<T, InspectionItemAggregateArgs>): Prisma.PrismaPromise<GetInspectionItemAggregateType<T>>

    /**
     * Group by InspectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectionItemGroupByArgs['orderBy'] }
        : { orderBy?: InspectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InspectionItem model
   */
  readonly fields: InspectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InspectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    results<T extends InspectionItem$resultsArgs<ExtArgs> = {}>(args?: Subset<T, InspectionItem$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InspectionItem model
   */ 
  interface InspectionItemFieldRefs {
    readonly id: FieldRef<"InspectionItem", 'Int'>
    readonly code: FieldRef<"InspectionItem", 'String'>
    readonly name: FieldRef<"InspectionItem", 'String'>
    readonly group: FieldRef<"InspectionItem", 'ItemGroup'>
    readonly weightPct: FieldRef<"InspectionItem", 'Int'>
    readonly requiredForCategories: FieldRef<"InspectionItem", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * InspectionItem findUnique
   */
  export type InspectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which InspectionItem to fetch.
     */
    where: InspectionItemWhereUniqueInput
  }

  /**
   * InspectionItem findUniqueOrThrow
   */
  export type InspectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which InspectionItem to fetch.
     */
    where: InspectionItemWhereUniqueInput
  }

  /**
   * InspectionItem findFirst
   */
  export type InspectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which InspectionItem to fetch.
     */
    where?: InspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionItems to fetch.
     */
    orderBy?: InspectionItemOrderByWithRelationInput | InspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionItems.
     */
    cursor?: InspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionItems.
     */
    distinct?: InspectionItemScalarFieldEnum | InspectionItemScalarFieldEnum[]
  }

  /**
   * InspectionItem findFirstOrThrow
   */
  export type InspectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which InspectionItem to fetch.
     */
    where?: InspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionItems to fetch.
     */
    orderBy?: InspectionItemOrderByWithRelationInput | InspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionItems.
     */
    cursor?: InspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionItems.
     */
    distinct?: InspectionItemScalarFieldEnum | InspectionItemScalarFieldEnum[]
  }

  /**
   * InspectionItem findMany
   */
  export type InspectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * Filter, which InspectionItems to fetch.
     */
    where?: InspectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionItems to fetch.
     */
    orderBy?: InspectionItemOrderByWithRelationInput | InspectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InspectionItems.
     */
    cursor?: InspectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionItems.
     */
    skip?: number
    distinct?: InspectionItemScalarFieldEnum | InspectionItemScalarFieldEnum[]
  }

  /**
   * InspectionItem create
   */
  export type InspectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InspectionItem.
     */
    data: XOR<InspectionItemCreateInput, InspectionItemUncheckedCreateInput>
  }

  /**
   * InspectionItem createMany
   */
  export type InspectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InspectionItems.
     */
    data: InspectionItemCreateManyInput | InspectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InspectionItem createManyAndReturn
   */
  export type InspectionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InspectionItems.
     */
    data: InspectionItemCreateManyInput | InspectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InspectionItem update
   */
  export type InspectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InspectionItem.
     */
    data: XOR<InspectionItemUpdateInput, InspectionItemUncheckedUpdateInput>
    /**
     * Choose, which InspectionItem to update.
     */
    where: InspectionItemWhereUniqueInput
  }

  /**
   * InspectionItem updateMany
   */
  export type InspectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InspectionItems.
     */
    data: XOR<InspectionItemUpdateManyMutationInput, InspectionItemUncheckedUpdateManyInput>
    /**
     * Filter which InspectionItems to update
     */
    where?: InspectionItemWhereInput
  }

  /**
   * InspectionItem upsert
   */
  export type InspectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InspectionItem to update in case it exists.
     */
    where: InspectionItemWhereUniqueInput
    /**
     * In case the InspectionItem found by the `where` argument doesn't exist, create a new InspectionItem with this data.
     */
    create: XOR<InspectionItemCreateInput, InspectionItemUncheckedCreateInput>
    /**
     * In case the InspectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectionItemUpdateInput, InspectionItemUncheckedUpdateInput>
  }

  /**
   * InspectionItem delete
   */
  export type InspectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
    /**
     * Filter which InspectionItem to delete.
     */
    where: InspectionItemWhereUniqueInput
  }

  /**
   * InspectionItem deleteMany
   */
  export type InspectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionItems to delete
     */
    where?: InspectionItemWhereInput
  }

  /**
   * InspectionItem.results
   */
  export type InspectionItem$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    where?: InspectionResultWhereInput
    orderBy?: InspectionResultOrderByWithRelationInput | InspectionResultOrderByWithRelationInput[]
    cursor?: InspectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionResultScalarFieldEnum | InspectionResultScalarFieldEnum[]
  }

  /**
   * InspectionItem without action
   */
  export type InspectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionItem
     */
    select?: InspectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionItemInclude<ExtArgs> | null
  }


  /**
   * Model InspectionSession
   */

  export type AggregateInspectionSession = {
    _count: InspectionSessionCountAggregateOutputType | null
    _avg: InspectionSessionAvgAggregateOutputType | null
    _sum: InspectionSessionSumAggregateOutputType | null
    _min: InspectionSessionMinAggregateOutputType | null
    _max: InspectionSessionMaxAggregateOutputType | null
  }

  export type InspectionSessionAvgAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
    bookingId: number | null
    inspectorId: number | null
    odometerKm: number | null
    passThreshold: number | null
    totalScore: number | null
  }

  export type InspectionSessionSumAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
    bookingId: number | null
    inspectorId: number | null
    odometerKm: number | null
    passThreshold: number | null
    totalScore: number | null
  }

  export type InspectionSessionMinAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
    bookingId: number | null
    inspectorId: number | null
    inspectedAt: Date | null
    inspectionType: $Enums.InspectionType | null
    odometerKm: number | null
    notes: string | null
    status: $Enums.InspectionStatus | null
    passThreshold: number | null
    totalScore: number | null
    defectSeverity: $Enums.DefectSeverity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InspectionSessionMaxAggregateOutputType = {
    id: number | null
    tenantId: number | null
    vehicleId: number | null
    bookingId: number | null
    inspectorId: number | null
    inspectedAt: Date | null
    inspectionType: $Enums.InspectionType | null
    odometerKm: number | null
    notes: string | null
    status: $Enums.InspectionStatus | null
    passThreshold: number | null
    totalScore: number | null
    defectSeverity: $Enums.DefectSeverity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InspectionSessionCountAggregateOutputType = {
    id: number
    tenantId: number
    vehicleId: number
    bookingId: number
    inspectorId: number
    inspectedAt: number
    inspectionType: number
    odometerKm: number
    notes: number
    status: number
    passThreshold: number
    totalScore: number
    defectSeverity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InspectionSessionAvgAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingId?: true
    inspectorId?: true
    odometerKm?: true
    passThreshold?: true
    totalScore?: true
  }

  export type InspectionSessionSumAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingId?: true
    inspectorId?: true
    odometerKm?: true
    passThreshold?: true
    totalScore?: true
  }

  export type InspectionSessionMinAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingId?: true
    inspectorId?: true
    inspectedAt?: true
    inspectionType?: true
    odometerKm?: true
    notes?: true
    status?: true
    passThreshold?: true
    totalScore?: true
    defectSeverity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InspectionSessionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingId?: true
    inspectorId?: true
    inspectedAt?: true
    inspectionType?: true
    odometerKm?: true
    notes?: true
    status?: true
    passThreshold?: true
    totalScore?: true
    defectSeverity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InspectionSessionCountAggregateInputType = {
    id?: true
    tenantId?: true
    vehicleId?: true
    bookingId?: true
    inspectorId?: true
    inspectedAt?: true
    inspectionType?: true
    odometerKm?: true
    notes?: true
    status?: true
    passThreshold?: true
    totalScore?: true
    defectSeverity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InspectionSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionSession to aggregate.
     */
    where?: InspectionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionSessions to fetch.
     */
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InspectionSessions
    **/
    _count?: true | InspectionSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InspectionSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InspectionSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectionSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectionSessionMaxAggregateInputType
  }

  export type GetInspectionSessionAggregateType<T extends InspectionSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateInspectionSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspectionSession[P]>
      : GetScalarType<T[P], AggregateInspectionSession[P]>
  }




  export type InspectionSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionSessionWhereInput
    orderBy?: InspectionSessionOrderByWithAggregationInput | InspectionSessionOrderByWithAggregationInput[]
    by: InspectionSessionScalarFieldEnum[] | InspectionSessionScalarFieldEnum
    having?: InspectionSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectionSessionCountAggregateInputType | true
    _avg?: InspectionSessionAvgAggregateInputType
    _sum?: InspectionSessionSumAggregateInputType
    _min?: InspectionSessionMinAggregateInputType
    _max?: InspectionSessionMaxAggregateInputType
  }

  export type InspectionSessionGroupByOutputType = {
    id: number
    tenantId: number
    vehicleId: number
    bookingId: number | null
    inspectorId: number | null
    inspectedAt: Date | null
    inspectionType: $Enums.InspectionType
    odometerKm: number | null
    notes: string | null
    status: $Enums.InspectionStatus
    passThreshold: number
    totalScore: number
    defectSeverity: $Enums.DefectSeverity
    createdAt: Date
    updatedAt: Date
    _count: InspectionSessionCountAggregateOutputType | null
    _avg: InspectionSessionAvgAggregateOutputType | null
    _sum: InspectionSessionSumAggregateOutputType | null
    _min: InspectionSessionMinAggregateOutputType | null
    _max: InspectionSessionMaxAggregateOutputType | null
  }

  type GetInspectionSessionGroupByPayload<T extends InspectionSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectionSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectionSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectionSessionGroupByOutputType[P]>
            : GetScalarType<T[P], InspectionSessionGroupByOutputType[P]>
        }
      >
    >


  export type InspectionSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    vehicleId?: boolean
    bookingId?: boolean
    inspectorId?: boolean
    inspectedAt?: boolean
    inspectionType?: boolean
    odometerKm?: boolean
    notes?: boolean
    status?: boolean
    passThreshold?: boolean
    totalScore?: boolean
    defectSeverity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    booking?: boolean | InspectionSession$bookingArgs<ExtArgs>
    inspector?: boolean | InspectionSession$inspectorArgs<ExtArgs>
    certificate?: boolean | InspectionSession$certificateArgs<ExtArgs>
    results?: boolean | InspectionSession$resultsArgs<ExtArgs>
    mediaRefs?: boolean | InspectionSession$mediaRefsArgs<ExtArgs>
    originalReinspections?: boolean | InspectionSession$originalReinspectionsArgs<ExtArgs>
    newReinspection?: boolean | InspectionSession$newReinspectionArgs<ExtArgs>
    referrals?: boolean | InspectionSession$referralsArgs<ExtArgs>
    _count?: boolean | InspectionSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionSession"]>

  export type InspectionSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    vehicleId?: boolean
    bookingId?: boolean
    inspectorId?: boolean
    inspectedAt?: boolean
    inspectionType?: boolean
    odometerKm?: boolean
    notes?: boolean
    status?: boolean
    passThreshold?: boolean
    totalScore?: boolean
    defectSeverity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    booking?: boolean | InspectionSession$bookingArgs<ExtArgs>
    inspector?: boolean | InspectionSession$inspectorArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionSession"]>

  export type InspectionSessionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    vehicleId?: boolean
    bookingId?: boolean
    inspectorId?: boolean
    inspectedAt?: boolean
    inspectionType?: boolean
    odometerKm?: boolean
    notes?: boolean
    status?: boolean
    passThreshold?: boolean
    totalScore?: boolean
    defectSeverity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InspectionSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    booking?: boolean | InspectionSession$bookingArgs<ExtArgs>
    inspector?: boolean | InspectionSession$inspectorArgs<ExtArgs>
    certificate?: boolean | InspectionSession$certificateArgs<ExtArgs>
    results?: boolean | InspectionSession$resultsArgs<ExtArgs>
    mediaRefs?: boolean | InspectionSession$mediaRefsArgs<ExtArgs>
    originalReinspections?: boolean | InspectionSession$originalReinspectionsArgs<ExtArgs>
    newReinspection?: boolean | InspectionSession$newReinspectionArgs<ExtArgs>
    referrals?: boolean | InspectionSession$referralsArgs<ExtArgs>
    _count?: boolean | InspectionSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InspectionSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    booking?: boolean | InspectionSession$bookingArgs<ExtArgs>
    inspector?: boolean | InspectionSession$inspectorArgs<ExtArgs>
  }

  export type $InspectionSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InspectionSession"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
      inspector: Prisma.$InspectorPayload<ExtArgs> | null
      certificate: Prisma.$CertificatePayload<ExtArgs> | null
      results: Prisma.$InspectionResultPayload<ExtArgs>[]
      mediaRefs: Prisma.$MediaRefPayload<ExtArgs>[]
      originalReinspections: Prisma.$ReinspectionLinkPayload<ExtArgs>[]
      newReinspection: Prisma.$ReinspectionLinkPayload<ExtArgs> | null
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: number
      vehicleId: number
      bookingId: number | null
      inspectorId: number | null
      inspectedAt: Date | null
      inspectionType: $Enums.InspectionType
      odometerKm: number | null
      notes: string | null
      status: $Enums.InspectionStatus
      passThreshold: number
      totalScore: number
      defectSeverity: $Enums.DefectSeverity
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inspectionSession"]>
    composites: {}
  }

  type InspectionSessionGetPayload<S extends boolean | null | undefined | InspectionSessionDefaultArgs> = $Result.GetResult<Prisma.$InspectionSessionPayload, S>

  type InspectionSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InspectionSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InspectionSessionCountAggregateInputType | true
    }

  export interface InspectionSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InspectionSession'], meta: { name: 'InspectionSession' } }
    /**
     * Find zero or one InspectionSession that matches the filter.
     * @param {InspectionSessionFindUniqueArgs} args - Arguments to find a InspectionSession
     * @example
     * // Get one InspectionSession
     * const inspectionSession = await prisma.inspectionSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectionSessionFindUniqueArgs>(args: SelectSubset<T, InspectionSessionFindUniqueArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InspectionSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InspectionSessionFindUniqueOrThrowArgs} args - Arguments to find a InspectionSession
     * @example
     * // Get one InspectionSession
     * const inspectionSession = await prisma.inspectionSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectionSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectionSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InspectionSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionFindFirstArgs} args - Arguments to find a InspectionSession
     * @example
     * // Get one InspectionSession
     * const inspectionSession = await prisma.inspectionSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectionSessionFindFirstArgs>(args?: SelectSubset<T, InspectionSessionFindFirstArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InspectionSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionFindFirstOrThrowArgs} args - Arguments to find a InspectionSession
     * @example
     * // Get one InspectionSession
     * const inspectionSession = await prisma.inspectionSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectionSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectionSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InspectionSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InspectionSessions
     * const inspectionSessions = await prisma.inspectionSession.findMany()
     * 
     * // Get first 10 InspectionSessions
     * const inspectionSessions = await prisma.inspectionSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectionSessionWithIdOnly = await prisma.inspectionSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectionSessionFindManyArgs>(args?: SelectSubset<T, InspectionSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InspectionSession.
     * @param {InspectionSessionCreateArgs} args - Arguments to create a InspectionSession.
     * @example
     * // Create one InspectionSession
     * const InspectionSession = await prisma.inspectionSession.create({
     *   data: {
     *     // ... data to create a InspectionSession
     *   }
     * })
     * 
     */
    create<T extends InspectionSessionCreateArgs>(args: SelectSubset<T, InspectionSessionCreateArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InspectionSessions.
     * @param {InspectionSessionCreateManyArgs} args - Arguments to create many InspectionSessions.
     * @example
     * // Create many InspectionSessions
     * const inspectionSession = await prisma.inspectionSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectionSessionCreateManyArgs>(args?: SelectSubset<T, InspectionSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InspectionSessions and returns the data saved in the database.
     * @param {InspectionSessionCreateManyAndReturnArgs} args - Arguments to create many InspectionSessions.
     * @example
     * // Create many InspectionSessions
     * const inspectionSession = await prisma.inspectionSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InspectionSessions and only return the `id`
     * const inspectionSessionWithIdOnly = await prisma.inspectionSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectionSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectionSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InspectionSession.
     * @param {InspectionSessionDeleteArgs} args - Arguments to delete one InspectionSession.
     * @example
     * // Delete one InspectionSession
     * const InspectionSession = await prisma.inspectionSession.delete({
     *   where: {
     *     // ... filter to delete one InspectionSession
     *   }
     * })
     * 
     */
    delete<T extends InspectionSessionDeleteArgs>(args: SelectSubset<T, InspectionSessionDeleteArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InspectionSession.
     * @param {InspectionSessionUpdateArgs} args - Arguments to update one InspectionSession.
     * @example
     * // Update one InspectionSession
     * const inspectionSession = await prisma.inspectionSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectionSessionUpdateArgs>(args: SelectSubset<T, InspectionSessionUpdateArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InspectionSessions.
     * @param {InspectionSessionDeleteManyArgs} args - Arguments to filter InspectionSessions to delete.
     * @example
     * // Delete a few InspectionSessions
     * const { count } = await prisma.inspectionSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectionSessionDeleteManyArgs>(args?: SelectSubset<T, InspectionSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InspectionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InspectionSessions
     * const inspectionSession = await prisma.inspectionSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectionSessionUpdateManyArgs>(args: SelectSubset<T, InspectionSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InspectionSession.
     * @param {InspectionSessionUpsertArgs} args - Arguments to update or create a InspectionSession.
     * @example
     * // Update or create a InspectionSession
     * const inspectionSession = await prisma.inspectionSession.upsert({
     *   create: {
     *     // ... data to create a InspectionSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InspectionSession we want to update
     *   }
     * })
     */
    upsert<T extends InspectionSessionUpsertArgs>(args: SelectSubset<T, InspectionSessionUpsertArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InspectionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionCountArgs} args - Arguments to filter InspectionSessions to count.
     * @example
     * // Count the number of InspectionSessions
     * const count = await prisma.inspectionSession.count({
     *   where: {
     *     // ... the filter for the InspectionSessions we want to count
     *   }
     * })
    **/
    count<T extends InspectionSessionCountArgs>(
      args?: Subset<T, InspectionSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectionSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InspectionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectionSessionAggregateArgs>(args: Subset<T, InspectionSessionAggregateArgs>): Prisma.PrismaPromise<GetInspectionSessionAggregateType<T>>

    /**
     * Group by InspectionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectionSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectionSessionGroupByArgs['orderBy'] }
        : { orderBy?: InspectionSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectionSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectionSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InspectionSession model
   */
  readonly fields: InspectionSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InspectionSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectionSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    booking<T extends InspectionSession$bookingArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inspector<T extends InspectionSession$inspectorArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$inspectorArgs<ExtArgs>>): Prisma__InspectorClient<$Result.GetResult<Prisma.$InspectorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    certificate<T extends InspectionSession$certificateArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$certificateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    results<T extends InspectionSession$resultsArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findMany"> | Null>
    mediaRefs<T extends InspectionSession$mediaRefsArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$mediaRefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "findMany"> | Null>
    originalReinspections<T extends InspectionSession$originalReinspectionsArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$originalReinspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findMany"> | Null>
    newReinspection<T extends InspectionSession$newReinspectionArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$newReinspectionArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referrals<T extends InspectionSession$referralsArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSession$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InspectionSession model
   */ 
  interface InspectionSessionFieldRefs {
    readonly id: FieldRef<"InspectionSession", 'Int'>
    readonly tenantId: FieldRef<"InspectionSession", 'Int'>
    readonly vehicleId: FieldRef<"InspectionSession", 'Int'>
    readonly bookingId: FieldRef<"InspectionSession", 'Int'>
    readonly inspectorId: FieldRef<"InspectionSession", 'Int'>
    readonly inspectedAt: FieldRef<"InspectionSession", 'DateTime'>
    readonly inspectionType: FieldRef<"InspectionSession", 'InspectionType'>
    readonly odometerKm: FieldRef<"InspectionSession", 'Int'>
    readonly notes: FieldRef<"InspectionSession", 'String'>
    readonly status: FieldRef<"InspectionSession", 'InspectionStatus'>
    readonly passThreshold: FieldRef<"InspectionSession", 'Int'>
    readonly totalScore: FieldRef<"InspectionSession", 'Int'>
    readonly defectSeverity: FieldRef<"InspectionSession", 'DefectSeverity'>
    readonly createdAt: FieldRef<"InspectionSession", 'DateTime'>
    readonly updatedAt: FieldRef<"InspectionSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InspectionSession findUnique
   */
  export type InspectionSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * Filter, which InspectionSession to fetch.
     */
    where: InspectionSessionWhereUniqueInput
  }

  /**
   * InspectionSession findUniqueOrThrow
   */
  export type InspectionSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * Filter, which InspectionSession to fetch.
     */
    where: InspectionSessionWhereUniqueInput
  }

  /**
   * InspectionSession findFirst
   */
  export type InspectionSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * Filter, which InspectionSession to fetch.
     */
    where?: InspectionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionSessions to fetch.
     */
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionSessions.
     */
    cursor?: InspectionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionSessions.
     */
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * InspectionSession findFirstOrThrow
   */
  export type InspectionSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * Filter, which InspectionSession to fetch.
     */
    where?: InspectionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionSessions to fetch.
     */
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionSessions.
     */
    cursor?: InspectionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionSessions.
     */
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * InspectionSession findMany
   */
  export type InspectionSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * Filter, which InspectionSessions to fetch.
     */
    where?: InspectionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionSessions to fetch.
     */
    orderBy?: InspectionSessionOrderByWithRelationInput | InspectionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InspectionSessions.
     */
    cursor?: InspectionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionSessions.
     */
    skip?: number
    distinct?: InspectionSessionScalarFieldEnum | InspectionSessionScalarFieldEnum[]
  }

  /**
   * InspectionSession create
   */
  export type InspectionSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a InspectionSession.
     */
    data: XOR<InspectionSessionCreateInput, InspectionSessionUncheckedCreateInput>
  }

  /**
   * InspectionSession createMany
   */
  export type InspectionSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InspectionSessions.
     */
    data: InspectionSessionCreateManyInput | InspectionSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InspectionSession createManyAndReturn
   */
  export type InspectionSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InspectionSessions.
     */
    data: InspectionSessionCreateManyInput | InspectionSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InspectionSession update
   */
  export type InspectionSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a InspectionSession.
     */
    data: XOR<InspectionSessionUpdateInput, InspectionSessionUncheckedUpdateInput>
    /**
     * Choose, which InspectionSession to update.
     */
    where: InspectionSessionWhereUniqueInput
  }

  /**
   * InspectionSession updateMany
   */
  export type InspectionSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InspectionSessions.
     */
    data: XOR<InspectionSessionUpdateManyMutationInput, InspectionSessionUncheckedUpdateManyInput>
    /**
     * Filter which InspectionSessions to update
     */
    where?: InspectionSessionWhereInput
  }

  /**
   * InspectionSession upsert
   */
  export type InspectionSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the InspectionSession to update in case it exists.
     */
    where: InspectionSessionWhereUniqueInput
    /**
     * In case the InspectionSession found by the `where` argument doesn't exist, create a new InspectionSession with this data.
     */
    create: XOR<InspectionSessionCreateInput, InspectionSessionUncheckedCreateInput>
    /**
     * In case the InspectionSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectionSessionUpdateInput, InspectionSessionUncheckedUpdateInput>
  }

  /**
   * InspectionSession delete
   */
  export type InspectionSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    /**
     * Filter which InspectionSession to delete.
     */
    where: InspectionSessionWhereUniqueInput
  }

  /**
   * InspectionSession deleteMany
   */
  export type InspectionSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionSessions to delete
     */
    where?: InspectionSessionWhereInput
  }

  /**
   * InspectionSession.booking
   */
  export type InspectionSession$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * InspectionSession.inspector
   */
  export type InspectionSession$inspectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inspector
     */
    select?: InspectorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectorInclude<ExtArgs> | null
    where?: InspectorWhereInput
  }

  /**
   * InspectionSession.certificate
   */
  export type InspectionSession$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
  }

  /**
   * InspectionSession.results
   */
  export type InspectionSession$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    where?: InspectionResultWhereInput
    orderBy?: InspectionResultOrderByWithRelationInput | InspectionResultOrderByWithRelationInput[]
    cursor?: InspectionResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InspectionResultScalarFieldEnum | InspectionResultScalarFieldEnum[]
  }

  /**
   * InspectionSession.mediaRefs
   */
  export type InspectionSession$mediaRefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    where?: MediaRefWhereInput
    orderBy?: MediaRefOrderByWithRelationInput | MediaRefOrderByWithRelationInput[]
    cursor?: MediaRefWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaRefScalarFieldEnum | MediaRefScalarFieldEnum[]
  }

  /**
   * InspectionSession.originalReinspections
   */
  export type InspectionSession$originalReinspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    where?: ReinspectionLinkWhereInput
    orderBy?: ReinspectionLinkOrderByWithRelationInput | ReinspectionLinkOrderByWithRelationInput[]
    cursor?: ReinspectionLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReinspectionLinkScalarFieldEnum | ReinspectionLinkScalarFieldEnum[]
  }

  /**
   * InspectionSession.newReinspection
   */
  export type InspectionSession$newReinspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    where?: ReinspectionLinkWhereInput
  }

  /**
   * InspectionSession.referrals
   */
  export type InspectionSession$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * InspectionSession without action
   */
  export type InspectionSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
  }


  /**
   * Model InspectionResult
   */

  export type AggregateInspectionResult = {
    _count: InspectionResultCountAggregateOutputType | null
    _avg: InspectionResultAvgAggregateOutputType | null
    _sum: InspectionResultSumAggregateOutputType | null
    _min: InspectionResultMinAggregateOutputType | null
    _max: InspectionResultMaxAggregateOutputType | null
  }

  export type InspectionResultAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
    itemId: number | null
    measuredValueNum: Decimal | null
  }

  export type InspectionResultSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
    itemId: number | null
    measuredValueNum: Decimal | null
  }

  export type InspectionResultMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    itemId: number | null
    measuredValueNum: Decimal | null
    measuredValueText: string | null
    pass: boolean | null
    severity: $Enums.ResultSeverity | null
    remarks: string | null
    createdAt: Date | null
  }

  export type InspectionResultMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    itemId: number | null
    measuredValueNum: Decimal | null
    measuredValueText: string | null
    pass: boolean | null
    severity: $Enums.ResultSeverity | null
    remarks: string | null
    createdAt: Date | null
  }

  export type InspectionResultCountAggregateOutputType = {
    id: number
    sessionId: number
    itemId: number
    measuredValueNum: number
    measuredValueText: number
    pass: number
    severity: number
    remarks: number
    createdAt: number
    _all: number
  }


  export type InspectionResultAvgAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    measuredValueNum?: true
  }

  export type InspectionResultSumAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    measuredValueNum?: true
  }

  export type InspectionResultMinAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    measuredValueNum?: true
    measuredValueText?: true
    pass?: true
    severity?: true
    remarks?: true
    createdAt?: true
  }

  export type InspectionResultMaxAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    measuredValueNum?: true
    measuredValueText?: true
    pass?: true
    severity?: true
    remarks?: true
    createdAt?: true
  }

  export type InspectionResultCountAggregateInputType = {
    id?: true
    sessionId?: true
    itemId?: true
    measuredValueNum?: true
    measuredValueText?: true
    pass?: true
    severity?: true
    remarks?: true
    createdAt?: true
    _all?: true
  }

  export type InspectionResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionResult to aggregate.
     */
    where?: InspectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResults to fetch.
     */
    orderBy?: InspectionResultOrderByWithRelationInput | InspectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InspectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InspectionResults
    **/
    _count?: true | InspectionResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InspectionResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InspectionResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InspectionResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InspectionResultMaxAggregateInputType
  }

  export type GetInspectionResultAggregateType<T extends InspectionResultAggregateArgs> = {
        [P in keyof T & keyof AggregateInspectionResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInspectionResult[P]>
      : GetScalarType<T[P], AggregateInspectionResult[P]>
  }




  export type InspectionResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InspectionResultWhereInput
    orderBy?: InspectionResultOrderByWithAggregationInput | InspectionResultOrderByWithAggregationInput[]
    by: InspectionResultScalarFieldEnum[] | InspectionResultScalarFieldEnum
    having?: InspectionResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InspectionResultCountAggregateInputType | true
    _avg?: InspectionResultAvgAggregateInputType
    _sum?: InspectionResultSumAggregateInputType
    _min?: InspectionResultMinAggregateInputType
    _max?: InspectionResultMaxAggregateInputType
  }

  export type InspectionResultGroupByOutputType = {
    id: number
    sessionId: number
    itemId: number
    measuredValueNum: Decimal | null
    measuredValueText: string | null
    pass: boolean
    severity: $Enums.ResultSeverity
    remarks: string | null
    createdAt: Date
    _count: InspectionResultCountAggregateOutputType | null
    _avg: InspectionResultAvgAggregateOutputType | null
    _sum: InspectionResultSumAggregateOutputType | null
    _min: InspectionResultMinAggregateOutputType | null
    _max: InspectionResultMaxAggregateOutputType | null
  }

  type GetInspectionResultGroupByPayload<T extends InspectionResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InspectionResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InspectionResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InspectionResultGroupByOutputType[P]>
            : GetScalarType<T[P], InspectionResultGroupByOutputType[P]>
        }
      >
    >


  export type InspectionResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    measuredValueNum?: boolean
    measuredValueText?: boolean
    pass?: boolean
    severity?: boolean
    remarks?: boolean
    createdAt?: boolean
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    item?: boolean | InspectionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionResult"]>

  export type InspectionResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    measuredValueNum?: boolean
    measuredValueText?: boolean
    pass?: boolean
    severity?: boolean
    remarks?: boolean
    createdAt?: boolean
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    item?: boolean | InspectionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inspectionResult"]>

  export type InspectionResultSelectScalar = {
    id?: boolean
    sessionId?: boolean
    itemId?: boolean
    measuredValueNum?: boolean
    measuredValueText?: boolean
    pass?: boolean
    severity?: boolean
    remarks?: boolean
    createdAt?: boolean
  }

  export type InspectionResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    item?: boolean | InspectionItemDefaultArgs<ExtArgs>
  }
  export type InspectionResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    item?: boolean | InspectionItemDefaultArgs<ExtArgs>
  }

  export type $InspectionResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InspectionResult"
    objects: {
      session: Prisma.$InspectionSessionPayload<ExtArgs>
      item: Prisma.$InspectionItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      itemId: number
      measuredValueNum: Prisma.Decimal | null
      measuredValueText: string | null
      pass: boolean
      severity: $Enums.ResultSeverity
      remarks: string | null
      createdAt: Date
    }, ExtArgs["result"]["inspectionResult"]>
    composites: {}
  }

  type InspectionResultGetPayload<S extends boolean | null | undefined | InspectionResultDefaultArgs> = $Result.GetResult<Prisma.$InspectionResultPayload, S>

  type InspectionResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InspectionResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InspectionResultCountAggregateInputType | true
    }

  export interface InspectionResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InspectionResult'], meta: { name: 'InspectionResult' } }
    /**
     * Find zero or one InspectionResult that matches the filter.
     * @param {InspectionResultFindUniqueArgs} args - Arguments to find a InspectionResult
     * @example
     * // Get one InspectionResult
     * const inspectionResult = await prisma.inspectionResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InspectionResultFindUniqueArgs>(args: SelectSubset<T, InspectionResultFindUniqueArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InspectionResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InspectionResultFindUniqueOrThrowArgs} args - Arguments to find a InspectionResult
     * @example
     * // Get one InspectionResult
     * const inspectionResult = await prisma.inspectionResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InspectionResultFindUniqueOrThrowArgs>(args: SelectSubset<T, InspectionResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InspectionResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultFindFirstArgs} args - Arguments to find a InspectionResult
     * @example
     * // Get one InspectionResult
     * const inspectionResult = await prisma.inspectionResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InspectionResultFindFirstArgs>(args?: SelectSubset<T, InspectionResultFindFirstArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InspectionResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultFindFirstOrThrowArgs} args - Arguments to find a InspectionResult
     * @example
     * // Get one InspectionResult
     * const inspectionResult = await prisma.inspectionResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InspectionResultFindFirstOrThrowArgs>(args?: SelectSubset<T, InspectionResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InspectionResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InspectionResults
     * const inspectionResults = await prisma.inspectionResult.findMany()
     * 
     * // Get first 10 InspectionResults
     * const inspectionResults = await prisma.inspectionResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inspectionResultWithIdOnly = await prisma.inspectionResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InspectionResultFindManyArgs>(args?: SelectSubset<T, InspectionResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InspectionResult.
     * @param {InspectionResultCreateArgs} args - Arguments to create a InspectionResult.
     * @example
     * // Create one InspectionResult
     * const InspectionResult = await prisma.inspectionResult.create({
     *   data: {
     *     // ... data to create a InspectionResult
     *   }
     * })
     * 
     */
    create<T extends InspectionResultCreateArgs>(args: SelectSubset<T, InspectionResultCreateArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InspectionResults.
     * @param {InspectionResultCreateManyArgs} args - Arguments to create many InspectionResults.
     * @example
     * // Create many InspectionResults
     * const inspectionResult = await prisma.inspectionResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InspectionResultCreateManyArgs>(args?: SelectSubset<T, InspectionResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InspectionResults and returns the data saved in the database.
     * @param {InspectionResultCreateManyAndReturnArgs} args - Arguments to create many InspectionResults.
     * @example
     * // Create many InspectionResults
     * const inspectionResult = await prisma.inspectionResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InspectionResults and only return the `id`
     * const inspectionResultWithIdOnly = await prisma.inspectionResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InspectionResultCreateManyAndReturnArgs>(args?: SelectSubset<T, InspectionResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InspectionResult.
     * @param {InspectionResultDeleteArgs} args - Arguments to delete one InspectionResult.
     * @example
     * // Delete one InspectionResult
     * const InspectionResult = await prisma.inspectionResult.delete({
     *   where: {
     *     // ... filter to delete one InspectionResult
     *   }
     * })
     * 
     */
    delete<T extends InspectionResultDeleteArgs>(args: SelectSubset<T, InspectionResultDeleteArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InspectionResult.
     * @param {InspectionResultUpdateArgs} args - Arguments to update one InspectionResult.
     * @example
     * // Update one InspectionResult
     * const inspectionResult = await prisma.inspectionResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InspectionResultUpdateArgs>(args: SelectSubset<T, InspectionResultUpdateArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InspectionResults.
     * @param {InspectionResultDeleteManyArgs} args - Arguments to filter InspectionResults to delete.
     * @example
     * // Delete a few InspectionResults
     * const { count } = await prisma.inspectionResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InspectionResultDeleteManyArgs>(args?: SelectSubset<T, InspectionResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InspectionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InspectionResults
     * const inspectionResult = await prisma.inspectionResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InspectionResultUpdateManyArgs>(args: SelectSubset<T, InspectionResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InspectionResult.
     * @param {InspectionResultUpsertArgs} args - Arguments to update or create a InspectionResult.
     * @example
     * // Update or create a InspectionResult
     * const inspectionResult = await prisma.inspectionResult.upsert({
     *   create: {
     *     // ... data to create a InspectionResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InspectionResult we want to update
     *   }
     * })
     */
    upsert<T extends InspectionResultUpsertArgs>(args: SelectSubset<T, InspectionResultUpsertArgs<ExtArgs>>): Prisma__InspectionResultClient<$Result.GetResult<Prisma.$InspectionResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InspectionResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultCountArgs} args - Arguments to filter InspectionResults to count.
     * @example
     * // Count the number of InspectionResults
     * const count = await prisma.inspectionResult.count({
     *   where: {
     *     // ... the filter for the InspectionResults we want to count
     *   }
     * })
    **/
    count<T extends InspectionResultCountArgs>(
      args?: Subset<T, InspectionResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InspectionResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InspectionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InspectionResultAggregateArgs>(args: Subset<T, InspectionResultAggregateArgs>): Prisma.PrismaPromise<GetInspectionResultAggregateType<T>>

    /**
     * Group by InspectionResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InspectionResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InspectionResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InspectionResultGroupByArgs['orderBy'] }
        : { orderBy?: InspectionResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InspectionResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInspectionResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InspectionResult model
   */
  readonly fields: InspectionResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InspectionResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InspectionResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends InspectionSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSessionDefaultArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends InspectionItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionItemDefaultArgs<ExtArgs>>): Prisma__InspectionItemClient<$Result.GetResult<Prisma.$InspectionItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InspectionResult model
   */ 
  interface InspectionResultFieldRefs {
    readonly id: FieldRef<"InspectionResult", 'Int'>
    readonly sessionId: FieldRef<"InspectionResult", 'Int'>
    readonly itemId: FieldRef<"InspectionResult", 'Int'>
    readonly measuredValueNum: FieldRef<"InspectionResult", 'Decimal'>
    readonly measuredValueText: FieldRef<"InspectionResult", 'String'>
    readonly pass: FieldRef<"InspectionResult", 'Boolean'>
    readonly severity: FieldRef<"InspectionResult", 'ResultSeverity'>
    readonly remarks: FieldRef<"InspectionResult", 'String'>
    readonly createdAt: FieldRef<"InspectionResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InspectionResult findUnique
   */
  export type InspectionResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResult to fetch.
     */
    where: InspectionResultWhereUniqueInput
  }

  /**
   * InspectionResult findUniqueOrThrow
   */
  export type InspectionResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResult to fetch.
     */
    where: InspectionResultWhereUniqueInput
  }

  /**
   * InspectionResult findFirst
   */
  export type InspectionResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResult to fetch.
     */
    where?: InspectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResults to fetch.
     */
    orderBy?: InspectionResultOrderByWithRelationInput | InspectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionResults.
     */
    cursor?: InspectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionResults.
     */
    distinct?: InspectionResultScalarFieldEnum | InspectionResultScalarFieldEnum[]
  }

  /**
   * InspectionResult findFirstOrThrow
   */
  export type InspectionResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResult to fetch.
     */
    where?: InspectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResults to fetch.
     */
    orderBy?: InspectionResultOrderByWithRelationInput | InspectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InspectionResults.
     */
    cursor?: InspectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InspectionResults.
     */
    distinct?: InspectionResultScalarFieldEnum | InspectionResultScalarFieldEnum[]
  }

  /**
   * InspectionResult findMany
   */
  export type InspectionResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * Filter, which InspectionResults to fetch.
     */
    where?: InspectionResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InspectionResults to fetch.
     */
    orderBy?: InspectionResultOrderByWithRelationInput | InspectionResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InspectionResults.
     */
    cursor?: InspectionResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InspectionResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InspectionResults.
     */
    skip?: number
    distinct?: InspectionResultScalarFieldEnum | InspectionResultScalarFieldEnum[]
  }

  /**
   * InspectionResult create
   */
  export type InspectionResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * The data needed to create a InspectionResult.
     */
    data: XOR<InspectionResultCreateInput, InspectionResultUncheckedCreateInput>
  }

  /**
   * InspectionResult createMany
   */
  export type InspectionResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InspectionResults.
     */
    data: InspectionResultCreateManyInput | InspectionResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InspectionResult createManyAndReturn
   */
  export type InspectionResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InspectionResults.
     */
    data: InspectionResultCreateManyInput | InspectionResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InspectionResult update
   */
  export type InspectionResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * The data needed to update a InspectionResult.
     */
    data: XOR<InspectionResultUpdateInput, InspectionResultUncheckedUpdateInput>
    /**
     * Choose, which InspectionResult to update.
     */
    where: InspectionResultWhereUniqueInput
  }

  /**
   * InspectionResult updateMany
   */
  export type InspectionResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InspectionResults.
     */
    data: XOR<InspectionResultUpdateManyMutationInput, InspectionResultUncheckedUpdateManyInput>
    /**
     * Filter which InspectionResults to update
     */
    where?: InspectionResultWhereInput
  }

  /**
   * InspectionResult upsert
   */
  export type InspectionResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * The filter to search for the InspectionResult to update in case it exists.
     */
    where: InspectionResultWhereUniqueInput
    /**
     * In case the InspectionResult found by the `where` argument doesn't exist, create a new InspectionResult with this data.
     */
    create: XOR<InspectionResultCreateInput, InspectionResultUncheckedCreateInput>
    /**
     * In case the InspectionResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InspectionResultUpdateInput, InspectionResultUncheckedUpdateInput>
  }

  /**
   * InspectionResult delete
   */
  export type InspectionResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
    /**
     * Filter which InspectionResult to delete.
     */
    where: InspectionResultWhereUniqueInput
  }

  /**
   * InspectionResult deleteMany
   */
  export type InspectionResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InspectionResults to delete
     */
    where?: InspectionResultWhereInput
  }

  /**
   * InspectionResult without action
   */
  export type InspectionResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionResult
     */
    select?: InspectionResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionResultInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
  }

  export type CertificateSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    certificateNo: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    stickerNo: string | null
    reportPdfUrl: string | null
    verificationHash: string | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    certificateNo: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    stickerNo: string | null
    reportPdfUrl: string | null
    verificationHash: string | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    sessionId: number
    certificateNo: number
    issuedAt: number
    expiresAt: number
    stickerNo: number
    reportPdfUrl: number
    verificationHash: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    id?: true
    sessionId?: true
  }

  export type CertificateSumAggregateInputType = {
    id?: true
    sessionId?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    sessionId?: true
    certificateNo?: true
    issuedAt?: true
    expiresAt?: true
    stickerNo?: true
    reportPdfUrl?: true
    verificationHash?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    sessionId?: true
    certificateNo?: true
    issuedAt?: true
    expiresAt?: true
    stickerNo?: true
    reportPdfUrl?: true
    verificationHash?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    sessionId?: true
    certificateNo?: true
    issuedAt?: true
    expiresAt?: true
    stickerNo?: true
    reportPdfUrl?: true
    verificationHash?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: number
    sessionId: number
    certificateNo: string
    issuedAt: Date
    expiresAt: Date
    stickerNo: string | null
    reportPdfUrl: string | null
    verificationHash: string
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    certificateNo?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    stickerNo?: boolean
    reportPdfUrl?: boolean
    verificationHash?: boolean
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    certificateNo?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    stickerNo?: boolean
    reportPdfUrl?: boolean
    verificationHash?: boolean
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    sessionId?: boolean
    certificateNo?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    stickerNo?: boolean
    reportPdfUrl?: boolean
    verificationHash?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      session: Prisma.$InspectionSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      certificateNo: string
      issuedAt: Date
      expiresAt: Date
      stickerNo: string | null
      reportPdfUrl: string | null
      verificationHash: string
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends InspectionSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSessionDefaultArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'Int'>
    readonly sessionId: FieldRef<"Certificate", 'Int'>
    readonly certificateNo: FieldRef<"Certificate", 'String'>
    readonly issuedAt: FieldRef<"Certificate", 'DateTime'>
    readonly expiresAt: FieldRef<"Certificate", 'DateTime'>
    readonly stickerNo: FieldRef<"Certificate", 'String'>
    readonly reportPdfUrl: FieldRef<"Certificate", 'String'>
    readonly verificationHash: FieldRef<"Certificate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model ReinspectionLink
   */

  export type AggregateReinspectionLink = {
    _count: ReinspectionLinkCountAggregateOutputType | null
    _avg: ReinspectionLinkAvgAggregateOutputType | null
    _sum: ReinspectionLinkSumAggregateOutputType | null
    _min: ReinspectionLinkMinAggregateOutputType | null
    _max: ReinspectionLinkMaxAggregateOutputType | null
  }

  export type ReinspectionLinkAvgAggregateOutputType = {
    id: number | null
    originalSessionId: number | null
    newSessionId: number | null
  }

  export type ReinspectionLinkSumAggregateOutputType = {
    id: number | null
    originalSessionId: number | null
    newSessionId: number | null
  }

  export type ReinspectionLinkMinAggregateOutputType = {
    id: number | null
    originalSessionId: number | null
    newSessionId: number | null
    freeWithin14Days: boolean | null
    reason: string | null
  }

  export type ReinspectionLinkMaxAggregateOutputType = {
    id: number | null
    originalSessionId: number | null
    newSessionId: number | null
    freeWithin14Days: boolean | null
    reason: string | null
  }

  export type ReinspectionLinkCountAggregateOutputType = {
    id: number
    originalSessionId: number
    newSessionId: number
    freeWithin14Days: number
    reason: number
    _all: number
  }


  export type ReinspectionLinkAvgAggregateInputType = {
    id?: true
    originalSessionId?: true
    newSessionId?: true
  }

  export type ReinspectionLinkSumAggregateInputType = {
    id?: true
    originalSessionId?: true
    newSessionId?: true
  }

  export type ReinspectionLinkMinAggregateInputType = {
    id?: true
    originalSessionId?: true
    newSessionId?: true
    freeWithin14Days?: true
    reason?: true
  }

  export type ReinspectionLinkMaxAggregateInputType = {
    id?: true
    originalSessionId?: true
    newSessionId?: true
    freeWithin14Days?: true
    reason?: true
  }

  export type ReinspectionLinkCountAggregateInputType = {
    id?: true
    originalSessionId?: true
    newSessionId?: true
    freeWithin14Days?: true
    reason?: true
    _all?: true
  }

  export type ReinspectionLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReinspectionLink to aggregate.
     */
    where?: ReinspectionLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReinspectionLinks to fetch.
     */
    orderBy?: ReinspectionLinkOrderByWithRelationInput | ReinspectionLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReinspectionLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReinspectionLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReinspectionLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReinspectionLinks
    **/
    _count?: true | ReinspectionLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReinspectionLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReinspectionLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReinspectionLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReinspectionLinkMaxAggregateInputType
  }

  export type GetReinspectionLinkAggregateType<T extends ReinspectionLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateReinspectionLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReinspectionLink[P]>
      : GetScalarType<T[P], AggregateReinspectionLink[P]>
  }




  export type ReinspectionLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReinspectionLinkWhereInput
    orderBy?: ReinspectionLinkOrderByWithAggregationInput | ReinspectionLinkOrderByWithAggregationInput[]
    by: ReinspectionLinkScalarFieldEnum[] | ReinspectionLinkScalarFieldEnum
    having?: ReinspectionLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReinspectionLinkCountAggregateInputType | true
    _avg?: ReinspectionLinkAvgAggregateInputType
    _sum?: ReinspectionLinkSumAggregateInputType
    _min?: ReinspectionLinkMinAggregateInputType
    _max?: ReinspectionLinkMaxAggregateInputType
  }

  export type ReinspectionLinkGroupByOutputType = {
    id: number
    originalSessionId: number
    newSessionId: number
    freeWithin14Days: boolean
    reason: string | null
    _count: ReinspectionLinkCountAggregateOutputType | null
    _avg: ReinspectionLinkAvgAggregateOutputType | null
    _sum: ReinspectionLinkSumAggregateOutputType | null
    _min: ReinspectionLinkMinAggregateOutputType | null
    _max: ReinspectionLinkMaxAggregateOutputType | null
  }

  type GetReinspectionLinkGroupByPayload<T extends ReinspectionLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReinspectionLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReinspectionLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReinspectionLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ReinspectionLinkGroupByOutputType[P]>
        }
      >
    >


  export type ReinspectionLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalSessionId?: boolean
    newSessionId?: boolean
    freeWithin14Days?: boolean
    reason?: boolean
    originalSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    newSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reinspectionLink"]>

  export type ReinspectionLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalSessionId?: boolean
    newSessionId?: boolean
    freeWithin14Days?: boolean
    reason?: boolean
    originalSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    newSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reinspectionLink"]>

  export type ReinspectionLinkSelectScalar = {
    id?: boolean
    originalSessionId?: boolean
    newSessionId?: boolean
    freeWithin14Days?: boolean
    reason?: boolean
  }

  export type ReinspectionLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    newSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }
  export type ReinspectionLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
    newSession?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }

  export type $ReinspectionLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReinspectionLink"
    objects: {
      originalSession: Prisma.$InspectionSessionPayload<ExtArgs>
      newSession: Prisma.$InspectionSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      originalSessionId: number
      newSessionId: number
      freeWithin14Days: boolean
      reason: string | null
    }, ExtArgs["result"]["reinspectionLink"]>
    composites: {}
  }

  type ReinspectionLinkGetPayload<S extends boolean | null | undefined | ReinspectionLinkDefaultArgs> = $Result.GetResult<Prisma.$ReinspectionLinkPayload, S>

  type ReinspectionLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReinspectionLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReinspectionLinkCountAggregateInputType | true
    }

  export interface ReinspectionLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReinspectionLink'], meta: { name: 'ReinspectionLink' } }
    /**
     * Find zero or one ReinspectionLink that matches the filter.
     * @param {ReinspectionLinkFindUniqueArgs} args - Arguments to find a ReinspectionLink
     * @example
     * // Get one ReinspectionLink
     * const reinspectionLink = await prisma.reinspectionLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReinspectionLinkFindUniqueArgs>(args: SelectSubset<T, ReinspectionLinkFindUniqueArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReinspectionLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReinspectionLinkFindUniqueOrThrowArgs} args - Arguments to find a ReinspectionLink
     * @example
     * // Get one ReinspectionLink
     * const reinspectionLink = await prisma.reinspectionLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReinspectionLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ReinspectionLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReinspectionLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkFindFirstArgs} args - Arguments to find a ReinspectionLink
     * @example
     * // Get one ReinspectionLink
     * const reinspectionLink = await prisma.reinspectionLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReinspectionLinkFindFirstArgs>(args?: SelectSubset<T, ReinspectionLinkFindFirstArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReinspectionLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkFindFirstOrThrowArgs} args - Arguments to find a ReinspectionLink
     * @example
     * // Get one ReinspectionLink
     * const reinspectionLink = await prisma.reinspectionLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReinspectionLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ReinspectionLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReinspectionLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReinspectionLinks
     * const reinspectionLinks = await prisma.reinspectionLink.findMany()
     * 
     * // Get first 10 ReinspectionLinks
     * const reinspectionLinks = await prisma.reinspectionLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reinspectionLinkWithIdOnly = await prisma.reinspectionLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReinspectionLinkFindManyArgs>(args?: SelectSubset<T, ReinspectionLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReinspectionLink.
     * @param {ReinspectionLinkCreateArgs} args - Arguments to create a ReinspectionLink.
     * @example
     * // Create one ReinspectionLink
     * const ReinspectionLink = await prisma.reinspectionLink.create({
     *   data: {
     *     // ... data to create a ReinspectionLink
     *   }
     * })
     * 
     */
    create<T extends ReinspectionLinkCreateArgs>(args: SelectSubset<T, ReinspectionLinkCreateArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReinspectionLinks.
     * @param {ReinspectionLinkCreateManyArgs} args - Arguments to create many ReinspectionLinks.
     * @example
     * // Create many ReinspectionLinks
     * const reinspectionLink = await prisma.reinspectionLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReinspectionLinkCreateManyArgs>(args?: SelectSubset<T, ReinspectionLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReinspectionLinks and returns the data saved in the database.
     * @param {ReinspectionLinkCreateManyAndReturnArgs} args - Arguments to create many ReinspectionLinks.
     * @example
     * // Create many ReinspectionLinks
     * const reinspectionLink = await prisma.reinspectionLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReinspectionLinks and only return the `id`
     * const reinspectionLinkWithIdOnly = await prisma.reinspectionLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReinspectionLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ReinspectionLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReinspectionLink.
     * @param {ReinspectionLinkDeleteArgs} args - Arguments to delete one ReinspectionLink.
     * @example
     * // Delete one ReinspectionLink
     * const ReinspectionLink = await prisma.reinspectionLink.delete({
     *   where: {
     *     // ... filter to delete one ReinspectionLink
     *   }
     * })
     * 
     */
    delete<T extends ReinspectionLinkDeleteArgs>(args: SelectSubset<T, ReinspectionLinkDeleteArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReinspectionLink.
     * @param {ReinspectionLinkUpdateArgs} args - Arguments to update one ReinspectionLink.
     * @example
     * // Update one ReinspectionLink
     * const reinspectionLink = await prisma.reinspectionLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReinspectionLinkUpdateArgs>(args: SelectSubset<T, ReinspectionLinkUpdateArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReinspectionLinks.
     * @param {ReinspectionLinkDeleteManyArgs} args - Arguments to filter ReinspectionLinks to delete.
     * @example
     * // Delete a few ReinspectionLinks
     * const { count } = await prisma.reinspectionLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReinspectionLinkDeleteManyArgs>(args?: SelectSubset<T, ReinspectionLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReinspectionLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReinspectionLinks
     * const reinspectionLink = await prisma.reinspectionLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReinspectionLinkUpdateManyArgs>(args: SelectSubset<T, ReinspectionLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReinspectionLink.
     * @param {ReinspectionLinkUpsertArgs} args - Arguments to update or create a ReinspectionLink.
     * @example
     * // Update or create a ReinspectionLink
     * const reinspectionLink = await prisma.reinspectionLink.upsert({
     *   create: {
     *     // ... data to create a ReinspectionLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReinspectionLink we want to update
     *   }
     * })
     */
    upsert<T extends ReinspectionLinkUpsertArgs>(args: SelectSubset<T, ReinspectionLinkUpsertArgs<ExtArgs>>): Prisma__ReinspectionLinkClient<$Result.GetResult<Prisma.$ReinspectionLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReinspectionLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkCountArgs} args - Arguments to filter ReinspectionLinks to count.
     * @example
     * // Count the number of ReinspectionLinks
     * const count = await prisma.reinspectionLink.count({
     *   where: {
     *     // ... the filter for the ReinspectionLinks we want to count
     *   }
     * })
    **/
    count<T extends ReinspectionLinkCountArgs>(
      args?: Subset<T, ReinspectionLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReinspectionLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReinspectionLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReinspectionLinkAggregateArgs>(args: Subset<T, ReinspectionLinkAggregateArgs>): Prisma.PrismaPromise<GetReinspectionLinkAggregateType<T>>

    /**
     * Group by ReinspectionLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinspectionLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReinspectionLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReinspectionLinkGroupByArgs['orderBy'] }
        : { orderBy?: ReinspectionLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReinspectionLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReinspectionLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReinspectionLink model
   */
  readonly fields: ReinspectionLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReinspectionLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReinspectionLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalSession<T extends InspectionSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSessionDefaultArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    newSession<T extends InspectionSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSessionDefaultArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReinspectionLink model
   */ 
  interface ReinspectionLinkFieldRefs {
    readonly id: FieldRef<"ReinspectionLink", 'Int'>
    readonly originalSessionId: FieldRef<"ReinspectionLink", 'Int'>
    readonly newSessionId: FieldRef<"ReinspectionLink", 'Int'>
    readonly freeWithin14Days: FieldRef<"ReinspectionLink", 'Boolean'>
    readonly reason: FieldRef<"ReinspectionLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReinspectionLink findUnique
   */
  export type ReinspectionLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * Filter, which ReinspectionLink to fetch.
     */
    where: ReinspectionLinkWhereUniqueInput
  }

  /**
   * ReinspectionLink findUniqueOrThrow
   */
  export type ReinspectionLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * Filter, which ReinspectionLink to fetch.
     */
    where: ReinspectionLinkWhereUniqueInput
  }

  /**
   * ReinspectionLink findFirst
   */
  export type ReinspectionLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * Filter, which ReinspectionLink to fetch.
     */
    where?: ReinspectionLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReinspectionLinks to fetch.
     */
    orderBy?: ReinspectionLinkOrderByWithRelationInput | ReinspectionLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReinspectionLinks.
     */
    cursor?: ReinspectionLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReinspectionLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReinspectionLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReinspectionLinks.
     */
    distinct?: ReinspectionLinkScalarFieldEnum | ReinspectionLinkScalarFieldEnum[]
  }

  /**
   * ReinspectionLink findFirstOrThrow
   */
  export type ReinspectionLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * Filter, which ReinspectionLink to fetch.
     */
    where?: ReinspectionLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReinspectionLinks to fetch.
     */
    orderBy?: ReinspectionLinkOrderByWithRelationInput | ReinspectionLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReinspectionLinks.
     */
    cursor?: ReinspectionLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReinspectionLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReinspectionLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReinspectionLinks.
     */
    distinct?: ReinspectionLinkScalarFieldEnum | ReinspectionLinkScalarFieldEnum[]
  }

  /**
   * ReinspectionLink findMany
   */
  export type ReinspectionLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * Filter, which ReinspectionLinks to fetch.
     */
    where?: ReinspectionLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReinspectionLinks to fetch.
     */
    orderBy?: ReinspectionLinkOrderByWithRelationInput | ReinspectionLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReinspectionLinks.
     */
    cursor?: ReinspectionLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReinspectionLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReinspectionLinks.
     */
    skip?: number
    distinct?: ReinspectionLinkScalarFieldEnum | ReinspectionLinkScalarFieldEnum[]
  }

  /**
   * ReinspectionLink create
   */
  export type ReinspectionLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ReinspectionLink.
     */
    data: XOR<ReinspectionLinkCreateInput, ReinspectionLinkUncheckedCreateInput>
  }

  /**
   * ReinspectionLink createMany
   */
  export type ReinspectionLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReinspectionLinks.
     */
    data: ReinspectionLinkCreateManyInput | ReinspectionLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReinspectionLink createManyAndReturn
   */
  export type ReinspectionLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReinspectionLinks.
     */
    data: ReinspectionLinkCreateManyInput | ReinspectionLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReinspectionLink update
   */
  export type ReinspectionLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ReinspectionLink.
     */
    data: XOR<ReinspectionLinkUpdateInput, ReinspectionLinkUncheckedUpdateInput>
    /**
     * Choose, which ReinspectionLink to update.
     */
    where: ReinspectionLinkWhereUniqueInput
  }

  /**
   * ReinspectionLink updateMany
   */
  export type ReinspectionLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReinspectionLinks.
     */
    data: XOR<ReinspectionLinkUpdateManyMutationInput, ReinspectionLinkUncheckedUpdateManyInput>
    /**
     * Filter which ReinspectionLinks to update
     */
    where?: ReinspectionLinkWhereInput
  }

  /**
   * ReinspectionLink upsert
   */
  export type ReinspectionLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ReinspectionLink to update in case it exists.
     */
    where: ReinspectionLinkWhereUniqueInput
    /**
     * In case the ReinspectionLink found by the `where` argument doesn't exist, create a new ReinspectionLink with this data.
     */
    create: XOR<ReinspectionLinkCreateInput, ReinspectionLinkUncheckedCreateInput>
    /**
     * In case the ReinspectionLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReinspectionLinkUpdateInput, ReinspectionLinkUncheckedUpdateInput>
  }

  /**
   * ReinspectionLink delete
   */
  export type ReinspectionLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
    /**
     * Filter which ReinspectionLink to delete.
     */
    where: ReinspectionLinkWhereUniqueInput
  }

  /**
   * ReinspectionLink deleteMany
   */
  export type ReinspectionLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReinspectionLinks to delete
     */
    where?: ReinspectionLinkWhereInput
  }

  /**
   * ReinspectionLink without action
   */
  export type ReinspectionLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReinspectionLink
     */
    select?: ReinspectionLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReinspectionLinkInclude<ExtArgs> | null
  }


  /**
   * Model MediaRef
   */

  export type AggregateMediaRef = {
    _count: MediaRefCountAggregateOutputType | null
    _avg: MediaRefAvgAggregateOutputType | null
    _sum: MediaRefSumAggregateOutputType | null
    _min: MediaRefMinAggregateOutputType | null
    _max: MediaRefMaxAggregateOutputType | null
  }

  export type MediaRefAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
  }

  export type MediaRefSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
  }

  export type MediaRefMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    type: $Enums.MediaType | null
    storageUrl: string | null
    sha256: string | null
    capturedAt: Date | null
    cctvCameraId: string | null
    cctvStartTs: Date | null
    cctvEndTs: Date | null
  }

  export type MediaRefMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    type: $Enums.MediaType | null
    storageUrl: string | null
    sha256: string | null
    capturedAt: Date | null
    cctvCameraId: string | null
    cctvStartTs: Date | null
    cctvEndTs: Date | null
  }

  export type MediaRefCountAggregateOutputType = {
    id: number
    sessionId: number
    type: number
    storageUrl: number
    sha256: number
    capturedAt: number
    cctvCameraId: number
    cctvStartTs: number
    cctvEndTs: number
    _all: number
  }


  export type MediaRefAvgAggregateInputType = {
    id?: true
    sessionId?: true
  }

  export type MediaRefSumAggregateInputType = {
    id?: true
    sessionId?: true
  }

  export type MediaRefMinAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    storageUrl?: true
    sha256?: true
    capturedAt?: true
    cctvCameraId?: true
    cctvStartTs?: true
    cctvEndTs?: true
  }

  export type MediaRefMaxAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    storageUrl?: true
    sha256?: true
    capturedAt?: true
    cctvCameraId?: true
    cctvStartTs?: true
    cctvEndTs?: true
  }

  export type MediaRefCountAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    storageUrl?: true
    sha256?: true
    capturedAt?: true
    cctvCameraId?: true
    cctvStartTs?: true
    cctvEndTs?: true
    _all?: true
  }

  export type MediaRefAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaRef to aggregate.
     */
    where?: MediaRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaRefs to fetch.
     */
    orderBy?: MediaRefOrderByWithRelationInput | MediaRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaRefs
    **/
    _count?: true | MediaRefCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaRefAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaRefSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaRefMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaRefMaxAggregateInputType
  }

  export type GetMediaRefAggregateType<T extends MediaRefAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaRef]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaRef[P]>
      : GetScalarType<T[P], AggregateMediaRef[P]>
  }




  export type MediaRefGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaRefWhereInput
    orderBy?: MediaRefOrderByWithAggregationInput | MediaRefOrderByWithAggregationInput[]
    by: MediaRefScalarFieldEnum[] | MediaRefScalarFieldEnum
    having?: MediaRefScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaRefCountAggregateInputType | true
    _avg?: MediaRefAvgAggregateInputType
    _sum?: MediaRefSumAggregateInputType
    _min?: MediaRefMinAggregateInputType
    _max?: MediaRefMaxAggregateInputType
  }

  export type MediaRefGroupByOutputType = {
    id: number
    sessionId: number
    type: $Enums.MediaType
    storageUrl: string
    sha256: string | null
    capturedAt: Date
    cctvCameraId: string | null
    cctvStartTs: Date | null
    cctvEndTs: Date | null
    _count: MediaRefCountAggregateOutputType | null
    _avg: MediaRefAvgAggregateOutputType | null
    _sum: MediaRefSumAggregateOutputType | null
    _min: MediaRefMinAggregateOutputType | null
    _max: MediaRefMaxAggregateOutputType | null
  }

  type GetMediaRefGroupByPayload<T extends MediaRefGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaRefGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaRefGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaRefGroupByOutputType[P]>
            : GetScalarType<T[P], MediaRefGroupByOutputType[P]>
        }
      >
    >


  export type MediaRefSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    storageUrl?: boolean
    sha256?: boolean
    capturedAt?: boolean
    cctvCameraId?: boolean
    cctvStartTs?: boolean
    cctvEndTs?: boolean
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaRef"]>

  export type MediaRefSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    storageUrl?: boolean
    sha256?: boolean
    capturedAt?: boolean
    cctvCameraId?: boolean
    cctvStartTs?: boolean
    cctvEndTs?: boolean
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaRef"]>

  export type MediaRefSelectScalar = {
    id?: boolean
    sessionId?: boolean
    type?: boolean
    storageUrl?: boolean
    sha256?: boolean
    capturedAt?: boolean
    cctvCameraId?: boolean
    cctvStartTs?: boolean
    cctvEndTs?: boolean
  }

  export type MediaRefInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }
  export type MediaRefIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InspectionSessionDefaultArgs<ExtArgs>
  }

  export type $MediaRefPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaRef"
    objects: {
      session: Prisma.$InspectionSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      type: $Enums.MediaType
      storageUrl: string
      sha256: string | null
      capturedAt: Date
      cctvCameraId: string | null
      cctvStartTs: Date | null
      cctvEndTs: Date | null
    }, ExtArgs["result"]["mediaRef"]>
    composites: {}
  }

  type MediaRefGetPayload<S extends boolean | null | undefined | MediaRefDefaultArgs> = $Result.GetResult<Prisma.$MediaRefPayload, S>

  type MediaRefCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaRefFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaRefCountAggregateInputType | true
    }

  export interface MediaRefDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaRef'], meta: { name: 'MediaRef' } }
    /**
     * Find zero or one MediaRef that matches the filter.
     * @param {MediaRefFindUniqueArgs} args - Arguments to find a MediaRef
     * @example
     * // Get one MediaRef
     * const mediaRef = await prisma.mediaRef.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaRefFindUniqueArgs>(args: SelectSubset<T, MediaRefFindUniqueArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MediaRef that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaRefFindUniqueOrThrowArgs} args - Arguments to find a MediaRef
     * @example
     * // Get one MediaRef
     * const mediaRef = await prisma.mediaRef.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaRefFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaRefFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MediaRef that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefFindFirstArgs} args - Arguments to find a MediaRef
     * @example
     * // Get one MediaRef
     * const mediaRef = await prisma.mediaRef.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaRefFindFirstArgs>(args?: SelectSubset<T, MediaRefFindFirstArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MediaRef that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefFindFirstOrThrowArgs} args - Arguments to find a MediaRef
     * @example
     * // Get one MediaRef
     * const mediaRef = await prisma.mediaRef.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaRefFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaRefFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MediaRefs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaRefs
     * const mediaRefs = await prisma.mediaRef.findMany()
     * 
     * // Get first 10 MediaRefs
     * const mediaRefs = await prisma.mediaRef.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaRefWithIdOnly = await prisma.mediaRef.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaRefFindManyArgs>(args?: SelectSubset<T, MediaRefFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MediaRef.
     * @param {MediaRefCreateArgs} args - Arguments to create a MediaRef.
     * @example
     * // Create one MediaRef
     * const MediaRef = await prisma.mediaRef.create({
     *   data: {
     *     // ... data to create a MediaRef
     *   }
     * })
     * 
     */
    create<T extends MediaRefCreateArgs>(args: SelectSubset<T, MediaRefCreateArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MediaRefs.
     * @param {MediaRefCreateManyArgs} args - Arguments to create many MediaRefs.
     * @example
     * // Create many MediaRefs
     * const mediaRef = await prisma.mediaRef.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaRefCreateManyArgs>(args?: SelectSubset<T, MediaRefCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaRefs and returns the data saved in the database.
     * @param {MediaRefCreateManyAndReturnArgs} args - Arguments to create many MediaRefs.
     * @example
     * // Create many MediaRefs
     * const mediaRef = await prisma.mediaRef.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaRefs and only return the `id`
     * const mediaRefWithIdOnly = await prisma.mediaRef.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaRefCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaRefCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MediaRef.
     * @param {MediaRefDeleteArgs} args - Arguments to delete one MediaRef.
     * @example
     * // Delete one MediaRef
     * const MediaRef = await prisma.mediaRef.delete({
     *   where: {
     *     // ... filter to delete one MediaRef
     *   }
     * })
     * 
     */
    delete<T extends MediaRefDeleteArgs>(args: SelectSubset<T, MediaRefDeleteArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MediaRef.
     * @param {MediaRefUpdateArgs} args - Arguments to update one MediaRef.
     * @example
     * // Update one MediaRef
     * const mediaRef = await prisma.mediaRef.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaRefUpdateArgs>(args: SelectSubset<T, MediaRefUpdateArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MediaRefs.
     * @param {MediaRefDeleteManyArgs} args - Arguments to filter MediaRefs to delete.
     * @example
     * // Delete a few MediaRefs
     * const { count } = await prisma.mediaRef.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaRefDeleteManyArgs>(args?: SelectSubset<T, MediaRefDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaRefs
     * const mediaRef = await prisma.mediaRef.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaRefUpdateManyArgs>(args: SelectSubset<T, MediaRefUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaRef.
     * @param {MediaRefUpsertArgs} args - Arguments to update or create a MediaRef.
     * @example
     * // Update or create a MediaRef
     * const mediaRef = await prisma.mediaRef.upsert({
     *   create: {
     *     // ... data to create a MediaRef
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaRef we want to update
     *   }
     * })
     */
    upsert<T extends MediaRefUpsertArgs>(args: SelectSubset<T, MediaRefUpsertArgs<ExtArgs>>): Prisma__MediaRefClient<$Result.GetResult<Prisma.$MediaRefPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MediaRefs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefCountArgs} args - Arguments to filter MediaRefs to count.
     * @example
     * // Count the number of MediaRefs
     * const count = await prisma.mediaRef.count({
     *   where: {
     *     // ... the filter for the MediaRefs we want to count
     *   }
     * })
    **/
    count<T extends MediaRefCountArgs>(
      args?: Subset<T, MediaRefCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaRefCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaRefAggregateArgs>(args: Subset<T, MediaRefAggregateArgs>): Prisma.PrismaPromise<GetMediaRefAggregateType<T>>

    /**
     * Group by MediaRef.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaRefGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaRefGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaRefGroupByArgs['orderBy'] }
        : { orderBy?: MediaRefGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaRefGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaRefGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaRef model
   */
  readonly fields: MediaRefFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaRef.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaRefClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends InspectionSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InspectionSessionDefaultArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaRef model
   */ 
  interface MediaRefFieldRefs {
    readonly id: FieldRef<"MediaRef", 'Int'>
    readonly sessionId: FieldRef<"MediaRef", 'Int'>
    readonly type: FieldRef<"MediaRef", 'MediaType'>
    readonly storageUrl: FieldRef<"MediaRef", 'String'>
    readonly sha256: FieldRef<"MediaRef", 'String'>
    readonly capturedAt: FieldRef<"MediaRef", 'DateTime'>
    readonly cctvCameraId: FieldRef<"MediaRef", 'String'>
    readonly cctvStartTs: FieldRef<"MediaRef", 'DateTime'>
    readonly cctvEndTs: FieldRef<"MediaRef", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaRef findUnique
   */
  export type MediaRefFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * Filter, which MediaRef to fetch.
     */
    where: MediaRefWhereUniqueInput
  }

  /**
   * MediaRef findUniqueOrThrow
   */
  export type MediaRefFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * Filter, which MediaRef to fetch.
     */
    where: MediaRefWhereUniqueInput
  }

  /**
   * MediaRef findFirst
   */
  export type MediaRefFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * Filter, which MediaRef to fetch.
     */
    where?: MediaRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaRefs to fetch.
     */
    orderBy?: MediaRefOrderByWithRelationInput | MediaRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaRefs.
     */
    cursor?: MediaRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaRefs.
     */
    distinct?: MediaRefScalarFieldEnum | MediaRefScalarFieldEnum[]
  }

  /**
   * MediaRef findFirstOrThrow
   */
  export type MediaRefFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * Filter, which MediaRef to fetch.
     */
    where?: MediaRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaRefs to fetch.
     */
    orderBy?: MediaRefOrderByWithRelationInput | MediaRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaRefs.
     */
    cursor?: MediaRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaRefs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaRefs.
     */
    distinct?: MediaRefScalarFieldEnum | MediaRefScalarFieldEnum[]
  }

  /**
   * MediaRef findMany
   */
  export type MediaRefFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * Filter, which MediaRefs to fetch.
     */
    where?: MediaRefWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaRefs to fetch.
     */
    orderBy?: MediaRefOrderByWithRelationInput | MediaRefOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaRefs.
     */
    cursor?: MediaRefWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaRefs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaRefs.
     */
    skip?: number
    distinct?: MediaRefScalarFieldEnum | MediaRefScalarFieldEnum[]
  }

  /**
   * MediaRef create
   */
  export type MediaRefCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaRef.
     */
    data: XOR<MediaRefCreateInput, MediaRefUncheckedCreateInput>
  }

  /**
   * MediaRef createMany
   */
  export type MediaRefCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaRefs.
     */
    data: MediaRefCreateManyInput | MediaRefCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaRef createManyAndReturn
   */
  export type MediaRefCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MediaRefs.
     */
    data: MediaRefCreateManyInput | MediaRefCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaRef update
   */
  export type MediaRefUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaRef.
     */
    data: XOR<MediaRefUpdateInput, MediaRefUncheckedUpdateInput>
    /**
     * Choose, which MediaRef to update.
     */
    where: MediaRefWhereUniqueInput
  }

  /**
   * MediaRef updateMany
   */
  export type MediaRefUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaRefs.
     */
    data: XOR<MediaRefUpdateManyMutationInput, MediaRefUncheckedUpdateManyInput>
    /**
     * Filter which MediaRefs to update
     */
    where?: MediaRefWhereInput
  }

  /**
   * MediaRef upsert
   */
  export type MediaRefUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaRef to update in case it exists.
     */
    where: MediaRefWhereUniqueInput
    /**
     * In case the MediaRef found by the `where` argument doesn't exist, create a new MediaRef with this data.
     */
    create: XOR<MediaRefCreateInput, MediaRefUncheckedCreateInput>
    /**
     * In case the MediaRef was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaRefUpdateInput, MediaRefUncheckedUpdateInput>
  }

  /**
   * MediaRef delete
   */
  export type MediaRefDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
    /**
     * Filter which MediaRef to delete.
     */
    where: MediaRefWhereUniqueInput
  }

  /**
   * MediaRef deleteMany
   */
  export type MediaRefDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaRefs to delete
     */
    where?: MediaRefWhereInput
  }

  /**
   * MediaRef without action
   */
  export type MediaRefDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaRef
     */
    select?: MediaRefSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaRefInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    tenantId: number | null
    actorUserId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    tenantId: number | null
    actorUserId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    tenantId: number | null
    actorUserId: number | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    tenantId: number | null
    actorUserId: number | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    actorUserId: number
    action: number
    entityType: number
    entityId: number
    ip: number
    userAgent: number
    beforeJson: number
    afterJson: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    actorUserId?: true
    action?: true
    entityType?: true
    entityId?: true
    ip?: true
    userAgent?: true
    beforeJson?: true
    afterJson?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    tenantId: number
    actorUserId: number | null
    action: string
    entityType: string
    entityId: string
    ip: string | null
    userAgent: string | null
    beforeJson: JsonValue | null
    afterJson: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    beforeJson?: boolean
    afterJson?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    beforeJson?: boolean
    afterJson?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    actorUserId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    ip?: boolean
    userAgent?: boolean
    beforeJson?: boolean
    afterJson?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tenantId: number
      actorUserId: number | null
      action: string
      entityType: string
      entityId: string
      ip: string | null
      userAgent: string | null
      beforeJson: Prisma.JsonValue | null
      afterJson: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly tenantId: FieldRef<"AuditLog", 'Int'>
    readonly actorUserId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly beforeJson: FieldRef<"AuditLog", 'Json'>
    readonly afterJson: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Insurer
   */

  export type AggregateInsurer = {
    _count: InsurerCountAggregateOutputType | null
    _avg: InsurerAvgAggregateOutputType | null
    _sum: InsurerSumAggregateOutputType | null
    _min: InsurerMinAggregateOutputType | null
    _max: InsurerMaxAggregateOutputType | null
  }

  export type InsurerAvgAggregateOutputType = {
    id: number | null
  }

  export type InsurerSumAggregateOutputType = {
    id: number | null
  }

  export type InsurerMinAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    status: $Enums.InsurerStatus | null
  }

  export type InsurerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    status: $Enums.InsurerStatus | null
  }

  export type InsurerCountAggregateOutputType = {
    id: number
    name: number
    contactPerson: number
    email: number
    phone: number
    status: number
    _all: number
  }


  export type InsurerAvgAggregateInputType = {
    id?: true
  }

  export type InsurerSumAggregateInputType = {
    id?: true
  }

  export type InsurerMinAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    status?: true
  }

  export type InsurerMaxAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    status?: true
  }

  export type InsurerCountAggregateInputType = {
    id?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    status?: true
    _all?: true
  }

  export type InsurerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurer to aggregate.
     */
    where?: InsurerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurers to fetch.
     */
    orderBy?: InsurerOrderByWithRelationInput | InsurerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsurerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insurers
    **/
    _count?: true | InsurerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsurerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsurerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsurerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsurerMaxAggregateInputType
  }

  export type GetInsurerAggregateType<T extends InsurerAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurer[P]>
      : GetScalarType<T[P], AggregateInsurer[P]>
  }




  export type InsurerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurerWhereInput
    orderBy?: InsurerOrderByWithAggregationInput | InsurerOrderByWithAggregationInput[]
    by: InsurerScalarFieldEnum[] | InsurerScalarFieldEnum
    having?: InsurerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsurerCountAggregateInputType | true
    _avg?: InsurerAvgAggregateInputType
    _sum?: InsurerSumAggregateInputType
    _min?: InsurerMinAggregateInputType
    _max?: InsurerMaxAggregateInputType
  }

  export type InsurerGroupByOutputType = {
    id: number
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    status: $Enums.InsurerStatus
    _count: InsurerCountAggregateOutputType | null
    _avg: InsurerAvgAggregateOutputType | null
    _sum: InsurerSumAggregateOutputType | null
    _min: InsurerMinAggregateOutputType | null
    _max: InsurerMaxAggregateOutputType | null
  }

  type GetInsurerGroupByPayload<T extends InsurerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsurerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsurerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsurerGroupByOutputType[P]>
            : GetScalarType<T[P], InsurerGroupByOutputType[P]>
        }
      >
    >


  export type InsurerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    users?: boolean | Insurer$usersArgs<ExtArgs>
    apiKeys?: boolean | Insurer$apiKeysArgs<ExtArgs>
    apiUsageLogs?: boolean | Insurer$apiUsageLogsArgs<ExtArgs>
    agents?: boolean | Insurer$agentsArgs<ExtArgs>
    _count?: boolean | InsurerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurer"]>

  export type InsurerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
  }, ExtArgs["result"]["insurer"]>

  export type InsurerSelectScalar = {
    id?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
  }

  export type InsurerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Insurer$usersArgs<ExtArgs>
    apiKeys?: boolean | Insurer$apiKeysArgs<ExtArgs>
    apiUsageLogs?: boolean | Insurer$apiUsageLogsArgs<ExtArgs>
    agents?: boolean | Insurer$agentsArgs<ExtArgs>
    _count?: boolean | InsurerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InsurerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InsurerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insurer"
    objects: {
      users: Prisma.$InsurerUserPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      apiUsageLogs: Prisma.$ApiUsageLogPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      status: $Enums.InsurerStatus
    }, ExtArgs["result"]["insurer"]>
    composites: {}
  }

  type InsurerGetPayload<S extends boolean | null | undefined | InsurerDefaultArgs> = $Result.GetResult<Prisma.$InsurerPayload, S>

  type InsurerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsurerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsurerCountAggregateInputType | true
    }

  export interface InsurerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insurer'], meta: { name: 'Insurer' } }
    /**
     * Find zero or one Insurer that matches the filter.
     * @param {InsurerFindUniqueArgs} args - Arguments to find a Insurer
     * @example
     * // Get one Insurer
     * const insurer = await prisma.insurer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsurerFindUniqueArgs>(args: SelectSubset<T, InsurerFindUniqueArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Insurer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsurerFindUniqueOrThrowArgs} args - Arguments to find a Insurer
     * @example
     * // Get one Insurer
     * const insurer = await prisma.insurer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsurerFindUniqueOrThrowArgs>(args: SelectSubset<T, InsurerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Insurer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerFindFirstArgs} args - Arguments to find a Insurer
     * @example
     * // Get one Insurer
     * const insurer = await prisma.insurer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsurerFindFirstArgs>(args?: SelectSubset<T, InsurerFindFirstArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Insurer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerFindFirstOrThrowArgs} args - Arguments to find a Insurer
     * @example
     * // Get one Insurer
     * const insurer = await prisma.insurer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsurerFindFirstOrThrowArgs>(args?: SelectSubset<T, InsurerFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Insurers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insurers
     * const insurers = await prisma.insurer.findMany()
     * 
     * // Get first 10 Insurers
     * const insurers = await prisma.insurer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insurerWithIdOnly = await prisma.insurer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsurerFindManyArgs>(args?: SelectSubset<T, InsurerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Insurer.
     * @param {InsurerCreateArgs} args - Arguments to create a Insurer.
     * @example
     * // Create one Insurer
     * const Insurer = await prisma.insurer.create({
     *   data: {
     *     // ... data to create a Insurer
     *   }
     * })
     * 
     */
    create<T extends InsurerCreateArgs>(args: SelectSubset<T, InsurerCreateArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Insurers.
     * @param {InsurerCreateManyArgs} args - Arguments to create many Insurers.
     * @example
     * // Create many Insurers
     * const insurer = await prisma.insurer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsurerCreateManyArgs>(args?: SelectSubset<T, InsurerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insurers and returns the data saved in the database.
     * @param {InsurerCreateManyAndReturnArgs} args - Arguments to create many Insurers.
     * @example
     * // Create many Insurers
     * const insurer = await prisma.insurer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insurers and only return the `id`
     * const insurerWithIdOnly = await prisma.insurer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsurerCreateManyAndReturnArgs>(args?: SelectSubset<T, InsurerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Insurer.
     * @param {InsurerDeleteArgs} args - Arguments to delete one Insurer.
     * @example
     * // Delete one Insurer
     * const Insurer = await prisma.insurer.delete({
     *   where: {
     *     // ... filter to delete one Insurer
     *   }
     * })
     * 
     */
    delete<T extends InsurerDeleteArgs>(args: SelectSubset<T, InsurerDeleteArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Insurer.
     * @param {InsurerUpdateArgs} args - Arguments to update one Insurer.
     * @example
     * // Update one Insurer
     * const insurer = await prisma.insurer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsurerUpdateArgs>(args: SelectSubset<T, InsurerUpdateArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Insurers.
     * @param {InsurerDeleteManyArgs} args - Arguments to filter Insurers to delete.
     * @example
     * // Delete a few Insurers
     * const { count } = await prisma.insurer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsurerDeleteManyArgs>(args?: SelectSubset<T, InsurerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insurers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insurers
     * const insurer = await prisma.insurer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsurerUpdateManyArgs>(args: SelectSubset<T, InsurerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insurer.
     * @param {InsurerUpsertArgs} args - Arguments to update or create a Insurer.
     * @example
     * // Update or create a Insurer
     * const insurer = await prisma.insurer.upsert({
     *   create: {
     *     // ... data to create a Insurer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insurer we want to update
     *   }
     * })
     */
    upsert<T extends InsurerUpsertArgs>(args: SelectSubset<T, InsurerUpsertArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Insurers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerCountArgs} args - Arguments to filter Insurers to count.
     * @example
     * // Count the number of Insurers
     * const count = await prisma.insurer.count({
     *   where: {
     *     // ... the filter for the Insurers we want to count
     *   }
     * })
    **/
    count<T extends InsurerCountArgs>(
      args?: Subset<T, InsurerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsurerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insurer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsurerAggregateArgs>(args: Subset<T, InsurerAggregateArgs>): Prisma.PrismaPromise<GetInsurerAggregateType<T>>

    /**
     * Group by Insurer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsurerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsurerGroupByArgs['orderBy'] }
        : { orderBy?: InsurerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsurerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsurerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insurer model
   */
  readonly fields: InsurerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insurer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsurerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Insurer$usersArgs<ExtArgs> = {}>(args?: Subset<T, Insurer$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends Insurer$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, Insurer$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    apiUsageLogs<T extends Insurer$apiUsageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Insurer$apiUsageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findMany"> | Null>
    agents<T extends Insurer$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Insurer$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insurer model
   */ 
  interface InsurerFieldRefs {
    readonly id: FieldRef<"Insurer", 'Int'>
    readonly name: FieldRef<"Insurer", 'String'>
    readonly contactPerson: FieldRef<"Insurer", 'String'>
    readonly email: FieldRef<"Insurer", 'String'>
    readonly phone: FieldRef<"Insurer", 'String'>
    readonly status: FieldRef<"Insurer", 'InsurerStatus'>
  }
    

  // Custom InputTypes
  /**
   * Insurer findUnique
   */
  export type InsurerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * Filter, which Insurer to fetch.
     */
    where: InsurerWhereUniqueInput
  }

  /**
   * Insurer findUniqueOrThrow
   */
  export type InsurerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * Filter, which Insurer to fetch.
     */
    where: InsurerWhereUniqueInput
  }

  /**
   * Insurer findFirst
   */
  export type InsurerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * Filter, which Insurer to fetch.
     */
    where?: InsurerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurers to fetch.
     */
    orderBy?: InsurerOrderByWithRelationInput | InsurerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurers.
     */
    cursor?: InsurerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurers.
     */
    distinct?: InsurerScalarFieldEnum | InsurerScalarFieldEnum[]
  }

  /**
   * Insurer findFirstOrThrow
   */
  export type InsurerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * Filter, which Insurer to fetch.
     */
    where?: InsurerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurers to fetch.
     */
    orderBy?: InsurerOrderByWithRelationInput | InsurerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurers.
     */
    cursor?: InsurerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurers.
     */
    distinct?: InsurerScalarFieldEnum | InsurerScalarFieldEnum[]
  }

  /**
   * Insurer findMany
   */
  export type InsurerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * Filter, which Insurers to fetch.
     */
    where?: InsurerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurers to fetch.
     */
    orderBy?: InsurerOrderByWithRelationInput | InsurerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insurers.
     */
    cursor?: InsurerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurers.
     */
    skip?: number
    distinct?: InsurerScalarFieldEnum | InsurerScalarFieldEnum[]
  }

  /**
   * Insurer create
   */
  export type InsurerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * The data needed to create a Insurer.
     */
    data: XOR<InsurerCreateInput, InsurerUncheckedCreateInput>
  }

  /**
   * Insurer createMany
   */
  export type InsurerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insurers.
     */
    data: InsurerCreateManyInput | InsurerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insurer createManyAndReturn
   */
  export type InsurerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Insurers.
     */
    data: InsurerCreateManyInput | InsurerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insurer update
   */
  export type InsurerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * The data needed to update a Insurer.
     */
    data: XOR<InsurerUpdateInput, InsurerUncheckedUpdateInput>
    /**
     * Choose, which Insurer to update.
     */
    where: InsurerWhereUniqueInput
  }

  /**
   * Insurer updateMany
   */
  export type InsurerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insurers.
     */
    data: XOR<InsurerUpdateManyMutationInput, InsurerUncheckedUpdateManyInput>
    /**
     * Filter which Insurers to update
     */
    where?: InsurerWhereInput
  }

  /**
   * Insurer upsert
   */
  export type InsurerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * The filter to search for the Insurer to update in case it exists.
     */
    where: InsurerWhereUniqueInput
    /**
     * In case the Insurer found by the `where` argument doesn't exist, create a new Insurer with this data.
     */
    create: XOR<InsurerCreateInput, InsurerUncheckedCreateInput>
    /**
     * In case the Insurer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsurerUpdateInput, InsurerUncheckedUpdateInput>
  }

  /**
   * Insurer delete
   */
  export type InsurerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    /**
     * Filter which Insurer to delete.
     */
    where: InsurerWhereUniqueInput
  }

  /**
   * Insurer deleteMany
   */
  export type InsurerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurers to delete
     */
    where?: InsurerWhereInput
  }

  /**
   * Insurer.users
   */
  export type Insurer$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    where?: InsurerUserWhereInput
    orderBy?: InsurerUserOrderByWithRelationInput | InsurerUserOrderByWithRelationInput[]
    cursor?: InsurerUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsurerUserScalarFieldEnum | InsurerUserScalarFieldEnum[]
  }

  /**
   * Insurer.apiKeys
   */
  export type Insurer$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * Insurer.apiUsageLogs
   */
  export type Insurer$apiUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    where?: ApiUsageLogWhereInput
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    cursor?: ApiUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * Insurer.agents
   */
  export type Insurer$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Insurer without action
   */
  export type InsurerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
  }


  /**
   * Model InsurerUser
   */

  export type AggregateInsurerUser = {
    _count: InsurerUserCountAggregateOutputType | null
    _avg: InsurerUserAvgAggregateOutputType | null
    _sum: InsurerUserSumAggregateOutputType | null
    _min: InsurerUserMinAggregateOutputType | null
    _max: InsurerUserMaxAggregateOutputType | null
  }

  export type InsurerUserAvgAggregateOutputType = {
    id: number | null
    insurerId: number | null
    userId: number | null
  }

  export type InsurerUserSumAggregateOutputType = {
    id: number | null
    insurerId: number | null
    userId: number | null
  }

  export type InsurerUserMinAggregateOutputType = {
    id: number | null
    insurerId: number | null
    userId: number | null
  }

  export type InsurerUserMaxAggregateOutputType = {
    id: number | null
    insurerId: number | null
    userId: number | null
  }

  export type InsurerUserCountAggregateOutputType = {
    id: number
    insurerId: number
    userId: number
    _all: number
  }


  export type InsurerUserAvgAggregateInputType = {
    id?: true
    insurerId?: true
    userId?: true
  }

  export type InsurerUserSumAggregateInputType = {
    id?: true
    insurerId?: true
    userId?: true
  }

  export type InsurerUserMinAggregateInputType = {
    id?: true
    insurerId?: true
    userId?: true
  }

  export type InsurerUserMaxAggregateInputType = {
    id?: true
    insurerId?: true
    userId?: true
  }

  export type InsurerUserCountAggregateInputType = {
    id?: true
    insurerId?: true
    userId?: true
    _all?: true
  }

  export type InsurerUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsurerUser to aggregate.
     */
    where?: InsurerUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurerUsers to fetch.
     */
    orderBy?: InsurerUserOrderByWithRelationInput | InsurerUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsurerUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurerUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurerUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsurerUsers
    **/
    _count?: true | InsurerUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsurerUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsurerUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsurerUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsurerUserMaxAggregateInputType
  }

  export type GetInsurerUserAggregateType<T extends InsurerUserAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurerUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurerUser[P]>
      : GetScalarType<T[P], AggregateInsurerUser[P]>
  }




  export type InsurerUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurerUserWhereInput
    orderBy?: InsurerUserOrderByWithAggregationInput | InsurerUserOrderByWithAggregationInput[]
    by: InsurerUserScalarFieldEnum[] | InsurerUserScalarFieldEnum
    having?: InsurerUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsurerUserCountAggregateInputType | true
    _avg?: InsurerUserAvgAggregateInputType
    _sum?: InsurerUserSumAggregateInputType
    _min?: InsurerUserMinAggregateInputType
    _max?: InsurerUserMaxAggregateInputType
  }

  export type InsurerUserGroupByOutputType = {
    id: number
    insurerId: number
    userId: number
    _count: InsurerUserCountAggregateOutputType | null
    _avg: InsurerUserAvgAggregateOutputType | null
    _sum: InsurerUserSumAggregateOutputType | null
    _min: InsurerUserMinAggregateOutputType | null
    _max: InsurerUserMaxAggregateOutputType | null
  }

  type GetInsurerUserGroupByPayload<T extends InsurerUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsurerUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsurerUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsurerUserGroupByOutputType[P]>
            : GetScalarType<T[P], InsurerUserGroupByOutputType[P]>
        }
      >
    >


  export type InsurerUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerId?: boolean
    userId?: boolean
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurerUser"]>

  export type InsurerUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerId?: boolean
    userId?: boolean
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurerUser"]>

  export type InsurerUserSelectScalar = {
    id?: boolean
    insurerId?: boolean
    userId?: boolean
  }

  export type InsurerUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InsurerUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InsurerUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsurerUser"
    objects: {
      insurer: Prisma.$InsurerPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerId: number
      userId: number
    }, ExtArgs["result"]["insurerUser"]>
    composites: {}
  }

  type InsurerUserGetPayload<S extends boolean | null | undefined | InsurerUserDefaultArgs> = $Result.GetResult<Prisma.$InsurerUserPayload, S>

  type InsurerUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsurerUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsurerUserCountAggregateInputType | true
    }

  export interface InsurerUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsurerUser'], meta: { name: 'InsurerUser' } }
    /**
     * Find zero or one InsurerUser that matches the filter.
     * @param {InsurerUserFindUniqueArgs} args - Arguments to find a InsurerUser
     * @example
     * // Get one InsurerUser
     * const insurerUser = await prisma.insurerUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsurerUserFindUniqueArgs>(args: SelectSubset<T, InsurerUserFindUniqueArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InsurerUser that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsurerUserFindUniqueOrThrowArgs} args - Arguments to find a InsurerUser
     * @example
     * // Get one InsurerUser
     * const insurerUser = await prisma.insurerUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsurerUserFindUniqueOrThrowArgs>(args: SelectSubset<T, InsurerUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InsurerUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserFindFirstArgs} args - Arguments to find a InsurerUser
     * @example
     * // Get one InsurerUser
     * const insurerUser = await prisma.insurerUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsurerUserFindFirstArgs>(args?: SelectSubset<T, InsurerUserFindFirstArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InsurerUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserFindFirstOrThrowArgs} args - Arguments to find a InsurerUser
     * @example
     * // Get one InsurerUser
     * const insurerUser = await prisma.insurerUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsurerUserFindFirstOrThrowArgs>(args?: SelectSubset<T, InsurerUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InsurerUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsurerUsers
     * const insurerUsers = await prisma.insurerUser.findMany()
     * 
     * // Get first 10 InsurerUsers
     * const insurerUsers = await prisma.insurerUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insurerUserWithIdOnly = await prisma.insurerUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsurerUserFindManyArgs>(args?: SelectSubset<T, InsurerUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InsurerUser.
     * @param {InsurerUserCreateArgs} args - Arguments to create a InsurerUser.
     * @example
     * // Create one InsurerUser
     * const InsurerUser = await prisma.insurerUser.create({
     *   data: {
     *     // ... data to create a InsurerUser
     *   }
     * })
     * 
     */
    create<T extends InsurerUserCreateArgs>(args: SelectSubset<T, InsurerUserCreateArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InsurerUsers.
     * @param {InsurerUserCreateManyArgs} args - Arguments to create many InsurerUsers.
     * @example
     * // Create many InsurerUsers
     * const insurerUser = await prisma.insurerUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsurerUserCreateManyArgs>(args?: SelectSubset<T, InsurerUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsurerUsers and returns the data saved in the database.
     * @param {InsurerUserCreateManyAndReturnArgs} args - Arguments to create many InsurerUsers.
     * @example
     * // Create many InsurerUsers
     * const insurerUser = await prisma.insurerUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsurerUsers and only return the `id`
     * const insurerUserWithIdOnly = await prisma.insurerUser.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsurerUserCreateManyAndReturnArgs>(args?: SelectSubset<T, InsurerUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InsurerUser.
     * @param {InsurerUserDeleteArgs} args - Arguments to delete one InsurerUser.
     * @example
     * // Delete one InsurerUser
     * const InsurerUser = await prisma.insurerUser.delete({
     *   where: {
     *     // ... filter to delete one InsurerUser
     *   }
     * })
     * 
     */
    delete<T extends InsurerUserDeleteArgs>(args: SelectSubset<T, InsurerUserDeleteArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InsurerUser.
     * @param {InsurerUserUpdateArgs} args - Arguments to update one InsurerUser.
     * @example
     * // Update one InsurerUser
     * const insurerUser = await prisma.insurerUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsurerUserUpdateArgs>(args: SelectSubset<T, InsurerUserUpdateArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InsurerUsers.
     * @param {InsurerUserDeleteManyArgs} args - Arguments to filter InsurerUsers to delete.
     * @example
     * // Delete a few InsurerUsers
     * const { count } = await prisma.insurerUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsurerUserDeleteManyArgs>(args?: SelectSubset<T, InsurerUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsurerUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsurerUsers
     * const insurerUser = await prisma.insurerUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsurerUserUpdateManyArgs>(args: SelectSubset<T, InsurerUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsurerUser.
     * @param {InsurerUserUpsertArgs} args - Arguments to update or create a InsurerUser.
     * @example
     * // Update or create a InsurerUser
     * const insurerUser = await prisma.insurerUser.upsert({
     *   create: {
     *     // ... data to create a InsurerUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsurerUser we want to update
     *   }
     * })
     */
    upsert<T extends InsurerUserUpsertArgs>(args: SelectSubset<T, InsurerUserUpsertArgs<ExtArgs>>): Prisma__InsurerUserClient<$Result.GetResult<Prisma.$InsurerUserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InsurerUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserCountArgs} args - Arguments to filter InsurerUsers to count.
     * @example
     * // Count the number of InsurerUsers
     * const count = await prisma.insurerUser.count({
     *   where: {
     *     // ... the filter for the InsurerUsers we want to count
     *   }
     * })
    **/
    count<T extends InsurerUserCountArgs>(
      args?: Subset<T, InsurerUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsurerUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsurerUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsurerUserAggregateArgs>(args: Subset<T, InsurerUserAggregateArgs>): Prisma.PrismaPromise<GetInsurerUserAggregateType<T>>

    /**
     * Group by InsurerUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurerUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsurerUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsurerUserGroupByArgs['orderBy'] }
        : { orderBy?: InsurerUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsurerUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsurerUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsurerUser model
   */
  readonly fields: InsurerUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsurerUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsurerUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurer<T extends InsurerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsurerDefaultArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsurerUser model
   */ 
  interface InsurerUserFieldRefs {
    readonly id: FieldRef<"InsurerUser", 'Int'>
    readonly insurerId: FieldRef<"InsurerUser", 'Int'>
    readonly userId: FieldRef<"InsurerUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InsurerUser findUnique
   */
  export type InsurerUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * Filter, which InsurerUser to fetch.
     */
    where: InsurerUserWhereUniqueInput
  }

  /**
   * InsurerUser findUniqueOrThrow
   */
  export type InsurerUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * Filter, which InsurerUser to fetch.
     */
    where: InsurerUserWhereUniqueInput
  }

  /**
   * InsurerUser findFirst
   */
  export type InsurerUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * Filter, which InsurerUser to fetch.
     */
    where?: InsurerUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurerUsers to fetch.
     */
    orderBy?: InsurerUserOrderByWithRelationInput | InsurerUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsurerUsers.
     */
    cursor?: InsurerUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurerUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurerUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsurerUsers.
     */
    distinct?: InsurerUserScalarFieldEnum | InsurerUserScalarFieldEnum[]
  }

  /**
   * InsurerUser findFirstOrThrow
   */
  export type InsurerUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * Filter, which InsurerUser to fetch.
     */
    where?: InsurerUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurerUsers to fetch.
     */
    orderBy?: InsurerUserOrderByWithRelationInput | InsurerUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsurerUsers.
     */
    cursor?: InsurerUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurerUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurerUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsurerUsers.
     */
    distinct?: InsurerUserScalarFieldEnum | InsurerUserScalarFieldEnum[]
  }

  /**
   * InsurerUser findMany
   */
  export type InsurerUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * Filter, which InsurerUsers to fetch.
     */
    where?: InsurerUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurerUsers to fetch.
     */
    orderBy?: InsurerUserOrderByWithRelationInput | InsurerUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsurerUsers.
     */
    cursor?: InsurerUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurerUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurerUsers.
     */
    skip?: number
    distinct?: InsurerUserScalarFieldEnum | InsurerUserScalarFieldEnum[]
  }

  /**
   * InsurerUser create
   */
  export type InsurerUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * The data needed to create a InsurerUser.
     */
    data: XOR<InsurerUserCreateInput, InsurerUserUncheckedCreateInput>
  }

  /**
   * InsurerUser createMany
   */
  export type InsurerUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsurerUsers.
     */
    data: InsurerUserCreateManyInput | InsurerUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsurerUser createManyAndReturn
   */
  export type InsurerUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InsurerUsers.
     */
    data: InsurerUserCreateManyInput | InsurerUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsurerUser update
   */
  export type InsurerUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * The data needed to update a InsurerUser.
     */
    data: XOR<InsurerUserUpdateInput, InsurerUserUncheckedUpdateInput>
    /**
     * Choose, which InsurerUser to update.
     */
    where: InsurerUserWhereUniqueInput
  }

  /**
   * InsurerUser updateMany
   */
  export type InsurerUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsurerUsers.
     */
    data: XOR<InsurerUserUpdateManyMutationInput, InsurerUserUncheckedUpdateManyInput>
    /**
     * Filter which InsurerUsers to update
     */
    where?: InsurerUserWhereInput
  }

  /**
   * InsurerUser upsert
   */
  export type InsurerUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * The filter to search for the InsurerUser to update in case it exists.
     */
    where: InsurerUserWhereUniqueInput
    /**
     * In case the InsurerUser found by the `where` argument doesn't exist, create a new InsurerUser with this data.
     */
    create: XOR<InsurerUserCreateInput, InsurerUserUncheckedCreateInput>
    /**
     * In case the InsurerUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsurerUserUpdateInput, InsurerUserUncheckedUpdateInput>
  }

  /**
   * InsurerUser delete
   */
  export type InsurerUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
    /**
     * Filter which InsurerUser to delete.
     */
    where: InsurerUserWhereUniqueInput
  }

  /**
   * InsurerUser deleteMany
   */
  export type InsurerUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsurerUsers to delete
     */
    where?: InsurerUserWhereInput
  }

  /**
   * InsurerUser without action
   */
  export type InsurerUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurerUser
     */
    select?: InsurerUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerUserInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    id: number | null
    insurerId: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    id: number | null
    insurerId: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: number | null
    insurerId: number | null
    name: string | null
    keyHash: string | null
    lastUsedAt: Date | null
    revokedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: number | null
    insurerId: number | null
    name: string | null
    keyHash: string | null
    lastUsedAt: Date | null
    revokedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    insurerId: number
    name: number
    keyHash: number
    scopes: number
    lastUsedAt: number
    revokedAt: number
    createdAt: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    id?: true
    insurerId?: true
  }

  export type ApiKeySumAggregateInputType = {
    id?: true
    insurerId?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    insurerId?: true
    name?: true
    keyHash?: true
    lastUsedAt?: true
    revokedAt?: true
    createdAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    insurerId?: true
    name?: true
    keyHash?: true
    lastUsedAt?: true
    revokedAt?: true
    createdAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    insurerId?: true
    name?: true
    keyHash?: true
    scopes?: true
    lastUsedAt?: true
    revokedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: number
    insurerId: number
    name: string
    keyHash: string
    scopes: JsonValue | null
    lastUsedAt: Date | null
    revokedAt: Date | null
    createdAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerId?: boolean
    name?: boolean
    keyHash?: boolean
    scopes?: boolean
    lastUsedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerId?: boolean
    name?: boolean
    keyHash?: boolean
    scopes?: boolean
    lastUsedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    insurerId?: boolean
    name?: boolean
    keyHash?: boolean
    scopes?: boolean
    lastUsedAt?: boolean
    revokedAt?: boolean
    createdAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      insurer: Prisma.$InsurerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerId: number
      name: string
      keyHash: string
      scopes: Prisma.JsonValue | null
      lastUsedAt: Date | null
      revokedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurer<T extends InsurerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsurerDefaultArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'Int'>
    readonly insurerId: FieldRef<"ApiKey", 'Int'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly scopes: FieldRef<"ApiKey", 'Json'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly revokedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model ApiUsageLog
   */

  export type AggregateApiUsageLog = {
    _count: ApiUsageLogCountAggregateOutputType | null
    _avg: ApiUsageLogAvgAggregateOutputType | null
    _sum: ApiUsageLogSumAggregateOutputType | null
    _min: ApiUsageLogMinAggregateOutputType | null
    _max: ApiUsageLogMaxAggregateOutputType | null
  }

  export type ApiUsageLogAvgAggregateOutputType = {
    id: number | null
    insurerId: number | null
    vehicleId: number | null
    statusCode: number | null
    responseMs: number | null
  }

  export type ApiUsageLogSumAggregateOutputType = {
    id: number | null
    insurerId: number | null
    vehicleId: number | null
    statusCode: number | null
    responseMs: number | null
  }

  export type ApiUsageLogMinAggregateOutputType = {
    id: number | null
    insurerId: number | null
    endpoint: string | null
    vehicleId: number | null
    statusCode: number | null
    responseMs: number | null
    createdAt: Date | null
  }

  export type ApiUsageLogMaxAggregateOutputType = {
    id: number | null
    insurerId: number | null
    endpoint: string | null
    vehicleId: number | null
    statusCode: number | null
    responseMs: number | null
    createdAt: Date | null
  }

  export type ApiUsageLogCountAggregateOutputType = {
    id: number
    insurerId: number
    endpoint: number
    vehicleId: number
    statusCode: number
    responseMs: number
    createdAt: number
    _all: number
  }


  export type ApiUsageLogAvgAggregateInputType = {
    id?: true
    insurerId?: true
    vehicleId?: true
    statusCode?: true
    responseMs?: true
  }

  export type ApiUsageLogSumAggregateInputType = {
    id?: true
    insurerId?: true
    vehicleId?: true
    statusCode?: true
    responseMs?: true
  }

  export type ApiUsageLogMinAggregateInputType = {
    id?: true
    insurerId?: true
    endpoint?: true
    vehicleId?: true
    statusCode?: true
    responseMs?: true
    createdAt?: true
  }

  export type ApiUsageLogMaxAggregateInputType = {
    id?: true
    insurerId?: true
    endpoint?: true
    vehicleId?: true
    statusCode?: true
    responseMs?: true
    createdAt?: true
  }

  export type ApiUsageLogCountAggregateInputType = {
    id?: true
    insurerId?: true
    endpoint?: true
    vehicleId?: true
    statusCode?: true
    responseMs?: true
    createdAt?: true
    _all?: true
  }

  export type ApiUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiUsageLog to aggregate.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiUsageLogs
    **/
    _count?: true | ApiUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiUsageLogMaxAggregateInputType
  }

  export type GetApiUsageLogAggregateType<T extends ApiUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateApiUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiUsageLog[P]>
      : GetScalarType<T[P], AggregateApiUsageLog[P]>
  }




  export type ApiUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiUsageLogWhereInput
    orderBy?: ApiUsageLogOrderByWithAggregationInput | ApiUsageLogOrderByWithAggregationInput[]
    by: ApiUsageLogScalarFieldEnum[] | ApiUsageLogScalarFieldEnum
    having?: ApiUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiUsageLogCountAggregateInputType | true
    _avg?: ApiUsageLogAvgAggregateInputType
    _sum?: ApiUsageLogSumAggregateInputType
    _min?: ApiUsageLogMinAggregateInputType
    _max?: ApiUsageLogMaxAggregateInputType
  }

  export type ApiUsageLogGroupByOutputType = {
    id: number
    insurerId: number
    endpoint: string
    vehicleId: number | null
    statusCode: number
    responseMs: number
    createdAt: Date
    _count: ApiUsageLogCountAggregateOutputType | null
    _avg: ApiUsageLogAvgAggregateOutputType | null
    _sum: ApiUsageLogSumAggregateOutputType | null
    _min: ApiUsageLogMinAggregateOutputType | null
    _max: ApiUsageLogMaxAggregateOutputType | null
  }

  type GetApiUsageLogGroupByPayload<T extends ApiUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], ApiUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type ApiUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerId?: boolean
    endpoint?: boolean
    vehicleId?: boolean
    statusCode?: boolean
    responseMs?: boolean
    createdAt?: boolean
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsageLog"]>

  export type ApiUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insurerId?: boolean
    endpoint?: boolean
    vehicleId?: boolean
    statusCode?: boolean
    responseMs?: boolean
    createdAt?: boolean
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiUsageLog"]>

  export type ApiUsageLogSelectScalar = {
    id?: boolean
    insurerId?: boolean
    endpoint?: boolean
    vehicleId?: boolean
    statusCode?: boolean
    responseMs?: boolean
    createdAt?: boolean
  }

  export type ApiUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }
  export type ApiUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insurer?: boolean | InsurerDefaultArgs<ExtArgs>
  }

  export type $ApiUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiUsageLog"
    objects: {
      insurer: Prisma.$InsurerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      insurerId: number
      endpoint: string
      vehicleId: number | null
      statusCode: number
      responseMs: number
      createdAt: Date
    }, ExtArgs["result"]["apiUsageLog"]>
    composites: {}
  }

  type ApiUsageLogGetPayload<S extends boolean | null | undefined | ApiUsageLogDefaultArgs> = $Result.GetResult<Prisma.$ApiUsageLogPayload, S>

  type ApiUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiUsageLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiUsageLogCountAggregateInputType | true
    }

  export interface ApiUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiUsageLog'], meta: { name: 'ApiUsageLog' } }
    /**
     * Find zero or one ApiUsageLog that matches the filter.
     * @param {ApiUsageLogFindUniqueArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiUsageLogFindUniqueArgs>(args: SelectSubset<T, ApiUsageLogFindUniqueArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiUsageLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiUsageLogFindUniqueOrThrowArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogFindFirstArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiUsageLogFindFirstArgs>(args?: SelectSubset<T, ApiUsageLogFindFirstArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogFindFirstOrThrowArgs} args - Arguments to find a ApiUsageLog
     * @example
     * // Get one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiUsageLogs
     * const apiUsageLogs = await prisma.apiUsageLog.findMany()
     * 
     * // Get first 10 ApiUsageLogs
     * const apiUsageLogs = await prisma.apiUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiUsageLogWithIdOnly = await prisma.apiUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiUsageLogFindManyArgs>(args?: SelectSubset<T, ApiUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiUsageLog.
     * @param {ApiUsageLogCreateArgs} args - Arguments to create a ApiUsageLog.
     * @example
     * // Create one ApiUsageLog
     * const ApiUsageLog = await prisma.apiUsageLog.create({
     *   data: {
     *     // ... data to create a ApiUsageLog
     *   }
     * })
     * 
     */
    create<T extends ApiUsageLogCreateArgs>(args: SelectSubset<T, ApiUsageLogCreateArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiUsageLogs.
     * @param {ApiUsageLogCreateManyArgs} args - Arguments to create many ApiUsageLogs.
     * @example
     * // Create many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiUsageLogCreateManyArgs>(args?: SelectSubset<T, ApiUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiUsageLogs and returns the data saved in the database.
     * @param {ApiUsageLogCreateManyAndReturnArgs} args - Arguments to create many ApiUsageLogs.
     * @example
     * // Create many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiUsageLogs and only return the `id`
     * const apiUsageLogWithIdOnly = await prisma.apiUsageLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApiUsageLog.
     * @param {ApiUsageLogDeleteArgs} args - Arguments to delete one ApiUsageLog.
     * @example
     * // Delete one ApiUsageLog
     * const ApiUsageLog = await prisma.apiUsageLog.delete({
     *   where: {
     *     // ... filter to delete one ApiUsageLog
     *   }
     * })
     * 
     */
    delete<T extends ApiUsageLogDeleteArgs>(args: SelectSubset<T, ApiUsageLogDeleteArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiUsageLog.
     * @param {ApiUsageLogUpdateArgs} args - Arguments to update one ApiUsageLog.
     * @example
     * // Update one ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiUsageLogUpdateArgs>(args: SelectSubset<T, ApiUsageLogUpdateArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiUsageLogs.
     * @param {ApiUsageLogDeleteManyArgs} args - Arguments to filter ApiUsageLogs to delete.
     * @example
     * // Delete a few ApiUsageLogs
     * const { count } = await prisma.apiUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiUsageLogDeleteManyArgs>(args?: SelectSubset<T, ApiUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiUsageLogs
     * const apiUsageLog = await prisma.apiUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiUsageLogUpdateManyArgs>(args: SelectSubset<T, ApiUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiUsageLog.
     * @param {ApiUsageLogUpsertArgs} args - Arguments to update or create a ApiUsageLog.
     * @example
     * // Update or create a ApiUsageLog
     * const apiUsageLog = await prisma.apiUsageLog.upsert({
     *   create: {
     *     // ... data to create a ApiUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends ApiUsageLogUpsertArgs>(args: SelectSubset<T, ApiUsageLogUpsertArgs<ExtArgs>>): Prisma__ApiUsageLogClient<$Result.GetResult<Prisma.$ApiUsageLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogCountArgs} args - Arguments to filter ApiUsageLogs to count.
     * @example
     * // Count the number of ApiUsageLogs
     * const count = await prisma.apiUsageLog.count({
     *   where: {
     *     // ... the filter for the ApiUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends ApiUsageLogCountArgs>(
      args?: Subset<T, ApiUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiUsageLogAggregateArgs>(args: Subset<T, ApiUsageLogAggregateArgs>): Prisma.PrismaPromise<GetApiUsageLogAggregateType<T>>

    /**
     * Group by ApiUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: ApiUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiUsageLog model
   */
  readonly fields: ApiUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insurer<T extends InsurerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsurerDefaultArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiUsageLog model
   */ 
  interface ApiUsageLogFieldRefs {
    readonly id: FieldRef<"ApiUsageLog", 'Int'>
    readonly insurerId: FieldRef<"ApiUsageLog", 'Int'>
    readonly endpoint: FieldRef<"ApiUsageLog", 'String'>
    readonly vehicleId: FieldRef<"ApiUsageLog", 'Int'>
    readonly statusCode: FieldRef<"ApiUsageLog", 'Int'>
    readonly responseMs: FieldRef<"ApiUsageLog", 'Int'>
    readonly createdAt: FieldRef<"ApiUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiUsageLog findUnique
   */
  export type ApiUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog findUniqueOrThrow
   */
  export type ApiUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog findFirst
   */
  export type ApiUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiUsageLogs.
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiUsageLogs.
     */
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiUsageLog findFirstOrThrow
   */
  export type ApiUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLog to fetch.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiUsageLogs.
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiUsageLogs.
     */
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiUsageLog findMany
   */
  export type ApiUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which ApiUsageLogs to fetch.
     */
    where?: ApiUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiUsageLogs to fetch.
     */
    orderBy?: ApiUsageLogOrderByWithRelationInput | ApiUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiUsageLogs.
     */
    cursor?: ApiUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiUsageLogs.
     */
    skip?: number
    distinct?: ApiUsageLogScalarFieldEnum | ApiUsageLogScalarFieldEnum[]
  }

  /**
   * ApiUsageLog create
   */
  export type ApiUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiUsageLog.
     */
    data: XOR<ApiUsageLogCreateInput, ApiUsageLogUncheckedCreateInput>
  }

  /**
   * ApiUsageLog createMany
   */
  export type ApiUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiUsageLogs.
     */
    data: ApiUsageLogCreateManyInput | ApiUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiUsageLog createManyAndReturn
   */
  export type ApiUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApiUsageLogs.
     */
    data: ApiUsageLogCreateManyInput | ApiUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiUsageLog update
   */
  export type ApiUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiUsageLog.
     */
    data: XOR<ApiUsageLogUpdateInput, ApiUsageLogUncheckedUpdateInput>
    /**
     * Choose, which ApiUsageLog to update.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog updateMany
   */
  export type ApiUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiUsageLogs.
     */
    data: XOR<ApiUsageLogUpdateManyMutationInput, ApiUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which ApiUsageLogs to update
     */
    where?: ApiUsageLogWhereInput
  }

  /**
   * ApiUsageLog upsert
   */
  export type ApiUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiUsageLog to update in case it exists.
     */
    where: ApiUsageLogWhereUniqueInput
    /**
     * In case the ApiUsageLog found by the `where` argument doesn't exist, create a new ApiUsageLog with this data.
     */
    create: XOR<ApiUsageLogCreateInput, ApiUsageLogUncheckedCreateInput>
    /**
     * In case the ApiUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiUsageLogUpdateInput, ApiUsageLogUncheckedUpdateInput>
  }

  /**
   * ApiUsageLog delete
   */
  export type ApiUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
    /**
     * Filter which ApiUsageLog to delete.
     */
    where: ApiUsageLogWhereUniqueInput
  }

  /**
   * ApiUsageLog deleteMany
   */
  export type ApiUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiUsageLogs to delete
     */
    where?: ApiUsageLogWhereInput
  }

  /**
   * ApiUsageLog without action
   */
  export type ApiUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiUsageLog
     */
    select?: ApiUsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    insurerId: number | null
  }

  export type AgentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    insurerId: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    insurerId: number | null
    fullName: string | null
    phone: string | null
    email: string | null
    status: string | null
  }

  export type AgentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    insurerId: number | null
    fullName: string | null
    phone: string | null
    email: string | null
    status: string | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    userId: number
    insurerId: number
    fullName: number
    phone: number
    email: number
    status: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    id?: true
    userId?: true
    insurerId?: true
  }

  export type AgentSumAggregateInputType = {
    id?: true
    userId?: true
    insurerId?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    userId?: true
    insurerId?: true
    fullName?: true
    phone?: true
    email?: true
    status?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    userId?: true
    insurerId?: true
    fullName?: true
    phone?: true
    email?: true
    status?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    userId?: true
    insurerId?: true
    fullName?: true
    phone?: true
    email?: true
    status?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: number
    userId: number | null
    insurerId: number | null
    fullName: string
    phone: string | null
    email: string | null
    status: string
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insurerId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    user?: boolean | Agent$userArgs<ExtArgs>
    insurer?: boolean | Agent$insurerArgs<ExtArgs>
    referrals?: boolean | Agent$referralsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insurerId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    user?: boolean | Agent$userArgs<ExtArgs>
    insurer?: boolean | Agent$insurerArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    userId?: boolean
    insurerId?: boolean
    fullName?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
  }

  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Agent$userArgs<ExtArgs>
    insurer?: boolean | Agent$insurerArgs<ExtArgs>
    referrals?: boolean | Agent$referralsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Agent$userArgs<ExtArgs>
    insurer?: boolean | Agent$insurerArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      insurer: Prisma.$InsurerPayload<ExtArgs> | null
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      insurerId: number | null
      fullName: string
      phone: string | null
      email: string | null
      status: string
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Agent$userArgs<ExtArgs> = {}>(args?: Subset<T, Agent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    insurer<T extends Agent$insurerArgs<ExtArgs> = {}>(args?: Subset<T, Agent$insurerArgs<ExtArgs>>): Prisma__InsurerClient<$Result.GetResult<Prisma.$InsurerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referrals<T extends Agent$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */ 
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'Int'>
    readonly userId: FieldRef<"Agent", 'Int'>
    readonly insurerId: FieldRef<"Agent", 'Int'>
    readonly fullName: FieldRef<"Agent", 'String'>
    readonly phone: FieldRef<"Agent", 'String'>
    readonly email: FieldRef<"Agent", 'String'>
    readonly status: FieldRef<"Agent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
  }

  /**
   * Agent.user
   */
  export type Agent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Agent.insurer
   */
  export type Agent$insurerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurer
     */
    select?: InsurerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurerInclude<ExtArgs> | null
    where?: InsurerWhereInput
  }

  /**
   * Agent.referrals
   */
  export type Agent$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
    vehicleId: number | null
    sessionId: number | null
  }

  export type ReferralSumAggregateOutputType = {
    id: number | null
    agentId: number | null
    vehicleId: number | null
    sessionId: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: number | null
    agentId: number | null
    vehicleId: number | null
    sessionId: number | null
    referredAt: Date | null
    convertedToPolicy: boolean | null
    notes: string | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: number | null
    agentId: number | null
    vehicleId: number | null
    sessionId: number | null
    referredAt: Date | null
    convertedToPolicy: boolean | null
    notes: string | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    agentId: number
    vehicleId: number
    sessionId: number
    referredAt: number
    convertedToPolicy: number
    notes: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    id?: true
    agentId?: true
    vehicleId?: true
    sessionId?: true
  }

  export type ReferralSumAggregateInputType = {
    id?: true
    agentId?: true
    vehicleId?: true
    sessionId?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    agentId?: true
    vehicleId?: true
    sessionId?: true
    referredAt?: true
    convertedToPolicy?: true
    notes?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    agentId?: true
    vehicleId?: true
    sessionId?: true
    referredAt?: true
    convertedToPolicy?: true
    notes?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    agentId?: true
    vehicleId?: true
    sessionId?: true
    referredAt?: true
    convertedToPolicy?: true
    notes?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: number
    agentId: number
    vehicleId: number
    sessionId: number | null
    referredAt: Date
    convertedToPolicy: boolean
    notes: string | null
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    vehicleId?: boolean
    sessionId?: boolean
    referredAt?: boolean
    convertedToPolicy?: boolean
    notes?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    session?: boolean | Referral$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    vehicleId?: boolean
    sessionId?: boolean
    referredAt?: boolean
    convertedToPolicy?: boolean
    notes?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    session?: boolean | Referral$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    agentId?: boolean
    vehicleId?: boolean
    sessionId?: boolean
    referredAt?: boolean
    convertedToPolicy?: boolean
    notes?: boolean
  }

  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    session?: boolean | Referral$sessionArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    session?: boolean | Referral$sessionArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      session: Prisma.$InspectionSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agentId: number
      vehicleId: number
      sessionId: number | null
      referredAt: Date
      convertedToPolicy: boolean
      notes: string | null
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends Referral$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Referral$sessionArgs<ExtArgs>>): Prisma__InspectionSessionClient<$Result.GetResult<Prisma.$InspectionSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'Int'>
    readonly agentId: FieldRef<"Referral", 'Int'>
    readonly vehicleId: FieldRef<"Referral", 'Int'>
    readonly sessionId: FieldRef<"Referral", 'Int'>
    readonly referredAt: FieldRef<"Referral", 'DateTime'>
    readonly convertedToPolicy: FieldRef<"Referral", 'Boolean'>
    readonly notes: FieldRef<"Referral", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral.session
   */
  export type Referral$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InspectionSession
     */
    select?: InspectionSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InspectionSessionInclude<ExtArgs> | null
    where?: InspectionSessionWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    county: 'county',
    cluster: 'cluster',
    createdAt: 'createdAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const InspectorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licenceNo: 'licenceNo',
    licenceExpiry: 'licenceExpiry',
    qualification: 'qualification',
    yearsExperience: 'yearsExperience',
    status: 'status'
  };

  export type InspectorScalarFieldEnum = (typeof InspectorScalarFieldEnum)[keyof typeof InspectorScalarFieldEnum]


  export const OwnerScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    idNo: 'idNo',
    phone: 'phone',
    email: 'email',
    address: 'address'
  };

  export type OwnerScalarFieldEnum = (typeof OwnerScalarFieldEnum)[keyof typeof OwnerScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    ownerId: 'ownerId',
    registrationNo: 'registrationNo',
    vin: 'vin',
    engineNo: 'engineNo',
    make: 'make',
    model: 'model',
    yearOfMfg: 'yearOfMfg',
    category: 'category',
    tareWeightKg: 'tareWeightKg',
    engineCc: 'engineCc',
    evBatteryKwh: 'evBatteryKwh',
    telematicsImei: 'telematicsImei',
    speedGovernorSerial: 'speedGovernorSerial',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    vehicleId: 'vehicleId',
    bookingRef: 'bookingRef',
    bookingFeePaid: 'bookingFeePaid',
    bookingFeeReceiptNo: 'bookingFeeReceiptNo',
    bookedForDate: 'bookedForDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const InspectionItemScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    group: 'group',
    weightPct: 'weightPct',
    requiredForCategories: 'requiredForCategories'
  };

  export type InspectionItemScalarFieldEnum = (typeof InspectionItemScalarFieldEnum)[keyof typeof InspectionItemScalarFieldEnum]


  export const InspectionSessionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    vehicleId: 'vehicleId',
    bookingId: 'bookingId',
    inspectorId: 'inspectorId',
    inspectedAt: 'inspectedAt',
    inspectionType: 'inspectionType',
    odometerKm: 'odometerKm',
    notes: 'notes',
    status: 'status',
    passThreshold: 'passThreshold',
    totalScore: 'totalScore',
    defectSeverity: 'defectSeverity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InspectionSessionScalarFieldEnum = (typeof InspectionSessionScalarFieldEnum)[keyof typeof InspectionSessionScalarFieldEnum]


  export const InspectionResultScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    itemId: 'itemId',
    measuredValueNum: 'measuredValueNum',
    measuredValueText: 'measuredValueText',
    pass: 'pass',
    severity: 'severity',
    remarks: 'remarks',
    createdAt: 'createdAt'
  };

  export type InspectionResultScalarFieldEnum = (typeof InspectionResultScalarFieldEnum)[keyof typeof InspectionResultScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    certificateNo: 'certificateNo',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    stickerNo: 'stickerNo',
    reportPdfUrl: 'reportPdfUrl',
    verificationHash: 'verificationHash'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const ReinspectionLinkScalarFieldEnum: {
    id: 'id',
    originalSessionId: 'originalSessionId',
    newSessionId: 'newSessionId',
    freeWithin14Days: 'freeWithin14Days',
    reason: 'reason'
  };

  export type ReinspectionLinkScalarFieldEnum = (typeof ReinspectionLinkScalarFieldEnum)[keyof typeof ReinspectionLinkScalarFieldEnum]


  export const MediaRefScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    type: 'type',
    storageUrl: 'storageUrl',
    sha256: 'sha256',
    capturedAt: 'capturedAt',
    cctvCameraId: 'cctvCameraId',
    cctvStartTs: 'cctvStartTs',
    cctvEndTs: 'cctvEndTs'
  };

  export type MediaRefScalarFieldEnum = (typeof MediaRefScalarFieldEnum)[keyof typeof MediaRefScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    actorUserId: 'actorUserId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    ip: 'ip',
    userAgent: 'userAgent',
    beforeJson: 'beforeJson',
    afterJson: 'afterJson',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const InsurerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    status: 'status'
  };

  export type InsurerScalarFieldEnum = (typeof InsurerScalarFieldEnum)[keyof typeof InsurerScalarFieldEnum]


  export const InsurerUserScalarFieldEnum: {
    id: 'id',
    insurerId: 'insurerId',
    userId: 'userId'
  };

  export type InsurerUserScalarFieldEnum = (typeof InsurerUserScalarFieldEnum)[keyof typeof InsurerUserScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    insurerId: 'insurerId',
    name: 'name',
    keyHash: 'keyHash',
    scopes: 'scopes',
    lastUsedAt: 'lastUsedAt',
    revokedAt: 'revokedAt',
    createdAt: 'createdAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const ApiUsageLogScalarFieldEnum: {
    id: 'id',
    insurerId: 'insurerId',
    endpoint: 'endpoint',
    vehicleId: 'vehicleId',
    statusCode: 'statusCode',
    responseMs: 'responseMs',
    createdAt: 'createdAt'
  };

  export type ApiUsageLogScalarFieldEnum = (typeof ApiUsageLogScalarFieldEnum)[keyof typeof ApiUsageLogScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    insurerId: 'insurerId',
    fullName: 'fullName',
    phone: 'phone',
    email: 'email',
    status: 'status'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    vehicleId: 'vehicleId',
    sessionId: 'sessionId',
    referredAt: 'referredAt',
    convertedToPolicy: 'convertedToPolicy',
    notes: 'notes'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'InspectorStatus'
   */
  export type EnumInspectorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectorStatus'>
    


  /**
   * Reference to a field of type 'InspectorStatus[]'
   */
  export type ListEnumInspectorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectorStatus[]'>
    


  /**
   * Reference to a field of type 'VehicleCategory'
   */
  export type EnumVehicleCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleCategory'>
    


  /**
   * Reference to a field of type 'VehicleCategory[]'
   */
  export type ListEnumVehicleCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'ItemGroup'
   */
  export type EnumItemGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemGroup'>
    


  /**
   * Reference to a field of type 'ItemGroup[]'
   */
  export type ListEnumItemGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemGroup[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'InspectionType'
   */
  export type EnumInspectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectionType'>
    


  /**
   * Reference to a field of type 'InspectionType[]'
   */
  export type ListEnumInspectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectionType[]'>
    


  /**
   * Reference to a field of type 'InspectionStatus'
   */
  export type EnumInspectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectionStatus'>
    


  /**
   * Reference to a field of type 'InspectionStatus[]'
   */
  export type ListEnumInspectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InspectionStatus[]'>
    


  /**
   * Reference to a field of type 'DefectSeverity'
   */
  export type EnumDefectSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectSeverity'>
    


  /**
   * Reference to a field of type 'DefectSeverity[]'
   */
  export type ListEnumDefectSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DefectSeverity[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ResultSeverity'
   */
  export type EnumResultSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultSeverity'>
    


  /**
   * Reference to a field of type 'ResultSeverity[]'
   */
  export type ListEnumResultSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultSeverity[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'InsurerStatus'
   */
  export type EnumInsurerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsurerStatus'>
    


  /**
   * Reference to a field of type 'InsurerStatus[]'
   */
  export type ListEnumInsurerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsurerStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: IntFilter<"Tenant"> | number
    name?: StringFilter<"Tenant"> | string
    county?: StringNullableFilter<"Tenant"> | string | null
    cluster?: IntNullableFilter<"Tenant"> | number | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    vehicles?: VehicleListRelationFilter
    bookings?: BookingListRelationFilter
    sessions?: InspectionSessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    county?: SortOrderInput | SortOrder
    cluster?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    vehicles?: VehicleOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    sessions?: InspectionSessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    county?: StringNullableFilter<"Tenant"> | string | null
    cluster?: IntNullableFilter<"Tenant"> | number | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    vehicles?: VehicleListRelationFilter
    bookings?: BookingListRelationFilter
    sessions?: InspectionSessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    county?: SortOrderInput | SortOrder
    cluster?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tenant"> | number
    name?: StringWithAggregatesFilter<"Tenant"> | string
    county?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    cluster?: IntNullableWithAggregatesFilter<"Tenant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    tenantId?: IntNullableFilter<"User"> | number | null
    fullName?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    inspector?: XOR<InspectorNullableRelationFilter, InspectorWhereInput> | null
    insurerUser?: XOR<InsurerUserNullableRelationFilter, InsurerUserWhereInput> | null
    agent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    inspector?: InspectorOrderByWithRelationInput
    insurerUser?: InsurerUserOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: IntNullableFilter<"User"> | number | null
    fullName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    inspector?: XOR<InspectorNullableRelationFilter, InspectorWhereInput> | null
    insurerUser?: XOR<InsurerUserNullableRelationFilter, InsurerUserWhereInput> | null
    agent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    tenantId?: IntNullableWithAggregatesFilter<"User"> | number | null
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type InspectorWhereInput = {
    AND?: InspectorWhereInput | InspectorWhereInput[]
    OR?: InspectorWhereInput[]
    NOT?: InspectorWhereInput | InspectorWhereInput[]
    id?: IntFilter<"Inspector"> | number
    userId?: IntFilter<"Inspector"> | number
    licenceNo?: StringFilter<"Inspector"> | string
    licenceExpiry?: DateTimeFilter<"Inspector"> | Date | string
    qualification?: StringNullableFilter<"Inspector"> | string | null
    yearsExperience?: IntNullableFilter<"Inspector"> | number | null
    status?: EnumInspectorStatusFilter<"Inspector"> | $Enums.InspectorStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
    sessions?: InspectionSessionListRelationFilter
  }

  export type InspectorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenceNo?: SortOrder
    licenceExpiry?: SortOrder
    qualification?: SortOrderInput | SortOrder
    yearsExperience?: SortOrderInput | SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationInput
    sessions?: InspectionSessionOrderByRelationAggregateInput
  }

  export type InspectorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    licenceNo?: string
    AND?: InspectorWhereInput | InspectorWhereInput[]
    OR?: InspectorWhereInput[]
    NOT?: InspectorWhereInput | InspectorWhereInput[]
    licenceExpiry?: DateTimeFilter<"Inspector"> | Date | string
    qualification?: StringNullableFilter<"Inspector"> | string | null
    yearsExperience?: IntNullableFilter<"Inspector"> | number | null
    status?: EnumInspectorStatusFilter<"Inspector"> | $Enums.InspectorStatus
    user?: XOR<UserRelationFilter, UserWhereInput>
    sessions?: InspectionSessionListRelationFilter
  }, "id" | "userId" | "licenceNo">

  export type InspectorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenceNo?: SortOrder
    licenceExpiry?: SortOrder
    qualification?: SortOrderInput | SortOrder
    yearsExperience?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: InspectorCountOrderByAggregateInput
    _avg?: InspectorAvgOrderByAggregateInput
    _max?: InspectorMaxOrderByAggregateInput
    _min?: InspectorMinOrderByAggregateInput
    _sum?: InspectorSumOrderByAggregateInput
  }

  export type InspectorScalarWhereWithAggregatesInput = {
    AND?: InspectorScalarWhereWithAggregatesInput | InspectorScalarWhereWithAggregatesInput[]
    OR?: InspectorScalarWhereWithAggregatesInput[]
    NOT?: InspectorScalarWhereWithAggregatesInput | InspectorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inspector"> | number
    userId?: IntWithAggregatesFilter<"Inspector"> | number
    licenceNo?: StringWithAggregatesFilter<"Inspector"> | string
    licenceExpiry?: DateTimeWithAggregatesFilter<"Inspector"> | Date | string
    qualification?: StringNullableWithAggregatesFilter<"Inspector"> | string | null
    yearsExperience?: IntNullableWithAggregatesFilter<"Inspector"> | number | null
    status?: EnumInspectorStatusWithAggregatesFilter<"Inspector"> | $Enums.InspectorStatus
  }

  export type OwnerWhereInput = {
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    id?: IntFilter<"Owner"> | number
    fullName?: StringFilter<"Owner"> | string
    idNo?: StringNullableFilter<"Owner"> | string | null
    phone?: StringNullableFilter<"Owner"> | string | null
    email?: StringNullableFilter<"Owner"> | string | null
    address?: StringNullableFilter<"Owner"> | string | null
    vehicles?: VehicleListRelationFilter
  }

  export type OwnerOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    idNo?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    vehicles?: VehicleOrderByRelationAggregateInput
  }

  export type OwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    fullName?: StringFilter<"Owner"> | string
    idNo?: StringNullableFilter<"Owner"> | string | null
    phone?: StringNullableFilter<"Owner"> | string | null
    email?: StringNullableFilter<"Owner"> | string | null
    address?: StringNullableFilter<"Owner"> | string | null
    vehicles?: VehicleListRelationFilter
  }, "id">

  export type OwnerOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    idNo?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: OwnerCountOrderByAggregateInput
    _avg?: OwnerAvgOrderByAggregateInput
    _max?: OwnerMaxOrderByAggregateInput
    _min?: OwnerMinOrderByAggregateInput
    _sum?: OwnerSumOrderByAggregateInput
  }

  export type OwnerScalarWhereWithAggregatesInput = {
    AND?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    OR?: OwnerScalarWhereWithAggregatesInput[]
    NOT?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Owner"> | number
    fullName?: StringWithAggregatesFilter<"Owner"> | string
    idNo?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    email?: StringNullableWithAggregatesFilter<"Owner"> | string | null
    address?: StringNullableWithAggregatesFilter<"Owner"> | string | null
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    tenantId?: IntFilter<"Vehicle"> | number
    ownerId?: IntNullableFilter<"Vehicle"> | number | null
    registrationNo?: StringFilter<"Vehicle"> | string
    vin?: StringNullableFilter<"Vehicle"> | string | null
    engineNo?: StringNullableFilter<"Vehicle"> | string | null
    make?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    yearOfMfg?: IntNullableFilter<"Vehicle"> | number | null
    category?: EnumVehicleCategoryFilter<"Vehicle"> | $Enums.VehicleCategory
    tareWeightKg?: IntNullableFilter<"Vehicle"> | number | null
    engineCc?: IntNullableFilter<"Vehicle"> | number | null
    evBatteryKwh?: IntNullableFilter<"Vehicle"> | number | null
    telematicsImei?: StringNullableFilter<"Vehicle"> | string | null
    speedGovernorSerial?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    owner?: XOR<OwnerNullableRelationFilter, OwnerWhereInput> | null
    bookings?: BookingListRelationFilter
    sessions?: InspectionSessionListRelationFilter
    referrals?: ReferralListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    registrationNo?: SortOrder
    vin?: SortOrderInput | SortOrder
    engineNo?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    yearOfMfg?: SortOrderInput | SortOrder
    category?: SortOrder
    tareWeightKg?: SortOrderInput | SortOrder
    engineCc?: SortOrderInput | SortOrder
    evBatteryKwh?: SortOrderInput | SortOrder
    telematicsImei?: SortOrderInput | SortOrder
    speedGovernorSerial?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    owner?: OwnerOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    sessions?: InspectionSessionOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    registrationNo?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    tenantId?: IntFilter<"Vehicle"> | number
    ownerId?: IntNullableFilter<"Vehicle"> | number | null
    vin?: StringNullableFilter<"Vehicle"> | string | null
    engineNo?: StringNullableFilter<"Vehicle"> | string | null
    make?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    yearOfMfg?: IntNullableFilter<"Vehicle"> | number | null
    category?: EnumVehicleCategoryFilter<"Vehicle"> | $Enums.VehicleCategory
    tareWeightKg?: IntNullableFilter<"Vehicle"> | number | null
    engineCc?: IntNullableFilter<"Vehicle"> | number | null
    evBatteryKwh?: IntNullableFilter<"Vehicle"> | number | null
    telematicsImei?: StringNullableFilter<"Vehicle"> | string | null
    speedGovernorSerial?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    owner?: XOR<OwnerNullableRelationFilter, OwnerWhereInput> | null
    bookings?: BookingListRelationFilter
    sessions?: InspectionSessionListRelationFilter
    referrals?: ReferralListRelationFilter
  }, "id" | "registrationNo">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    registrationNo?: SortOrder
    vin?: SortOrderInput | SortOrder
    engineNo?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    yearOfMfg?: SortOrderInput | SortOrder
    category?: SortOrder
    tareWeightKg?: SortOrderInput | SortOrder
    engineCc?: SortOrderInput | SortOrder
    evBatteryKwh?: SortOrderInput | SortOrder
    telematicsImei?: SortOrderInput | SortOrder
    speedGovernorSerial?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vehicle"> | number
    tenantId?: IntWithAggregatesFilter<"Vehicle"> | number
    ownerId?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    registrationNo?: StringWithAggregatesFilter<"Vehicle"> | string
    vin?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    engineNo?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    make?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    model?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    yearOfMfg?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    category?: EnumVehicleCategoryWithAggregatesFilter<"Vehicle"> | $Enums.VehicleCategory
    tareWeightKg?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    engineCc?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    evBatteryKwh?: IntNullableWithAggregatesFilter<"Vehicle"> | number | null
    telematicsImei?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    speedGovernorSerial?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    tenantId?: IntFilter<"Booking"> | number
    vehicleId?: IntFilter<"Booking"> | number
    bookingRef?: StringNullableFilter<"Booking"> | string | null
    bookingFeePaid?: BoolFilter<"Booking"> | boolean
    bookingFeeReceiptNo?: StringNullableFilter<"Booking"> | string | null
    bookedForDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    sessions?: InspectionSessionListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingRef?: SortOrderInput | SortOrder
    bookingFeePaid?: SortOrder
    bookingFeeReceiptNo?: SortOrderInput | SortOrder
    bookedForDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    sessions?: InspectionSessionOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    tenantId?: IntFilter<"Booking"> | number
    vehicleId?: IntFilter<"Booking"> | number
    bookingRef?: StringNullableFilter<"Booking"> | string | null
    bookingFeePaid?: BoolFilter<"Booking"> | boolean
    bookingFeeReceiptNo?: StringNullableFilter<"Booking"> | string | null
    bookedForDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    sessions?: InspectionSessionListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingRef?: SortOrderInput | SortOrder
    bookingFeePaid?: SortOrder
    bookingFeeReceiptNo?: SortOrderInput | SortOrder
    bookedForDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    tenantId?: IntWithAggregatesFilter<"Booking"> | number
    vehicleId?: IntWithAggregatesFilter<"Booking"> | number
    bookingRef?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    bookingFeePaid?: BoolWithAggregatesFilter<"Booking"> | boolean
    bookingFeeReceiptNo?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    bookedForDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type InspectionItemWhereInput = {
    AND?: InspectionItemWhereInput | InspectionItemWhereInput[]
    OR?: InspectionItemWhereInput[]
    NOT?: InspectionItemWhereInput | InspectionItemWhereInput[]
    id?: IntFilter<"InspectionItem"> | number
    code?: StringFilter<"InspectionItem"> | string
    name?: StringFilter<"InspectionItem"> | string
    group?: EnumItemGroupFilter<"InspectionItem"> | $Enums.ItemGroup
    weightPct?: IntFilter<"InspectionItem"> | number
    requiredForCategories?: JsonNullableFilter<"InspectionItem">
    results?: InspectionResultListRelationFilter
  }

  export type InspectionItemOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    group?: SortOrder
    weightPct?: SortOrder
    requiredForCategories?: SortOrderInput | SortOrder
    results?: InspectionResultOrderByRelationAggregateInput
  }

  export type InspectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: InspectionItemWhereInput | InspectionItemWhereInput[]
    OR?: InspectionItemWhereInput[]
    NOT?: InspectionItemWhereInput | InspectionItemWhereInput[]
    name?: StringFilter<"InspectionItem"> | string
    group?: EnumItemGroupFilter<"InspectionItem"> | $Enums.ItemGroup
    weightPct?: IntFilter<"InspectionItem"> | number
    requiredForCategories?: JsonNullableFilter<"InspectionItem">
    results?: InspectionResultListRelationFilter
  }, "id" | "code">

  export type InspectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    group?: SortOrder
    weightPct?: SortOrder
    requiredForCategories?: SortOrderInput | SortOrder
    _count?: InspectionItemCountOrderByAggregateInput
    _avg?: InspectionItemAvgOrderByAggregateInput
    _max?: InspectionItemMaxOrderByAggregateInput
    _min?: InspectionItemMinOrderByAggregateInput
    _sum?: InspectionItemSumOrderByAggregateInput
  }

  export type InspectionItemScalarWhereWithAggregatesInput = {
    AND?: InspectionItemScalarWhereWithAggregatesInput | InspectionItemScalarWhereWithAggregatesInput[]
    OR?: InspectionItemScalarWhereWithAggregatesInput[]
    NOT?: InspectionItemScalarWhereWithAggregatesInput | InspectionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InspectionItem"> | number
    code?: StringWithAggregatesFilter<"InspectionItem"> | string
    name?: StringWithAggregatesFilter<"InspectionItem"> | string
    group?: EnumItemGroupWithAggregatesFilter<"InspectionItem"> | $Enums.ItemGroup
    weightPct?: IntWithAggregatesFilter<"InspectionItem"> | number
    requiredForCategories?: JsonNullableWithAggregatesFilter<"InspectionItem">
  }

  export type InspectionSessionWhereInput = {
    AND?: InspectionSessionWhereInput | InspectionSessionWhereInput[]
    OR?: InspectionSessionWhereInput[]
    NOT?: InspectionSessionWhereInput | InspectionSessionWhereInput[]
    id?: IntFilter<"InspectionSession"> | number
    tenantId?: IntFilter<"InspectionSession"> | number
    vehicleId?: IntFilter<"InspectionSession"> | number
    bookingId?: IntNullableFilter<"InspectionSession"> | number | null
    inspectorId?: IntNullableFilter<"InspectionSession"> | number | null
    inspectedAt?: DateTimeNullableFilter<"InspectionSession"> | Date | string | null
    inspectionType?: EnumInspectionTypeFilter<"InspectionSession"> | $Enums.InspectionType
    odometerKm?: IntNullableFilter<"InspectionSession"> | number | null
    notes?: StringNullableFilter<"InspectionSession"> | string | null
    status?: EnumInspectionStatusFilter<"InspectionSession"> | $Enums.InspectionStatus
    passThreshold?: IntFilter<"InspectionSession"> | number
    totalScore?: IntFilter<"InspectionSession"> | number
    defectSeverity?: EnumDefectSeverityFilter<"InspectionSession"> | $Enums.DefectSeverity
    createdAt?: DateTimeFilter<"InspectionSession"> | Date | string
    updatedAt?: DateTimeFilter<"InspectionSession"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    inspector?: XOR<InspectorNullableRelationFilter, InspectorWhereInput> | null
    certificate?: XOR<CertificateNullableRelationFilter, CertificateWhereInput> | null
    results?: InspectionResultListRelationFilter
    mediaRefs?: MediaRefListRelationFilter
    originalReinspections?: ReinspectionLinkListRelationFilter
    newReinspection?: XOR<ReinspectionLinkNullableRelationFilter, ReinspectionLinkWhereInput> | null
    referrals?: ReferralListRelationFilter
  }

  export type InspectionSessionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    inspectorId?: SortOrderInput | SortOrder
    inspectedAt?: SortOrderInput | SortOrder
    inspectionType?: SortOrder
    odometerKm?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
    defectSeverity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    inspector?: InspectorOrderByWithRelationInput
    certificate?: CertificateOrderByWithRelationInput
    results?: InspectionResultOrderByRelationAggregateInput
    mediaRefs?: MediaRefOrderByRelationAggregateInput
    originalReinspections?: ReinspectionLinkOrderByRelationAggregateInput
    newReinspection?: ReinspectionLinkOrderByWithRelationInput
    referrals?: ReferralOrderByRelationAggregateInput
  }

  export type InspectionSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InspectionSessionWhereInput | InspectionSessionWhereInput[]
    OR?: InspectionSessionWhereInput[]
    NOT?: InspectionSessionWhereInput | InspectionSessionWhereInput[]
    tenantId?: IntFilter<"InspectionSession"> | number
    vehicleId?: IntFilter<"InspectionSession"> | number
    bookingId?: IntNullableFilter<"InspectionSession"> | number | null
    inspectorId?: IntNullableFilter<"InspectionSession"> | number | null
    inspectedAt?: DateTimeNullableFilter<"InspectionSession"> | Date | string | null
    inspectionType?: EnumInspectionTypeFilter<"InspectionSession"> | $Enums.InspectionType
    odometerKm?: IntNullableFilter<"InspectionSession"> | number | null
    notes?: StringNullableFilter<"InspectionSession"> | string | null
    status?: EnumInspectionStatusFilter<"InspectionSession"> | $Enums.InspectionStatus
    passThreshold?: IntFilter<"InspectionSession"> | number
    totalScore?: IntFilter<"InspectionSession"> | number
    defectSeverity?: EnumDefectSeverityFilter<"InspectionSession"> | $Enums.DefectSeverity
    createdAt?: DateTimeFilter<"InspectionSession"> | Date | string
    updatedAt?: DateTimeFilter<"InspectionSession"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    inspector?: XOR<InspectorNullableRelationFilter, InspectorWhereInput> | null
    certificate?: XOR<CertificateNullableRelationFilter, CertificateWhereInput> | null
    results?: InspectionResultListRelationFilter
    mediaRefs?: MediaRefListRelationFilter
    originalReinspections?: ReinspectionLinkListRelationFilter
    newReinspection?: XOR<ReinspectionLinkNullableRelationFilter, ReinspectionLinkWhereInput> | null
    referrals?: ReferralListRelationFilter
  }, "id">

  export type InspectionSessionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    inspectorId?: SortOrderInput | SortOrder
    inspectedAt?: SortOrderInput | SortOrder
    inspectionType?: SortOrder
    odometerKm?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
    defectSeverity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InspectionSessionCountOrderByAggregateInput
    _avg?: InspectionSessionAvgOrderByAggregateInput
    _max?: InspectionSessionMaxOrderByAggregateInput
    _min?: InspectionSessionMinOrderByAggregateInput
    _sum?: InspectionSessionSumOrderByAggregateInput
  }

  export type InspectionSessionScalarWhereWithAggregatesInput = {
    AND?: InspectionSessionScalarWhereWithAggregatesInput | InspectionSessionScalarWhereWithAggregatesInput[]
    OR?: InspectionSessionScalarWhereWithAggregatesInput[]
    NOT?: InspectionSessionScalarWhereWithAggregatesInput | InspectionSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InspectionSession"> | number
    tenantId?: IntWithAggregatesFilter<"InspectionSession"> | number
    vehicleId?: IntWithAggregatesFilter<"InspectionSession"> | number
    bookingId?: IntNullableWithAggregatesFilter<"InspectionSession"> | number | null
    inspectorId?: IntNullableWithAggregatesFilter<"InspectionSession"> | number | null
    inspectedAt?: DateTimeNullableWithAggregatesFilter<"InspectionSession"> | Date | string | null
    inspectionType?: EnumInspectionTypeWithAggregatesFilter<"InspectionSession"> | $Enums.InspectionType
    odometerKm?: IntNullableWithAggregatesFilter<"InspectionSession"> | number | null
    notes?: StringNullableWithAggregatesFilter<"InspectionSession"> | string | null
    status?: EnumInspectionStatusWithAggregatesFilter<"InspectionSession"> | $Enums.InspectionStatus
    passThreshold?: IntWithAggregatesFilter<"InspectionSession"> | number
    totalScore?: IntWithAggregatesFilter<"InspectionSession"> | number
    defectSeverity?: EnumDefectSeverityWithAggregatesFilter<"InspectionSession"> | $Enums.DefectSeverity
    createdAt?: DateTimeWithAggregatesFilter<"InspectionSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InspectionSession"> | Date | string
  }

  export type InspectionResultWhereInput = {
    AND?: InspectionResultWhereInput | InspectionResultWhereInput[]
    OR?: InspectionResultWhereInput[]
    NOT?: InspectionResultWhereInput | InspectionResultWhereInput[]
    id?: IntFilter<"InspectionResult"> | number
    sessionId?: IntFilter<"InspectionResult"> | number
    itemId?: IntFilter<"InspectionResult"> | number
    measuredValueNum?: DecimalNullableFilter<"InspectionResult"> | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: StringNullableFilter<"InspectionResult"> | string | null
    pass?: BoolFilter<"InspectionResult"> | boolean
    severity?: EnumResultSeverityFilter<"InspectionResult"> | $Enums.ResultSeverity
    remarks?: StringNullableFilter<"InspectionResult"> | string | null
    createdAt?: DateTimeFilter<"InspectionResult"> | Date | string
    session?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
    item?: XOR<InspectionItemRelationFilter, InspectionItemWhereInput>
  }

  export type InspectionResultOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrderInput | SortOrder
    measuredValueText?: SortOrderInput | SortOrder
    pass?: SortOrder
    severity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: InspectionSessionOrderByWithRelationInput
    item?: InspectionItemOrderByWithRelationInput
  }

  export type InspectionResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId_itemId?: InspectionResultSessionIdItemIdCompoundUniqueInput
    AND?: InspectionResultWhereInput | InspectionResultWhereInput[]
    OR?: InspectionResultWhereInput[]
    NOT?: InspectionResultWhereInput | InspectionResultWhereInput[]
    sessionId?: IntFilter<"InspectionResult"> | number
    itemId?: IntFilter<"InspectionResult"> | number
    measuredValueNum?: DecimalNullableFilter<"InspectionResult"> | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: StringNullableFilter<"InspectionResult"> | string | null
    pass?: BoolFilter<"InspectionResult"> | boolean
    severity?: EnumResultSeverityFilter<"InspectionResult"> | $Enums.ResultSeverity
    remarks?: StringNullableFilter<"InspectionResult"> | string | null
    createdAt?: DateTimeFilter<"InspectionResult"> | Date | string
    session?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
    item?: XOR<InspectionItemRelationFilter, InspectionItemWhereInput>
  }, "id" | "sessionId_itemId">

  export type InspectionResultOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrderInput | SortOrder
    measuredValueText?: SortOrderInput | SortOrder
    pass?: SortOrder
    severity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InspectionResultCountOrderByAggregateInput
    _avg?: InspectionResultAvgOrderByAggregateInput
    _max?: InspectionResultMaxOrderByAggregateInput
    _min?: InspectionResultMinOrderByAggregateInput
    _sum?: InspectionResultSumOrderByAggregateInput
  }

  export type InspectionResultScalarWhereWithAggregatesInput = {
    AND?: InspectionResultScalarWhereWithAggregatesInput | InspectionResultScalarWhereWithAggregatesInput[]
    OR?: InspectionResultScalarWhereWithAggregatesInput[]
    NOT?: InspectionResultScalarWhereWithAggregatesInput | InspectionResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InspectionResult"> | number
    sessionId?: IntWithAggregatesFilter<"InspectionResult"> | number
    itemId?: IntWithAggregatesFilter<"InspectionResult"> | number
    measuredValueNum?: DecimalNullableWithAggregatesFilter<"InspectionResult"> | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: StringNullableWithAggregatesFilter<"InspectionResult"> | string | null
    pass?: BoolWithAggregatesFilter<"InspectionResult"> | boolean
    severity?: EnumResultSeverityWithAggregatesFilter<"InspectionResult"> | $Enums.ResultSeverity
    remarks?: StringNullableWithAggregatesFilter<"InspectionResult"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InspectionResult"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: IntFilter<"Certificate"> | number
    sessionId?: IntFilter<"Certificate"> | number
    certificateNo?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeFilter<"Certificate"> | Date | string
    stickerNo?: StringNullableFilter<"Certificate"> | string | null
    reportPdfUrl?: StringNullableFilter<"Certificate"> | string | null
    verificationHash?: StringFilter<"Certificate"> | string
    session?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    certificateNo?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    stickerNo?: SortOrderInput | SortOrder
    reportPdfUrl?: SortOrderInput | SortOrder
    verificationHash?: SortOrder
    session?: InspectionSessionOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId?: number
    certificateNo?: string
    stickerNo?: string
    verificationHash?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeFilter<"Certificate"> | Date | string
    reportPdfUrl?: StringNullableFilter<"Certificate"> | string | null
    session?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
  }, "id" | "sessionId" | "certificateNo" | "stickerNo" | "verificationHash">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    certificateNo?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    stickerNo?: SortOrderInput | SortOrder
    reportPdfUrl?: SortOrderInput | SortOrder
    verificationHash?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Certificate"> | number
    sessionId?: IntWithAggregatesFilter<"Certificate"> | number
    certificateNo?: StringWithAggregatesFilter<"Certificate"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    stickerNo?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    reportPdfUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    verificationHash?: StringWithAggregatesFilter<"Certificate"> | string
  }

  export type ReinspectionLinkWhereInput = {
    AND?: ReinspectionLinkWhereInput | ReinspectionLinkWhereInput[]
    OR?: ReinspectionLinkWhereInput[]
    NOT?: ReinspectionLinkWhereInput | ReinspectionLinkWhereInput[]
    id?: IntFilter<"ReinspectionLink"> | number
    originalSessionId?: IntFilter<"ReinspectionLink"> | number
    newSessionId?: IntFilter<"ReinspectionLink"> | number
    freeWithin14Days?: BoolFilter<"ReinspectionLink"> | boolean
    reason?: StringNullableFilter<"ReinspectionLink"> | string | null
    originalSession?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
    newSession?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
  }

  export type ReinspectionLinkOrderByWithRelationInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
    freeWithin14Days?: SortOrder
    reason?: SortOrderInput | SortOrder
    originalSession?: InspectionSessionOrderByWithRelationInput
    newSession?: InspectionSessionOrderByWithRelationInput
  }

  export type ReinspectionLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    newSessionId?: number
    AND?: ReinspectionLinkWhereInput | ReinspectionLinkWhereInput[]
    OR?: ReinspectionLinkWhereInput[]
    NOT?: ReinspectionLinkWhereInput | ReinspectionLinkWhereInput[]
    originalSessionId?: IntFilter<"ReinspectionLink"> | number
    freeWithin14Days?: BoolFilter<"ReinspectionLink"> | boolean
    reason?: StringNullableFilter<"ReinspectionLink"> | string | null
    originalSession?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
    newSession?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
  }, "id" | "newSessionId">

  export type ReinspectionLinkOrderByWithAggregationInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
    freeWithin14Days?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: ReinspectionLinkCountOrderByAggregateInput
    _avg?: ReinspectionLinkAvgOrderByAggregateInput
    _max?: ReinspectionLinkMaxOrderByAggregateInput
    _min?: ReinspectionLinkMinOrderByAggregateInput
    _sum?: ReinspectionLinkSumOrderByAggregateInput
  }

  export type ReinspectionLinkScalarWhereWithAggregatesInput = {
    AND?: ReinspectionLinkScalarWhereWithAggregatesInput | ReinspectionLinkScalarWhereWithAggregatesInput[]
    OR?: ReinspectionLinkScalarWhereWithAggregatesInput[]
    NOT?: ReinspectionLinkScalarWhereWithAggregatesInput | ReinspectionLinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReinspectionLink"> | number
    originalSessionId?: IntWithAggregatesFilter<"ReinspectionLink"> | number
    newSessionId?: IntWithAggregatesFilter<"ReinspectionLink"> | number
    freeWithin14Days?: BoolWithAggregatesFilter<"ReinspectionLink"> | boolean
    reason?: StringNullableWithAggregatesFilter<"ReinspectionLink"> | string | null
  }

  export type MediaRefWhereInput = {
    AND?: MediaRefWhereInput | MediaRefWhereInput[]
    OR?: MediaRefWhereInput[]
    NOT?: MediaRefWhereInput | MediaRefWhereInput[]
    id?: IntFilter<"MediaRef"> | number
    sessionId?: IntFilter<"MediaRef"> | number
    type?: EnumMediaTypeFilter<"MediaRef"> | $Enums.MediaType
    storageUrl?: StringFilter<"MediaRef"> | string
    sha256?: StringNullableFilter<"MediaRef"> | string | null
    capturedAt?: DateTimeFilter<"MediaRef"> | Date | string
    cctvCameraId?: StringNullableFilter<"MediaRef"> | string | null
    cctvStartTs?: DateTimeNullableFilter<"MediaRef"> | Date | string | null
    cctvEndTs?: DateTimeNullableFilter<"MediaRef"> | Date | string | null
    session?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
  }

  export type MediaRefOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    storageUrl?: SortOrder
    sha256?: SortOrderInput | SortOrder
    capturedAt?: SortOrder
    cctvCameraId?: SortOrderInput | SortOrder
    cctvStartTs?: SortOrderInput | SortOrder
    cctvEndTs?: SortOrderInput | SortOrder
    session?: InspectionSessionOrderByWithRelationInput
  }

  export type MediaRefWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MediaRefWhereInput | MediaRefWhereInput[]
    OR?: MediaRefWhereInput[]
    NOT?: MediaRefWhereInput | MediaRefWhereInput[]
    sessionId?: IntFilter<"MediaRef"> | number
    type?: EnumMediaTypeFilter<"MediaRef"> | $Enums.MediaType
    storageUrl?: StringFilter<"MediaRef"> | string
    sha256?: StringNullableFilter<"MediaRef"> | string | null
    capturedAt?: DateTimeFilter<"MediaRef"> | Date | string
    cctvCameraId?: StringNullableFilter<"MediaRef"> | string | null
    cctvStartTs?: DateTimeNullableFilter<"MediaRef"> | Date | string | null
    cctvEndTs?: DateTimeNullableFilter<"MediaRef"> | Date | string | null
    session?: XOR<InspectionSessionRelationFilter, InspectionSessionWhereInput>
  }, "id">

  export type MediaRefOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    storageUrl?: SortOrder
    sha256?: SortOrderInput | SortOrder
    capturedAt?: SortOrder
    cctvCameraId?: SortOrderInput | SortOrder
    cctvStartTs?: SortOrderInput | SortOrder
    cctvEndTs?: SortOrderInput | SortOrder
    _count?: MediaRefCountOrderByAggregateInput
    _avg?: MediaRefAvgOrderByAggregateInput
    _max?: MediaRefMaxOrderByAggregateInput
    _min?: MediaRefMinOrderByAggregateInput
    _sum?: MediaRefSumOrderByAggregateInput
  }

  export type MediaRefScalarWhereWithAggregatesInput = {
    AND?: MediaRefScalarWhereWithAggregatesInput | MediaRefScalarWhereWithAggregatesInput[]
    OR?: MediaRefScalarWhereWithAggregatesInput[]
    NOT?: MediaRefScalarWhereWithAggregatesInput | MediaRefScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MediaRef"> | number
    sessionId?: IntWithAggregatesFilter<"MediaRef"> | number
    type?: EnumMediaTypeWithAggregatesFilter<"MediaRef"> | $Enums.MediaType
    storageUrl?: StringWithAggregatesFilter<"MediaRef"> | string
    sha256?: StringNullableWithAggregatesFilter<"MediaRef"> | string | null
    capturedAt?: DateTimeWithAggregatesFilter<"MediaRef"> | Date | string
    cctvCameraId?: StringNullableWithAggregatesFilter<"MediaRef"> | string | null
    cctvStartTs?: DateTimeNullableWithAggregatesFilter<"MediaRef"> | Date | string | null
    cctvEndTs?: DateTimeNullableWithAggregatesFilter<"MediaRef"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    tenantId?: IntFilter<"AuditLog"> | number
    actorUserId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    beforeJson?: JsonNullableFilter<"AuditLog">
    afterJson?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    beforeJson?: SortOrderInput | SortOrder
    afterJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: IntFilter<"AuditLog"> | number
    actorUserId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    beforeJson?: JsonNullableFilter<"AuditLog">
    afterJson?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    beforeJson?: SortOrderInput | SortOrder
    afterJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    tenantId?: IntWithAggregatesFilter<"AuditLog"> | number
    actorUserId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    beforeJson?: JsonNullableWithAggregatesFilter<"AuditLog">
    afterJson?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type InsurerWhereInput = {
    AND?: InsurerWhereInput | InsurerWhereInput[]
    OR?: InsurerWhereInput[]
    NOT?: InsurerWhereInput | InsurerWhereInput[]
    id?: IntFilter<"Insurer"> | number
    name?: StringFilter<"Insurer"> | string
    contactPerson?: StringNullableFilter<"Insurer"> | string | null
    email?: StringNullableFilter<"Insurer"> | string | null
    phone?: StringNullableFilter<"Insurer"> | string | null
    status?: EnumInsurerStatusFilter<"Insurer"> | $Enums.InsurerStatus
    users?: InsurerUserListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    apiUsageLogs?: ApiUsageLogListRelationFilter
    agents?: AgentListRelationFilter
  }

  export type InsurerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    users?: InsurerUserOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    apiUsageLogs?: ApiUsageLogOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
  }

  export type InsurerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: InsurerWhereInput | InsurerWhereInput[]
    OR?: InsurerWhereInput[]
    NOT?: InsurerWhereInput | InsurerWhereInput[]
    contactPerson?: StringNullableFilter<"Insurer"> | string | null
    email?: StringNullableFilter<"Insurer"> | string | null
    phone?: StringNullableFilter<"Insurer"> | string | null
    status?: EnumInsurerStatusFilter<"Insurer"> | $Enums.InsurerStatus
    users?: InsurerUserListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    apiUsageLogs?: ApiUsageLogListRelationFilter
    agents?: AgentListRelationFilter
  }, "id" | "name">

  export type InsurerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: InsurerCountOrderByAggregateInput
    _avg?: InsurerAvgOrderByAggregateInput
    _max?: InsurerMaxOrderByAggregateInput
    _min?: InsurerMinOrderByAggregateInput
    _sum?: InsurerSumOrderByAggregateInput
  }

  export type InsurerScalarWhereWithAggregatesInput = {
    AND?: InsurerScalarWhereWithAggregatesInput | InsurerScalarWhereWithAggregatesInput[]
    OR?: InsurerScalarWhereWithAggregatesInput[]
    NOT?: InsurerScalarWhereWithAggregatesInput | InsurerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Insurer"> | number
    name?: StringWithAggregatesFilter<"Insurer"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Insurer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Insurer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Insurer"> | string | null
    status?: EnumInsurerStatusWithAggregatesFilter<"Insurer"> | $Enums.InsurerStatus
  }

  export type InsurerUserWhereInput = {
    AND?: InsurerUserWhereInput | InsurerUserWhereInput[]
    OR?: InsurerUserWhereInput[]
    NOT?: InsurerUserWhereInput | InsurerUserWhereInput[]
    id?: IntFilter<"InsurerUser"> | number
    insurerId?: IntFilter<"InsurerUser"> | number
    userId?: IntFilter<"InsurerUser"> | number
    insurer?: XOR<InsurerRelationFilter, InsurerWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InsurerUserOrderByWithRelationInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
    insurer?: InsurerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InsurerUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: InsurerUserWhereInput | InsurerUserWhereInput[]
    OR?: InsurerUserWhereInput[]
    NOT?: InsurerUserWhereInput | InsurerUserWhereInput[]
    insurerId?: IntFilter<"InsurerUser"> | number
    insurer?: XOR<InsurerRelationFilter, InsurerWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type InsurerUserOrderByWithAggregationInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
    _count?: InsurerUserCountOrderByAggregateInput
    _avg?: InsurerUserAvgOrderByAggregateInput
    _max?: InsurerUserMaxOrderByAggregateInput
    _min?: InsurerUserMinOrderByAggregateInput
    _sum?: InsurerUserSumOrderByAggregateInput
  }

  export type InsurerUserScalarWhereWithAggregatesInput = {
    AND?: InsurerUserScalarWhereWithAggregatesInput | InsurerUserScalarWhereWithAggregatesInput[]
    OR?: InsurerUserScalarWhereWithAggregatesInput[]
    NOT?: InsurerUserScalarWhereWithAggregatesInput | InsurerUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InsurerUser"> | number
    insurerId?: IntWithAggregatesFilter<"InsurerUser"> | number
    userId?: IntWithAggregatesFilter<"InsurerUser"> | number
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    insurerId?: IntFilter<"ApiKey"> | number
    name?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    scopes?: JsonNullableFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    insurer?: XOR<InsurerRelationFilter, InsurerWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    insurerId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    scopes?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    insurer?: InsurerOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    keyHash?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    insurerId?: IntFilter<"ApiKey"> | number
    name?: StringFilter<"ApiKey"> | string
    scopes?: JsonNullableFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    insurer?: XOR<InsurerRelationFilter, InsurerWhereInput>
  }, "id" | "keyHash">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    insurerId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    scopes?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiKey"> | number
    insurerId?: IntWithAggregatesFilter<"ApiKey"> | number
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    scopes?: JsonNullableWithAggregatesFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type ApiUsageLogWhereInput = {
    AND?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    OR?: ApiUsageLogWhereInput[]
    NOT?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    id?: IntFilter<"ApiUsageLog"> | number
    insurerId?: IntFilter<"ApiUsageLog"> | number
    endpoint?: StringFilter<"ApiUsageLog"> | string
    vehicleId?: IntNullableFilter<"ApiUsageLog"> | number | null
    statusCode?: IntFilter<"ApiUsageLog"> | number
    responseMs?: IntFilter<"ApiUsageLog"> | number
    createdAt?: DateTimeFilter<"ApiUsageLog"> | Date | string
    insurer?: XOR<InsurerRelationFilter, InsurerWhereInput>
  }

  export type ApiUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    insurerId?: SortOrder
    endpoint?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
    createdAt?: SortOrder
    insurer?: InsurerOrderByWithRelationInput
  }

  export type ApiUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    OR?: ApiUsageLogWhereInput[]
    NOT?: ApiUsageLogWhereInput | ApiUsageLogWhereInput[]
    insurerId?: IntFilter<"ApiUsageLog"> | number
    endpoint?: StringFilter<"ApiUsageLog"> | string
    vehicleId?: IntNullableFilter<"ApiUsageLog"> | number | null
    statusCode?: IntFilter<"ApiUsageLog"> | number
    responseMs?: IntFilter<"ApiUsageLog"> | number
    createdAt?: DateTimeFilter<"ApiUsageLog"> | Date | string
    insurer?: XOR<InsurerRelationFilter, InsurerWhereInput>
  }, "id">

  export type ApiUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    insurerId?: SortOrder
    endpoint?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
    createdAt?: SortOrder
    _count?: ApiUsageLogCountOrderByAggregateInput
    _avg?: ApiUsageLogAvgOrderByAggregateInput
    _max?: ApiUsageLogMaxOrderByAggregateInput
    _min?: ApiUsageLogMinOrderByAggregateInput
    _sum?: ApiUsageLogSumOrderByAggregateInput
  }

  export type ApiUsageLogScalarWhereWithAggregatesInput = {
    AND?: ApiUsageLogScalarWhereWithAggregatesInput | ApiUsageLogScalarWhereWithAggregatesInput[]
    OR?: ApiUsageLogScalarWhereWithAggregatesInput[]
    NOT?: ApiUsageLogScalarWhereWithAggregatesInput | ApiUsageLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiUsageLog"> | number
    insurerId?: IntWithAggregatesFilter<"ApiUsageLog"> | number
    endpoint?: StringWithAggregatesFilter<"ApiUsageLog"> | string
    vehicleId?: IntNullableWithAggregatesFilter<"ApiUsageLog"> | number | null
    statusCode?: IntWithAggregatesFilter<"ApiUsageLog"> | number
    responseMs?: IntWithAggregatesFilter<"ApiUsageLog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApiUsageLog"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: IntFilter<"Agent"> | number
    userId?: IntNullableFilter<"Agent"> | number | null
    insurerId?: IntNullableFilter<"Agent"> | number | null
    fullName?: StringFilter<"Agent"> | string
    phone?: StringNullableFilter<"Agent"> | string | null
    email?: StringNullableFilter<"Agent"> | string | null
    status?: StringFilter<"Agent"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    insurer?: XOR<InsurerNullableRelationFilter, InsurerWhereInput> | null
    referrals?: ReferralListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    insurerId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationInput
    insurer?: InsurerOrderByWithRelationInput
    referrals?: ReferralOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    insurerId?: IntNullableFilter<"Agent"> | number | null
    fullName?: StringFilter<"Agent"> | string
    phone?: StringNullableFilter<"Agent"> | string | null
    email?: StringNullableFilter<"Agent"> | string | null
    status?: StringFilter<"Agent"> | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    insurer?: XOR<InsurerNullableRelationFilter, InsurerWhereInput> | null
    referrals?: ReferralListRelationFilter
  }, "id" | "userId">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    insurerId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agent"> | number
    userId?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    insurerId?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    fullName?: StringWithAggregatesFilter<"Agent"> | string
    phone?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    email?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    status?: StringWithAggregatesFilter<"Agent"> | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: IntFilter<"Referral"> | number
    agentId?: IntFilter<"Referral"> | number
    vehicleId?: IntFilter<"Referral"> | number
    sessionId?: IntNullableFilter<"Referral"> | number | null
    referredAt?: DateTimeFilter<"Referral"> | Date | string
    convertedToPolicy?: BoolFilter<"Referral"> | boolean
    notes?: StringNullableFilter<"Referral"> | string | null
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    session?: XOR<InspectionSessionNullableRelationFilter, InspectionSessionWhereInput> | null
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    referredAt?: SortOrder
    convertedToPolicy?: SortOrder
    notes?: SortOrderInput | SortOrder
    agent?: AgentOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    session?: InspectionSessionOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    agentId?: IntFilter<"Referral"> | number
    vehicleId?: IntFilter<"Referral"> | number
    sessionId?: IntNullableFilter<"Referral"> | number | null
    referredAt?: DateTimeFilter<"Referral"> | Date | string
    convertedToPolicy?: BoolFilter<"Referral"> | boolean
    notes?: StringNullableFilter<"Referral"> | string | null
    agent?: XOR<AgentRelationFilter, AgentWhereInput>
    vehicle?: XOR<VehicleRelationFilter, VehicleWhereInput>
    session?: XOR<InspectionSessionNullableRelationFilter, InspectionSessionWhereInput> | null
  }, "id">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    referredAt?: SortOrder
    convertedToPolicy?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Referral"> | number
    agentId?: IntWithAggregatesFilter<"Referral"> | number
    vehicleId?: IntWithAggregatesFilter<"Referral"> | number
    sessionId?: IntNullableWithAggregatesFilter<"Referral"> | number | null
    referredAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    convertedToPolicy?: BoolWithAggregatesFilter<"Referral"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Referral"> | string | null
  }

  export type TenantCreateInput = {
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    inspector?: InspectorCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserCreateNestedOneWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    tenantId?: number | null
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    inspector?: InspectorUncheckedCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserUncheckedCreateNestedOneWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    inspector?: InspectorUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUpdateOneWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: InspectorUncheckedUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUncheckedUpdateOneWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    tenantId?: number | null
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectorCreateInput = {
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
    user: UserCreateNestedOneWithoutInspectorInput
    sessions?: InspectionSessionCreateNestedManyWithoutInspectorInput
  }

  export type InspectorUncheckedCreateInput = {
    id?: number
    userId: number
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutInspectorInput
  }

  export type InspectorUpdateInput = {
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
    user?: UserUpdateOneRequiredWithoutInspectorNestedInput
    sessions?: InspectionSessionUpdateManyWithoutInspectorNestedInput
  }

  export type InspectorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
    sessions?: InspectionSessionUncheckedUpdateManyWithoutInspectorNestedInput
  }

  export type InspectorCreateManyInput = {
    id?: number
    userId: number
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
  }

  export type InspectorUpdateManyMutationInput = {
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
  }

  export type InspectorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
  }

  export type OwnerCreateInput = {
    fullName: string
    idNo?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    vehicles?: VehicleCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateInput = {
    id?: number
    fullName: string
    idNo?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    vehicles?: VehicleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    idNo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vehicles?: VehicleUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    idNo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vehicles?: VehicleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateManyInput = {
    id?: number
    fullName: string
    idNo?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
  }

  export type OwnerUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    idNo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    idNo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleCreateInput = {
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVehiclesInput
    owner?: OwnerCreateNestedOneWithoutVehiclesInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionCreateNestedManyWithoutVehicleInput
    referrals?: ReferralCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: number
    tenantId: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutVehicleInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVehiclesNestedInput
    owner?: OwnerUpdateOneWithoutVehiclesNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: number
    tenantId: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    sessions?: InspectionSessionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    sessions?: InspectionSessionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InspectionSessionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionItemCreateInput = {
    code: string
    name: string
    group: $Enums.ItemGroup
    weightPct: number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
    results?: InspectionResultCreateNestedManyWithoutItemInput
  }

  export type InspectionItemUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    group: $Enums.ItemGroup
    weightPct: number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
    results?: InspectionResultUncheckedCreateNestedManyWithoutItemInput
  }

  export type InspectionItemUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: EnumItemGroupFieldUpdateOperationsInput | $Enums.ItemGroup
    weightPct?: IntFieldUpdateOperationsInput | number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
    results?: InspectionResultUpdateManyWithoutItemNestedInput
  }

  export type InspectionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: EnumItemGroupFieldUpdateOperationsInput | $Enums.ItemGroup
    weightPct?: IntFieldUpdateOperationsInput | number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
    results?: InspectionResultUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InspectionItemCreateManyInput = {
    id?: number
    code: string
    name: string
    group: $Enums.ItemGroup
    weightPct: number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionItemUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: EnumItemGroupFieldUpdateOperationsInput | $Enums.ItemGroup
    weightPct?: IntFieldUpdateOperationsInput | number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: EnumItemGroupFieldUpdateOperationsInput | $Enums.ItemGroup
    weightPct?: IntFieldUpdateOperationsInput | number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionSessionCreateInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUpdateInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionCreateManyInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionSessionUpdateManyMutationInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultCreateInput = {
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
    session: InspectionSessionCreateNestedOneWithoutResultsInput
    item: InspectionItemCreateNestedOneWithoutResultsInput
  }

  export type InspectionResultUncheckedCreateInput = {
    id?: number
    sessionId: number
    itemId: number
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
  }

  export type InspectionResultUpdateInput = {
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: InspectionSessionUpdateOneRequiredWithoutResultsNestedInput
    item?: InspectionItemUpdateOneRequiredWithoutResultsNestedInput
  }

  export type InspectionResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultCreateManyInput = {
    id?: number
    sessionId: number
    itemId: number
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
  }

  export type InspectionResultUpdateManyMutationInput = {
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    certificateNo: string
    issuedAt?: Date | string
    expiresAt: Date | string
    stickerNo?: string | null
    reportPdfUrl?: string | null
    verificationHash: string
    session: InspectionSessionCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: number
    sessionId: number
    certificateNo: string
    issuedAt?: Date | string
    expiresAt: Date | string
    stickerNo?: string | null
    reportPdfUrl?: string | null
    verificationHash: string
  }

  export type CertificateUpdateInput = {
    certificateNo?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickerNo?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationHash?: StringFieldUpdateOperationsInput | string
    session?: InspectionSessionUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    certificateNo?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickerNo?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationHash?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateCreateManyInput = {
    id?: number
    sessionId: number
    certificateNo: string
    issuedAt?: Date | string
    expiresAt: Date | string
    stickerNo?: string | null
    reportPdfUrl?: string | null
    verificationHash: string
  }

  export type CertificateUpdateManyMutationInput = {
    certificateNo?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickerNo?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationHash?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    certificateNo?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickerNo?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationHash?: StringFieldUpdateOperationsInput | string
  }

  export type ReinspectionLinkCreateInput = {
    freeWithin14Days?: boolean
    reason?: string | null
    originalSession: InspectionSessionCreateNestedOneWithoutOriginalReinspectionsInput
    newSession: InspectionSessionCreateNestedOneWithoutNewReinspectionInput
  }

  export type ReinspectionLinkUncheckedCreateInput = {
    id?: number
    originalSessionId: number
    newSessionId: number
    freeWithin14Days?: boolean
    reason?: string | null
  }

  export type ReinspectionLinkUpdateInput = {
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    originalSession?: InspectionSessionUpdateOneRequiredWithoutOriginalReinspectionsNestedInput
    newSession?: InspectionSessionUpdateOneRequiredWithoutNewReinspectionNestedInput
  }

  export type ReinspectionLinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalSessionId?: IntFieldUpdateOperationsInput | number
    newSessionId?: IntFieldUpdateOperationsInput | number
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReinspectionLinkCreateManyInput = {
    id?: number
    originalSessionId: number
    newSessionId: number
    freeWithin14Days?: boolean
    reason?: string | null
  }

  export type ReinspectionLinkUpdateManyMutationInput = {
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReinspectionLinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalSessionId?: IntFieldUpdateOperationsInput | number
    newSessionId?: IntFieldUpdateOperationsInput | number
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaRefCreateInput = {
    type: $Enums.MediaType
    storageUrl: string
    sha256?: string | null
    capturedAt?: Date | string
    cctvCameraId?: string | null
    cctvStartTs?: Date | string | null
    cctvEndTs?: Date | string | null
    session: InspectionSessionCreateNestedOneWithoutMediaRefsInput
  }

  export type MediaRefUncheckedCreateInput = {
    id?: number
    sessionId: number
    type: $Enums.MediaType
    storageUrl: string
    sha256?: string | null
    capturedAt?: Date | string
    cctvCameraId?: string | null
    cctvStartTs?: Date | string | null
    cctvEndTs?: Date | string | null
  }

  export type MediaRefUpdateInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session?: InspectionSessionUpdateOneRequiredWithoutMediaRefsNestedInput
  }

  export type MediaRefUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaRefCreateManyInput = {
    id?: number
    sessionId: number
    type: $Enums.MediaType
    storageUrl: string
    sha256?: string | null
    capturedAt?: Date | string
    cctvCameraId?: string | null
    cctvStartTs?: Date | string | null
    cctvEndTs?: Date | string | null
  }

  export type MediaRefUpdateManyMutationInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaRefUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    tenantId: number
    actorUserId?: number | null
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    tenantId: number
    actorUserId?: number | null
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurerCreateInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserCreateNestedManyWithoutInsurerInput
    apiKeys?: ApiKeyCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogCreateNestedManyWithoutInsurerInput
    agents?: AgentCreateNestedManyWithoutInsurerInput
  }

  export type InsurerUncheckedCreateInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserUncheckedCreateNestedManyWithoutInsurerInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutInsurerInput
    agents?: AgentUncheckedCreateNestedManyWithoutInsurerInput
  }

  export type InsurerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUpdateManyWithoutInsurerNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUpdateManyWithoutInsurerNestedInput
    agents?: AgentUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUncheckedUpdateManyWithoutInsurerNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUncheckedUpdateManyWithoutInsurerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerCreateManyInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
  }

  export type InsurerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
  }

  export type InsurerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
  }

  export type InsurerUserCreateInput = {
    insurer: InsurerCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutInsurerUserInput
  }

  export type InsurerUserUncheckedCreateInput = {
    id?: number
    insurerId: number
    userId: number
  }

  export type InsurerUserUpdateInput = {
    insurer?: InsurerUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutInsurerUserNestedInput
  }

  export type InsurerUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type InsurerUserCreateManyInput = {
    id?: number
    insurerId: number
    userId: number
  }

  export type InsurerUserUpdateManyMutationInput = {

  }

  export type InsurerUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ApiKeyCreateInput = {
    name: string
    keyHash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    insurer: InsurerCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: number
    insurerId: number
    name: string
    keyHash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insurer?: InsurerUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: number
    insurerId: number
    name: string
    keyHash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogCreateInput = {
    endpoint: string
    vehicleId?: number | null
    statusCode: number
    responseMs: number
    createdAt?: Date | string
    insurer: InsurerCreateNestedOneWithoutApiUsageLogsInput
  }

  export type ApiUsageLogUncheckedCreateInput = {
    id?: number
    insurerId: number
    endpoint: string
    vehicleId?: number | null
    statusCode: number
    responseMs: number
    createdAt?: Date | string
  }

  export type ApiUsageLogUpdateInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insurer?: InsurerUpdateOneRequiredWithoutApiUsageLogsNestedInput
  }

  export type ApiUsageLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogCreateManyInput = {
    id?: number
    insurerId: number
    endpoint: string
    vehicleId?: number | null
    statusCode: number
    responseMs: number
    createdAt?: Date | string
  }

  export type ApiUsageLogUpdateManyMutationInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    user?: UserCreateNestedOneWithoutAgentInput
    insurer?: InsurerCreateNestedOneWithoutAgentsInput
    referrals?: ReferralCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: number
    userId?: number | null
    insurerId?: number | null
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    referrals?: ReferralUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutAgentNestedInput
    insurer?: InsurerUpdateOneWithoutAgentsNestedInput
    referrals?: ReferralUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    insurerId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    referrals?: ReferralUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: number
    userId?: number | null
    insurerId?: number | null
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
  }

  export type AgentUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    insurerId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralCreateInput = {
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
    agent: AgentCreateNestedOneWithoutReferralsInput
    vehicle: VehicleCreateNestedOneWithoutReferralsInput
    session?: InspectionSessionCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: number
    agentId: number
    vehicleId: number
    sessionId?: number | null
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type ReferralUpdateInput = {
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutReferralsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutReferralsNestedInput
    session?: InspectionSessionUpdateOneWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralCreateManyInput = {
    id?: number
    agentId: number
    vehicleId: number
    sessionId?: number | null
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type ReferralUpdateManyMutationInput = {
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type InspectionSessionListRelationFilter = {
    every?: InspectionSessionWhereInput
    some?: InspectionSessionWhereInput
    none?: InspectionSessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InspectionSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    county?: SortOrder
    cluster?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    id?: SortOrder
    cluster?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    county?: SortOrder
    cluster?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    county?: SortOrder
    cluster?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    id?: SortOrder
    cluster?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type InspectorNullableRelationFilter = {
    is?: InspectorWhereInput | null
    isNot?: InspectorWhereInput | null
  }

  export type InsurerUserNullableRelationFilter = {
    is?: InsurerUserWhereInput | null
    isNot?: InsurerUserWhereInput | null
  }

  export type AgentNullableRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumInspectorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectorStatus | EnumInspectorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectorStatusFilter<$PrismaModel> | $Enums.InspectorStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InspectorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenceNo?: SortOrder
    licenceExpiry?: SortOrder
    qualification?: SortOrder
    yearsExperience?: SortOrder
    status?: SortOrder
  }

  export type InspectorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    yearsExperience?: SortOrder
  }

  export type InspectorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenceNo?: SortOrder
    licenceExpiry?: SortOrder
    qualification?: SortOrder
    yearsExperience?: SortOrder
    status?: SortOrder
  }

  export type InspectorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenceNo?: SortOrder
    licenceExpiry?: SortOrder
    qualification?: SortOrder
    yearsExperience?: SortOrder
    status?: SortOrder
  }

  export type InspectorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    yearsExperience?: SortOrder
  }

  export type EnumInspectorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectorStatus | EnumInspectorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectorStatusWithAggregatesFilter<$PrismaModel> | $Enums.InspectorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectorStatusFilter<$PrismaModel>
    _max?: NestedEnumInspectorStatusFilter<$PrismaModel>
  }

  export type OwnerCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    idNo?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
  }

  export type OwnerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    idNo?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
  }

  export type OwnerMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    idNo?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
  }

  export type OwnerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumVehicleCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleCategory | EnumVehicleCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleCategoryFilter<$PrismaModel> | $Enums.VehicleCategory
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type OwnerNullableRelationFilter = {
    is?: OwnerWhereInput | null
    isNot?: OwnerWhereInput | null
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrder
    registrationNo?: SortOrder
    vin?: SortOrder
    engineNo?: SortOrder
    make?: SortOrder
    model?: SortOrder
    yearOfMfg?: SortOrder
    category?: SortOrder
    tareWeightKg?: SortOrder
    engineCc?: SortOrder
    evBatteryKwh?: SortOrder
    telematicsImei?: SortOrder
    speedGovernorSerial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrder
    yearOfMfg?: SortOrder
    tareWeightKg?: SortOrder
    engineCc?: SortOrder
    evBatteryKwh?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrder
    registrationNo?: SortOrder
    vin?: SortOrder
    engineNo?: SortOrder
    make?: SortOrder
    model?: SortOrder
    yearOfMfg?: SortOrder
    category?: SortOrder
    tareWeightKg?: SortOrder
    engineCc?: SortOrder
    evBatteryKwh?: SortOrder
    telematicsImei?: SortOrder
    speedGovernorSerial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrder
    registrationNo?: SortOrder
    vin?: SortOrder
    engineNo?: SortOrder
    make?: SortOrder
    model?: SortOrder
    yearOfMfg?: SortOrder
    category?: SortOrder
    tareWeightKg?: SortOrder
    engineCc?: SortOrder
    evBatteryKwh?: SortOrder
    telematicsImei?: SortOrder
    speedGovernorSerial?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    ownerId?: SortOrder
    yearOfMfg?: SortOrder
    tareWeightKg?: SortOrder
    engineCc?: SortOrder
    evBatteryKwh?: SortOrder
  }

  export type EnumVehicleCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleCategory | EnumVehicleCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VehicleCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleCategoryFilter<$PrismaModel>
    _max?: NestedEnumVehicleCategoryFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type VehicleRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingRef?: SortOrder
    bookingFeePaid?: SortOrder
    bookingFeeReceiptNo?: SortOrder
    bookedForDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingRef?: SortOrder
    bookingFeePaid?: SortOrder
    bookingFeeReceiptNo?: SortOrder
    bookedForDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingRef?: SortOrder
    bookingFeePaid?: SortOrder
    bookingFeeReceiptNo?: SortOrder
    bookedForDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumItemGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemGroup | EnumItemGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumItemGroupFilter<$PrismaModel> | $Enums.ItemGroup
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InspectionResultListRelationFilter = {
    every?: InspectionResultWhereInput
    some?: InspectionResultWhereInput
    none?: InspectionResultWhereInput
  }

  export type InspectionResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InspectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    group?: SortOrder
    weightPct?: SortOrder
    requiredForCategories?: SortOrder
  }

  export type InspectionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    weightPct?: SortOrder
  }

  export type InspectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    group?: SortOrder
    weightPct?: SortOrder
  }

  export type InspectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    group?: SortOrder
    weightPct?: SortOrder
  }

  export type InspectionItemSumOrderByAggregateInput = {
    id?: SortOrder
    weightPct?: SortOrder
  }

  export type EnumItemGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemGroup | EnumItemGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumItemGroupWithAggregatesFilter<$PrismaModel> | $Enums.ItemGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemGroupFilter<$PrismaModel>
    _max?: NestedEnumItemGroupFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumInspectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionType | EnumInspectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionTypeFilter<$PrismaModel> | $Enums.InspectionType
  }

  export type EnumInspectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusFilter<$PrismaModel> | $Enums.InspectionStatus
  }

  export type EnumDefectSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityFilter<$PrismaModel> | $Enums.DefectSeverity
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type CertificateNullableRelationFilter = {
    is?: CertificateWhereInput | null
    isNot?: CertificateWhereInput | null
  }

  export type MediaRefListRelationFilter = {
    every?: MediaRefWhereInput
    some?: MediaRefWhereInput
    none?: MediaRefWhereInput
  }

  export type ReinspectionLinkListRelationFilter = {
    every?: ReinspectionLinkWhereInput
    some?: ReinspectionLinkWhereInput
    none?: ReinspectionLinkWhereInput
  }

  export type ReinspectionLinkNullableRelationFilter = {
    is?: ReinspectionLinkWhereInput | null
    isNot?: ReinspectionLinkWhereInput | null
  }

  export type MediaRefOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReinspectionLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InspectionSessionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrder
    inspectorId?: SortOrder
    inspectedAt?: SortOrder
    inspectionType?: SortOrder
    odometerKm?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
    defectSeverity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrder
    inspectorId?: SortOrder
    odometerKm?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
  }

  export type InspectionSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrder
    inspectorId?: SortOrder
    inspectedAt?: SortOrder
    inspectionType?: SortOrder
    odometerKm?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
    defectSeverity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionSessionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrder
    inspectorId?: SortOrder
    inspectedAt?: SortOrder
    inspectionType?: SortOrder
    odometerKm?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
    defectSeverity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InspectionSessionSumOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    vehicleId?: SortOrder
    bookingId?: SortOrder
    inspectorId?: SortOrder
    odometerKm?: SortOrder
    passThreshold?: SortOrder
    totalScore?: SortOrder
  }

  export type EnumInspectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionType | EnumInspectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InspectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectionTypeFilter<$PrismaModel>
    _max?: NestedEnumInspectionTypeFilter<$PrismaModel>
  }

  export type EnumInspectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InspectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectionStatusFilter<$PrismaModel>
    _max?: NestedEnumInspectionStatusFilter<$PrismaModel>
  }

  export type EnumDefectSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityWithAggregatesFilter<$PrismaModel> | $Enums.DefectSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectSeverityFilter<$PrismaModel>
    _max?: NestedEnumDefectSeverityFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumResultSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultSeverity | EnumResultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumResultSeverityFilter<$PrismaModel> | $Enums.ResultSeverity
  }

  export type InspectionSessionRelationFilter = {
    is?: InspectionSessionWhereInput
    isNot?: InspectionSessionWhereInput
  }

  export type InspectionItemRelationFilter = {
    is?: InspectionItemWhereInput
    isNot?: InspectionItemWhereInput
  }

  export type InspectionResultSessionIdItemIdCompoundUniqueInput = {
    sessionId: number
    itemId: number
  }

  export type InspectionResultCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrder
    measuredValueText?: SortOrder
    pass?: SortOrder
    severity?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type InspectionResultAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrder
  }

  export type InspectionResultMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrder
    measuredValueText?: SortOrder
    pass?: SortOrder
    severity?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type InspectionResultMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrder
    measuredValueText?: SortOrder
    pass?: SortOrder
    severity?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type InspectionResultSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    itemId?: SortOrder
    measuredValueNum?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumResultSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultSeverity | EnumResultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumResultSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ResultSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultSeverityFilter<$PrismaModel>
    _max?: NestedEnumResultSeverityFilter<$PrismaModel>
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    certificateNo?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    stickerNo?: SortOrder
    reportPdfUrl?: SortOrder
    verificationHash?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    certificateNo?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    stickerNo?: SortOrder
    reportPdfUrl?: SortOrder
    verificationHash?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    certificateNo?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    stickerNo?: SortOrder
    reportPdfUrl?: SortOrder
    verificationHash?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
  }

  export type ReinspectionLinkCountOrderByAggregateInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
    freeWithin14Days?: SortOrder
    reason?: SortOrder
  }

  export type ReinspectionLinkAvgOrderByAggregateInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
  }

  export type ReinspectionLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
    freeWithin14Days?: SortOrder
    reason?: SortOrder
  }

  export type ReinspectionLinkMinOrderByAggregateInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
    freeWithin14Days?: SortOrder
    reason?: SortOrder
  }

  export type ReinspectionLinkSumOrderByAggregateInput = {
    id?: SortOrder
    originalSessionId?: SortOrder
    newSessionId?: SortOrder
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type MediaRefCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    storageUrl?: SortOrder
    sha256?: SortOrder
    capturedAt?: SortOrder
    cctvCameraId?: SortOrder
    cctvStartTs?: SortOrder
    cctvEndTs?: SortOrder
  }

  export type MediaRefAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
  }

  export type MediaRefMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    storageUrl?: SortOrder
    sha256?: SortOrder
    capturedAt?: SortOrder
    cctvCameraId?: SortOrder
    cctvStartTs?: SortOrder
    cctvEndTs?: SortOrder
  }

  export type MediaRefMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    storageUrl?: SortOrder
    sha256?: SortOrder
    capturedAt?: SortOrder
    cctvCameraId?: SortOrder
    cctvStartTs?: SortOrder
    cctvEndTs?: SortOrder
  }

  export type MediaRefSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    beforeJson?: SortOrder
    afterJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorUserId?: SortOrder
  }

  export type EnumInsurerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsurerStatus | EnumInsurerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsurerStatusFilter<$PrismaModel> | $Enums.InsurerStatus
  }

  export type InsurerUserListRelationFilter = {
    every?: InsurerUserWhereInput
    some?: InsurerUserWhereInput
    none?: InsurerUserWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type ApiUsageLogListRelationFilter = {
    every?: ApiUsageLogWhereInput
    some?: ApiUsageLogWhereInput
    none?: ApiUsageLogWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type InsurerUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsurerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
  }

  export type InsurerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InsurerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
  }

  export type InsurerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
  }

  export type InsurerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumInsurerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsurerStatus | EnumInsurerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsurerStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsurerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsurerStatusFilter<$PrismaModel>
    _max?: NestedEnumInsurerStatusFilter<$PrismaModel>
  }

  export type InsurerRelationFilter = {
    is?: InsurerWhereInput
    isNot?: InsurerWhereInput
  }

  export type InsurerUserCountOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
  }

  export type InsurerUserAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
  }

  export type InsurerUserMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
  }

  export type InsurerUserMinOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
  }

  export type InsurerUserSumOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    userId?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    scopes?: SortOrder
    lastUsedAt?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    lastUsedAt?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    name?: SortOrder
    keyHash?: SortOrder
    lastUsedAt?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
  }

  export type ApiUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    endpoint?: SortOrder
    vehicleId?: SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogAvgOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    vehicleId?: SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
  }

  export type ApiUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    endpoint?: SortOrder
    vehicleId?: SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    endpoint?: SortOrder
    vehicleId?: SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiUsageLogSumOrderByAggregateInput = {
    id?: SortOrder
    insurerId?: SortOrder
    vehicleId?: SortOrder
    statusCode?: SortOrder
    responseMs?: SortOrder
  }

  export type InsurerNullableRelationFilter = {
    is?: InsurerWhereInput | null
    isNot?: InsurerWhereInput | null
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insurerId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insurerId?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insurerId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insurerId?: SortOrder
    fullName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insurerId?: SortOrder
  }

  export type AgentRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type InspectionSessionNullableRelationFilter = {
    is?: InspectionSessionWhereInput | null
    isNot?: InspectionSessionWhereInput | null
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrder
    referredAt?: SortOrder
    convertedToPolicy?: SortOrder
    notes?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrder
    referredAt?: SortOrder
    convertedToPolicy?: SortOrder
    notes?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrder
    referredAt?: SortOrder
    convertedToPolicy?: SortOrder
    notes?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    vehicleId?: SortOrder
    sessionId?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VehicleCreateNestedManyWithoutTenantInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutTenantInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InspectionSessionCreateNestedManyWithoutTenantInput = {
    create?: XOR<InspectionSessionCreateWithoutTenantInput, InspectionSessionUncheckedCreateWithoutTenantInput> | InspectionSessionCreateWithoutTenantInput[] | InspectionSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutTenantInput | InspectionSessionCreateOrConnectWithoutTenantInput[]
    createMany?: InspectionSessionCreateManyTenantInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InspectionSessionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InspectionSessionCreateWithoutTenantInput, InspectionSessionUncheckedCreateWithoutTenantInput> | InspectionSessionCreateWithoutTenantInput[] | InspectionSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutTenantInput | InspectionSessionCreateOrConnectWithoutTenantInput[]
    createMany?: InspectionSessionCreateManyTenantInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VehicleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutTenantInput | VehicleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutTenantInput | VehicleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutTenantInput | VehicleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTenantInput | BookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTenantInput | BookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTenantInput | BookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InspectionSessionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutTenantInput, InspectionSessionUncheckedCreateWithoutTenantInput> | InspectionSessionCreateWithoutTenantInput[] | InspectionSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutTenantInput | InspectionSessionCreateOrConnectWithoutTenantInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutTenantInput | InspectionSessionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InspectionSessionCreateManyTenantInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutTenantInput | InspectionSessionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutTenantInput | InspectionSessionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput> | VehicleCreateWithoutTenantInput[] | VehicleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutTenantInput | VehicleCreateOrConnectWithoutTenantInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutTenantInput | VehicleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VehicleCreateManyTenantInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutTenantInput | VehicleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutTenantInput | VehicleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput> | BookingCreateWithoutTenantInput[] | BookingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTenantInput | BookingCreateOrConnectWithoutTenantInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTenantInput | BookingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BookingCreateManyTenantInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTenantInput | BookingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTenantInput | BookingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InspectionSessionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutTenantInput, InspectionSessionUncheckedCreateWithoutTenantInput> | InspectionSessionCreateWithoutTenantInput[] | InspectionSessionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutTenantInput | InspectionSessionCreateOrConnectWithoutTenantInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutTenantInput | InspectionSessionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InspectionSessionCreateManyTenantInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutTenantInput | InspectionSessionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutTenantInput | InspectionSessionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type InspectorCreateNestedOneWithoutUserInput = {
    create?: XOR<InspectorCreateWithoutUserInput, InspectorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InspectorCreateOrConnectWithoutUserInput
    connect?: InspectorWhereUniqueInput
  }

  export type InsurerUserCreateNestedOneWithoutUserInput = {
    create?: XOR<InsurerUserCreateWithoutUserInput, InsurerUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: InsurerUserCreateOrConnectWithoutUserInput
    connect?: InsurerUserWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InspectorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InspectorCreateWithoutUserInput, InspectorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InspectorCreateOrConnectWithoutUserInput
    connect?: InspectorWhereUniqueInput
  }

  export type InsurerUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InsurerUserCreateWithoutUserInput, InsurerUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: InsurerUserCreateOrConnectWithoutUserInput
    connect?: InsurerUserWhereUniqueInput
  }

  export type AgentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    connect?: AgentWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type InspectorUpdateOneWithoutUserNestedInput = {
    create?: XOR<InspectorCreateWithoutUserInput, InspectorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InspectorCreateOrConnectWithoutUserInput
    upsert?: InspectorUpsertWithoutUserInput
    disconnect?: InspectorWhereInput | boolean
    delete?: InspectorWhereInput | boolean
    connect?: InspectorWhereUniqueInput
    update?: XOR<XOR<InspectorUpdateToOneWithWhereWithoutUserInput, InspectorUpdateWithoutUserInput>, InspectorUncheckedUpdateWithoutUserInput>
  }

  export type InsurerUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<InsurerUserCreateWithoutUserInput, InsurerUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: InsurerUserCreateOrConnectWithoutUserInput
    upsert?: InsurerUserUpsertWithoutUserInput
    disconnect?: InsurerUserWhereInput | boolean
    delete?: InsurerUserWhereInput | boolean
    connect?: InsurerUserWhereUniqueInput
    update?: XOR<XOR<InsurerUserUpdateToOneWithWhereWithoutUserInput, InsurerUserUpdateWithoutUserInput>, InsurerUserUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InspectorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InspectorCreateWithoutUserInput, InspectorUncheckedCreateWithoutUserInput>
    connectOrCreate?: InspectorCreateOrConnectWithoutUserInput
    upsert?: InspectorUpsertWithoutUserInput
    disconnect?: InspectorWhereInput | boolean
    delete?: InspectorWhereInput | boolean
    connect?: InspectorWhereUniqueInput
    update?: XOR<XOR<InspectorUpdateToOneWithWhereWithoutUserInput, InspectorUpdateWithoutUserInput>, InspectorUncheckedUpdateWithoutUserInput>
  }

  export type InsurerUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InsurerUserCreateWithoutUserInput, InsurerUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: InsurerUserCreateOrConnectWithoutUserInput
    upsert?: InsurerUserUpsertWithoutUserInput
    disconnect?: InsurerUserWhereInput | boolean
    delete?: InsurerUserWhereInput | boolean
    connect?: InsurerUserWhereUniqueInput
    update?: XOR<XOR<InsurerUserUpdateToOneWithWhereWithoutUserInput, InsurerUserUpdateWithoutUserInput>, InsurerUserUncheckedUpdateWithoutUserInput>
  }

  export type AgentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgentCreateOrConnectWithoutUserInput
    upsert?: AgentUpsertWithoutUserInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutUserInput, AgentUpdateWithoutUserInput>, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInspectorInput = {
    create?: XOR<UserCreateWithoutInspectorInput, UserUncheckedCreateWithoutInspectorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectorInput
    connect?: UserWhereUniqueInput
  }

  export type InspectionSessionCreateNestedManyWithoutInspectorInput = {
    create?: XOR<InspectionSessionCreateWithoutInspectorInput, InspectionSessionUncheckedCreateWithoutInspectorInput> | InspectionSessionCreateWithoutInspectorInput[] | InspectionSessionUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutInspectorInput | InspectionSessionCreateOrConnectWithoutInspectorInput[]
    createMany?: InspectionSessionCreateManyInspectorInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type InspectionSessionUncheckedCreateNestedManyWithoutInspectorInput = {
    create?: XOR<InspectionSessionCreateWithoutInspectorInput, InspectionSessionUncheckedCreateWithoutInspectorInput> | InspectionSessionCreateWithoutInspectorInput[] | InspectionSessionUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutInspectorInput | InspectionSessionCreateOrConnectWithoutInspectorInput[]
    createMany?: InspectionSessionCreateManyInspectorInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type EnumInspectorStatusFieldUpdateOperationsInput = {
    set?: $Enums.InspectorStatus
  }

  export type UserUpdateOneRequiredWithoutInspectorNestedInput = {
    create?: XOR<UserCreateWithoutInspectorInput, UserUncheckedCreateWithoutInspectorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInspectorInput
    upsert?: UserUpsertWithoutInspectorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInspectorInput, UserUpdateWithoutInspectorInput>, UserUncheckedUpdateWithoutInspectorInput>
  }

  export type InspectionSessionUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutInspectorInput, InspectionSessionUncheckedCreateWithoutInspectorInput> | InspectionSessionCreateWithoutInspectorInput[] | InspectionSessionUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutInspectorInput | InspectionSessionCreateOrConnectWithoutInspectorInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutInspectorInput | InspectionSessionUpsertWithWhereUniqueWithoutInspectorInput[]
    createMany?: InspectionSessionCreateManyInspectorInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutInspectorInput | InspectionSessionUpdateWithWhereUniqueWithoutInspectorInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutInspectorInput | InspectionSessionUpdateManyWithWhereWithoutInspectorInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type InspectionSessionUncheckedUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutInspectorInput, InspectionSessionUncheckedCreateWithoutInspectorInput> | InspectionSessionCreateWithoutInspectorInput[] | InspectionSessionUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutInspectorInput | InspectionSessionCreateOrConnectWithoutInspectorInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutInspectorInput | InspectionSessionUpsertWithWhereUniqueWithoutInspectorInput[]
    createMany?: InspectionSessionCreateManyInspectorInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutInspectorInput | InspectionSessionUpdateWithWhereUniqueWithoutInspectorInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutInspectorInput | InspectionSessionUpdateManyWithWhereWithoutInspectorInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type VehicleCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VehicleCreateWithoutOwnerInput, VehicleUncheckedCreateWithoutOwnerInput> | VehicleCreateWithoutOwnerInput[] | VehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutOwnerInput | VehicleCreateOrConnectWithoutOwnerInput[]
    createMany?: VehicleCreateManyOwnerInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<VehicleCreateWithoutOwnerInput, VehicleUncheckedCreateWithoutOwnerInput> | VehicleCreateWithoutOwnerInput[] | VehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutOwnerInput | VehicleCreateOrConnectWithoutOwnerInput[]
    createMany?: VehicleCreateManyOwnerInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type VehicleUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VehicleCreateWithoutOwnerInput, VehicleUncheckedCreateWithoutOwnerInput> | VehicleCreateWithoutOwnerInput[] | VehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutOwnerInput | VehicleCreateOrConnectWithoutOwnerInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutOwnerInput | VehicleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VehicleCreateManyOwnerInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutOwnerInput | VehicleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutOwnerInput | VehicleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<VehicleCreateWithoutOwnerInput, VehicleUncheckedCreateWithoutOwnerInput> | VehicleCreateWithoutOwnerInput[] | VehicleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutOwnerInput | VehicleCreateOrConnectWithoutOwnerInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutOwnerInput | VehicleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: VehicleCreateManyOwnerInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutOwnerInput | VehicleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutOwnerInput | VehicleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVehiclesInput
    connect?: TenantWhereUniqueInput
  }

  export type OwnerCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<OwnerCreateWithoutVehiclesInput, OwnerUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutVehiclesInput
    connect?: OwnerWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InspectionSessionCreateNestedManyWithoutVehicleInput = {
    create?: XOR<InspectionSessionCreateWithoutVehicleInput, InspectionSessionUncheckedCreateWithoutVehicleInput> | InspectionSessionCreateWithoutVehicleInput[] | InspectionSessionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutVehicleInput | InspectionSessionCreateOrConnectWithoutVehicleInput[]
    createMany?: InspectionSessionCreateManyVehicleInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ReferralCreateWithoutVehicleInput, ReferralUncheckedCreateWithoutVehicleInput> | ReferralCreateWithoutVehicleInput[] | ReferralUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutVehicleInput | ReferralCreateOrConnectWithoutVehicleInput[]
    createMany?: ReferralCreateManyVehicleInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InspectionSessionUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<InspectionSessionCreateWithoutVehicleInput, InspectionSessionUncheckedCreateWithoutVehicleInput> | InspectionSessionCreateWithoutVehicleInput[] | InspectionSessionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutVehicleInput | InspectionSessionCreateOrConnectWithoutVehicleInput[]
    createMany?: InspectionSessionCreateManyVehicleInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ReferralCreateWithoutVehicleInput, ReferralUncheckedCreateWithoutVehicleInput> | ReferralCreateWithoutVehicleInput[] | ReferralUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutVehicleInput | ReferralCreateOrConnectWithoutVehicleInput[]
    createMany?: ReferralCreateManyVehicleInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type EnumVehicleCategoryFieldUpdateOperationsInput = {
    set?: $Enums.VehicleCategory
  }

  export type TenantUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVehiclesInput
    upsert?: TenantUpsertWithoutVehiclesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVehiclesInput, TenantUpdateWithoutVehiclesInput>, TenantUncheckedUpdateWithoutVehiclesInput>
  }

  export type OwnerUpdateOneWithoutVehiclesNestedInput = {
    create?: XOR<OwnerCreateWithoutVehiclesInput, OwnerUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutVehiclesInput
    upsert?: OwnerUpsertWithoutVehiclesInput
    disconnect?: OwnerWhereInput | boolean
    delete?: OwnerWhereInput | boolean
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutVehiclesInput, OwnerUpdateWithoutVehiclesInput>, OwnerUncheckedUpdateWithoutVehiclesInput>
  }

  export type BookingUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVehicleInput | BookingUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVehicleInput | BookingUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVehicleInput | BookingUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InspectionSessionUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutVehicleInput, InspectionSessionUncheckedCreateWithoutVehicleInput> | InspectionSessionCreateWithoutVehicleInput[] | InspectionSessionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutVehicleInput | InspectionSessionCreateOrConnectWithoutVehicleInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutVehicleInput | InspectionSessionUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: InspectionSessionCreateManyVehicleInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutVehicleInput | InspectionSessionUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutVehicleInput | InspectionSessionUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ReferralCreateWithoutVehicleInput, ReferralUncheckedCreateWithoutVehicleInput> | ReferralCreateWithoutVehicleInput[] | ReferralUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutVehicleInput | ReferralCreateOrConnectWithoutVehicleInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutVehicleInput | ReferralUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ReferralCreateManyVehicleInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutVehicleInput | ReferralUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutVehicleInput | ReferralUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVehicleInput | BookingUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVehicleInput | BookingUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVehicleInput | BookingUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InspectionSessionUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutVehicleInput, InspectionSessionUncheckedCreateWithoutVehicleInput> | InspectionSessionCreateWithoutVehicleInput[] | InspectionSessionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutVehicleInput | InspectionSessionCreateOrConnectWithoutVehicleInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutVehicleInput | InspectionSessionUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: InspectionSessionCreateManyVehicleInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutVehicleInput | InspectionSessionUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutVehicleInput | InspectionSessionUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ReferralCreateWithoutVehicleInput, ReferralUncheckedCreateWithoutVehicleInput> | ReferralCreateWithoutVehicleInput[] | ReferralUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutVehicleInput | ReferralCreateOrConnectWithoutVehicleInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutVehicleInput | ReferralUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ReferralCreateManyVehicleInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutVehicleInput | ReferralUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutVehicleInput | ReferralUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBookingsInput
    connect?: TenantWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    connect?: VehicleWhereUniqueInput
  }

  export type InspectionSessionCreateNestedManyWithoutBookingInput = {
    create?: XOR<InspectionSessionCreateWithoutBookingInput, InspectionSessionUncheckedCreateWithoutBookingInput> | InspectionSessionCreateWithoutBookingInput[] | InspectionSessionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutBookingInput | InspectionSessionCreateOrConnectWithoutBookingInput[]
    createMany?: InspectionSessionCreateManyBookingInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type InspectionSessionUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<InspectionSessionCreateWithoutBookingInput, InspectionSessionUncheckedCreateWithoutBookingInput> | InspectionSessionCreateWithoutBookingInput[] | InspectionSessionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutBookingInput | InspectionSessionCreateOrConnectWithoutBookingInput[]
    createMany?: InspectionSessionCreateManyBookingInputEnvelope
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type TenantUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBookingsInput
    upsert?: TenantUpsertWithoutBookingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBookingsInput, TenantUpdateWithoutBookingsInput>, TenantUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    upsert?: VehicleUpsertWithoutBookingsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutBookingsInput, VehicleUpdateWithoutBookingsInput>, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type InspectionSessionUpdateManyWithoutBookingNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutBookingInput, InspectionSessionUncheckedCreateWithoutBookingInput> | InspectionSessionCreateWithoutBookingInput[] | InspectionSessionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutBookingInput | InspectionSessionCreateOrConnectWithoutBookingInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutBookingInput | InspectionSessionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: InspectionSessionCreateManyBookingInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutBookingInput | InspectionSessionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutBookingInput | InspectionSessionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type InspectionSessionUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutBookingInput, InspectionSessionUncheckedCreateWithoutBookingInput> | InspectionSessionCreateWithoutBookingInput[] | InspectionSessionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutBookingInput | InspectionSessionCreateOrConnectWithoutBookingInput[]
    upsert?: InspectionSessionUpsertWithWhereUniqueWithoutBookingInput | InspectionSessionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: InspectionSessionCreateManyBookingInputEnvelope
    set?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    disconnect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    delete?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    connect?: InspectionSessionWhereUniqueInput | InspectionSessionWhereUniqueInput[]
    update?: InspectionSessionUpdateWithWhereUniqueWithoutBookingInput | InspectionSessionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: InspectionSessionUpdateManyWithWhereWithoutBookingInput | InspectionSessionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
  }

  export type InspectionResultCreateNestedManyWithoutItemInput = {
    create?: XOR<InspectionResultCreateWithoutItemInput, InspectionResultUncheckedCreateWithoutItemInput> | InspectionResultCreateWithoutItemInput[] | InspectionResultUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutItemInput | InspectionResultCreateOrConnectWithoutItemInput[]
    createMany?: InspectionResultCreateManyItemInputEnvelope
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
  }

  export type InspectionResultUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InspectionResultCreateWithoutItemInput, InspectionResultUncheckedCreateWithoutItemInput> | InspectionResultCreateWithoutItemInput[] | InspectionResultUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutItemInput | InspectionResultCreateOrConnectWithoutItemInput[]
    createMany?: InspectionResultCreateManyItemInputEnvelope
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
  }

  export type EnumItemGroupFieldUpdateOperationsInput = {
    set?: $Enums.ItemGroup
  }

  export type InspectionResultUpdateManyWithoutItemNestedInput = {
    create?: XOR<InspectionResultCreateWithoutItemInput, InspectionResultUncheckedCreateWithoutItemInput> | InspectionResultCreateWithoutItemInput[] | InspectionResultUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutItemInput | InspectionResultCreateOrConnectWithoutItemInput[]
    upsert?: InspectionResultUpsertWithWhereUniqueWithoutItemInput | InspectionResultUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InspectionResultCreateManyItemInputEnvelope
    set?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    disconnect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    delete?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    update?: InspectionResultUpdateWithWhereUniqueWithoutItemInput | InspectionResultUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InspectionResultUpdateManyWithWhereWithoutItemInput | InspectionResultUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InspectionResultScalarWhereInput | InspectionResultScalarWhereInput[]
  }

  export type InspectionResultUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InspectionResultCreateWithoutItemInput, InspectionResultUncheckedCreateWithoutItemInput> | InspectionResultCreateWithoutItemInput[] | InspectionResultUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutItemInput | InspectionResultCreateOrConnectWithoutItemInput[]
    upsert?: InspectionResultUpsertWithWhereUniqueWithoutItemInput | InspectionResultUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InspectionResultCreateManyItemInputEnvelope
    set?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    disconnect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    delete?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    update?: InspectionResultUpdateWithWhereUniqueWithoutItemInput | InspectionResultUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InspectionResultUpdateManyWithWhereWithoutItemInput | InspectionResultUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InspectionResultScalarWhereInput | InspectionResultScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSessionsInput
    connect?: TenantWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutSessionsInput = {
    create?: XOR<VehicleCreateWithoutSessionsInput, VehicleUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSessionsInput
    connect?: VehicleWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutSessionsInput = {
    create?: XOR<BookingCreateWithoutSessionsInput, BookingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutSessionsInput
    connect?: BookingWhereUniqueInput
  }

  export type InspectorCreateNestedOneWithoutSessionsInput = {
    create?: XOR<InspectorCreateWithoutSessionsInput, InspectorUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: InspectorCreateOrConnectWithoutSessionsInput
    connect?: InspectorWhereUniqueInput
  }

  export type CertificateCreateNestedOneWithoutSessionInput = {
    create?: XOR<CertificateCreateWithoutSessionInput, CertificateUncheckedCreateWithoutSessionInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutSessionInput
    connect?: CertificateWhereUniqueInput
  }

  export type InspectionResultCreateNestedManyWithoutSessionInput = {
    create?: XOR<InspectionResultCreateWithoutSessionInput, InspectionResultUncheckedCreateWithoutSessionInput> | InspectionResultCreateWithoutSessionInput[] | InspectionResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutSessionInput | InspectionResultCreateOrConnectWithoutSessionInput[]
    createMany?: InspectionResultCreateManySessionInputEnvelope
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
  }

  export type MediaRefCreateNestedManyWithoutSessionInput = {
    create?: XOR<MediaRefCreateWithoutSessionInput, MediaRefUncheckedCreateWithoutSessionInput> | MediaRefCreateWithoutSessionInput[] | MediaRefUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MediaRefCreateOrConnectWithoutSessionInput | MediaRefCreateOrConnectWithoutSessionInput[]
    createMany?: MediaRefCreateManySessionInputEnvelope
    connect?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
  }

  export type ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput = {
    create?: XOR<ReinspectionLinkCreateWithoutOriginalSessionInput, ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput> | ReinspectionLinkCreateWithoutOriginalSessionInput[] | ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput[]
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput | ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput[]
    createMany?: ReinspectionLinkCreateManyOriginalSessionInputEnvelope
    connect?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
  }

  export type ReinspectionLinkCreateNestedOneWithoutNewSessionInput = {
    create?: XOR<ReinspectionLinkCreateWithoutNewSessionInput, ReinspectionLinkUncheckedCreateWithoutNewSessionInput>
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutNewSessionInput
    connect?: ReinspectionLinkWhereUniqueInput
  }

  export type ReferralCreateNestedManyWithoutSessionInput = {
    create?: XOR<ReferralCreateWithoutSessionInput, ReferralUncheckedCreateWithoutSessionInput> | ReferralCreateWithoutSessionInput[] | ReferralUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutSessionInput | ReferralCreateOrConnectWithoutSessionInput[]
    createMany?: ReferralCreateManySessionInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<CertificateCreateWithoutSessionInput, CertificateUncheckedCreateWithoutSessionInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutSessionInput
    connect?: CertificateWhereUniqueInput
  }

  export type InspectionResultUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<InspectionResultCreateWithoutSessionInput, InspectionResultUncheckedCreateWithoutSessionInput> | InspectionResultCreateWithoutSessionInput[] | InspectionResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutSessionInput | InspectionResultCreateOrConnectWithoutSessionInput[]
    createMany?: InspectionResultCreateManySessionInputEnvelope
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
  }

  export type MediaRefUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<MediaRefCreateWithoutSessionInput, MediaRefUncheckedCreateWithoutSessionInput> | MediaRefCreateWithoutSessionInput[] | MediaRefUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MediaRefCreateOrConnectWithoutSessionInput | MediaRefCreateOrConnectWithoutSessionInput[]
    createMany?: MediaRefCreateManySessionInputEnvelope
    connect?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
  }

  export type ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput = {
    create?: XOR<ReinspectionLinkCreateWithoutOriginalSessionInput, ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput> | ReinspectionLinkCreateWithoutOriginalSessionInput[] | ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput[]
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput | ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput[]
    createMany?: ReinspectionLinkCreateManyOriginalSessionInputEnvelope
    connect?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
  }

  export type ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput = {
    create?: XOR<ReinspectionLinkCreateWithoutNewSessionInput, ReinspectionLinkUncheckedCreateWithoutNewSessionInput>
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutNewSessionInput
    connect?: ReinspectionLinkWhereUniqueInput
  }

  export type ReferralUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ReferralCreateWithoutSessionInput, ReferralUncheckedCreateWithoutSessionInput> | ReferralCreateWithoutSessionInput[] | ReferralUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutSessionInput | ReferralCreateOrConnectWithoutSessionInput[]
    createMany?: ReferralCreateManySessionInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type EnumInspectionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InspectionType
  }

  export type EnumInspectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InspectionStatus
  }

  export type EnumDefectSeverityFieldUpdateOperationsInput = {
    set?: $Enums.DefectSeverity
  }

  export type TenantUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSessionsInput
    upsert?: TenantUpsertWithoutSessionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSessionsInput, TenantUpdateWithoutSessionsInput>, TenantUncheckedUpdateWithoutSessionsInput>
  }

  export type VehicleUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<VehicleCreateWithoutSessionsInput, VehicleUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutSessionsInput
    upsert?: VehicleUpsertWithoutSessionsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutSessionsInput, VehicleUpdateWithoutSessionsInput>, VehicleUncheckedUpdateWithoutSessionsInput>
  }

  export type BookingUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<BookingCreateWithoutSessionsInput, BookingUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutSessionsInput
    upsert?: BookingUpsertWithoutSessionsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutSessionsInput, BookingUpdateWithoutSessionsInput>, BookingUncheckedUpdateWithoutSessionsInput>
  }

  export type InspectorUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<InspectorCreateWithoutSessionsInput, InspectorUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: InspectorCreateOrConnectWithoutSessionsInput
    upsert?: InspectorUpsertWithoutSessionsInput
    disconnect?: InspectorWhereInput | boolean
    delete?: InspectorWhereInput | boolean
    connect?: InspectorWhereUniqueInput
    update?: XOR<XOR<InspectorUpdateToOneWithWhereWithoutSessionsInput, InspectorUpdateWithoutSessionsInput>, InspectorUncheckedUpdateWithoutSessionsInput>
  }

  export type CertificateUpdateOneWithoutSessionNestedInput = {
    create?: XOR<CertificateCreateWithoutSessionInput, CertificateUncheckedCreateWithoutSessionInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutSessionInput
    upsert?: CertificateUpsertWithoutSessionInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutSessionInput, CertificateUpdateWithoutSessionInput>, CertificateUncheckedUpdateWithoutSessionInput>
  }

  export type InspectionResultUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InspectionResultCreateWithoutSessionInput, InspectionResultUncheckedCreateWithoutSessionInput> | InspectionResultCreateWithoutSessionInput[] | InspectionResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutSessionInput | InspectionResultCreateOrConnectWithoutSessionInput[]
    upsert?: InspectionResultUpsertWithWhereUniqueWithoutSessionInput | InspectionResultUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InspectionResultCreateManySessionInputEnvelope
    set?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    disconnect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    delete?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    update?: InspectionResultUpdateWithWhereUniqueWithoutSessionInput | InspectionResultUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InspectionResultUpdateManyWithWhereWithoutSessionInput | InspectionResultUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InspectionResultScalarWhereInput | InspectionResultScalarWhereInput[]
  }

  export type MediaRefUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MediaRefCreateWithoutSessionInput, MediaRefUncheckedCreateWithoutSessionInput> | MediaRefCreateWithoutSessionInput[] | MediaRefUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MediaRefCreateOrConnectWithoutSessionInput | MediaRefCreateOrConnectWithoutSessionInput[]
    upsert?: MediaRefUpsertWithWhereUniqueWithoutSessionInput | MediaRefUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MediaRefCreateManySessionInputEnvelope
    set?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    disconnect?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    delete?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    connect?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    update?: MediaRefUpdateWithWhereUniqueWithoutSessionInput | MediaRefUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MediaRefUpdateManyWithWhereWithoutSessionInput | MediaRefUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MediaRefScalarWhereInput | MediaRefScalarWhereInput[]
  }

  export type ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput = {
    create?: XOR<ReinspectionLinkCreateWithoutOriginalSessionInput, ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput> | ReinspectionLinkCreateWithoutOriginalSessionInput[] | ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput[]
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput | ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput[]
    upsert?: ReinspectionLinkUpsertWithWhereUniqueWithoutOriginalSessionInput | ReinspectionLinkUpsertWithWhereUniqueWithoutOriginalSessionInput[]
    createMany?: ReinspectionLinkCreateManyOriginalSessionInputEnvelope
    set?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    disconnect?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    delete?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    connect?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    update?: ReinspectionLinkUpdateWithWhereUniqueWithoutOriginalSessionInput | ReinspectionLinkUpdateWithWhereUniqueWithoutOriginalSessionInput[]
    updateMany?: ReinspectionLinkUpdateManyWithWhereWithoutOriginalSessionInput | ReinspectionLinkUpdateManyWithWhereWithoutOriginalSessionInput[]
    deleteMany?: ReinspectionLinkScalarWhereInput | ReinspectionLinkScalarWhereInput[]
  }

  export type ReinspectionLinkUpdateOneWithoutNewSessionNestedInput = {
    create?: XOR<ReinspectionLinkCreateWithoutNewSessionInput, ReinspectionLinkUncheckedCreateWithoutNewSessionInput>
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutNewSessionInput
    upsert?: ReinspectionLinkUpsertWithoutNewSessionInput
    disconnect?: ReinspectionLinkWhereInput | boolean
    delete?: ReinspectionLinkWhereInput | boolean
    connect?: ReinspectionLinkWhereUniqueInput
    update?: XOR<XOR<ReinspectionLinkUpdateToOneWithWhereWithoutNewSessionInput, ReinspectionLinkUpdateWithoutNewSessionInput>, ReinspectionLinkUncheckedUpdateWithoutNewSessionInput>
  }

  export type ReferralUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ReferralCreateWithoutSessionInput, ReferralUncheckedCreateWithoutSessionInput> | ReferralCreateWithoutSessionInput[] | ReferralUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutSessionInput | ReferralCreateOrConnectWithoutSessionInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutSessionInput | ReferralUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ReferralCreateManySessionInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutSessionInput | ReferralUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutSessionInput | ReferralUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<CertificateCreateWithoutSessionInput, CertificateUncheckedCreateWithoutSessionInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutSessionInput
    upsert?: CertificateUpsertWithoutSessionInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutSessionInput, CertificateUpdateWithoutSessionInput>, CertificateUncheckedUpdateWithoutSessionInput>
  }

  export type InspectionResultUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InspectionResultCreateWithoutSessionInput, InspectionResultUncheckedCreateWithoutSessionInput> | InspectionResultCreateWithoutSessionInput[] | InspectionResultUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InspectionResultCreateOrConnectWithoutSessionInput | InspectionResultCreateOrConnectWithoutSessionInput[]
    upsert?: InspectionResultUpsertWithWhereUniqueWithoutSessionInput | InspectionResultUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InspectionResultCreateManySessionInputEnvelope
    set?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    disconnect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    delete?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    connect?: InspectionResultWhereUniqueInput | InspectionResultWhereUniqueInput[]
    update?: InspectionResultUpdateWithWhereUniqueWithoutSessionInput | InspectionResultUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InspectionResultUpdateManyWithWhereWithoutSessionInput | InspectionResultUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InspectionResultScalarWhereInput | InspectionResultScalarWhereInput[]
  }

  export type MediaRefUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MediaRefCreateWithoutSessionInput, MediaRefUncheckedCreateWithoutSessionInput> | MediaRefCreateWithoutSessionInput[] | MediaRefUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MediaRefCreateOrConnectWithoutSessionInput | MediaRefCreateOrConnectWithoutSessionInput[]
    upsert?: MediaRefUpsertWithWhereUniqueWithoutSessionInput | MediaRefUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MediaRefCreateManySessionInputEnvelope
    set?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    disconnect?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    delete?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    connect?: MediaRefWhereUniqueInput | MediaRefWhereUniqueInput[]
    update?: MediaRefUpdateWithWhereUniqueWithoutSessionInput | MediaRefUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MediaRefUpdateManyWithWhereWithoutSessionInput | MediaRefUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MediaRefScalarWhereInput | MediaRefScalarWhereInput[]
  }

  export type ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput = {
    create?: XOR<ReinspectionLinkCreateWithoutOriginalSessionInput, ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput> | ReinspectionLinkCreateWithoutOriginalSessionInput[] | ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput[]
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput | ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput[]
    upsert?: ReinspectionLinkUpsertWithWhereUniqueWithoutOriginalSessionInput | ReinspectionLinkUpsertWithWhereUniqueWithoutOriginalSessionInput[]
    createMany?: ReinspectionLinkCreateManyOriginalSessionInputEnvelope
    set?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    disconnect?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    delete?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    connect?: ReinspectionLinkWhereUniqueInput | ReinspectionLinkWhereUniqueInput[]
    update?: ReinspectionLinkUpdateWithWhereUniqueWithoutOriginalSessionInput | ReinspectionLinkUpdateWithWhereUniqueWithoutOriginalSessionInput[]
    updateMany?: ReinspectionLinkUpdateManyWithWhereWithoutOriginalSessionInput | ReinspectionLinkUpdateManyWithWhereWithoutOriginalSessionInput[]
    deleteMany?: ReinspectionLinkScalarWhereInput | ReinspectionLinkScalarWhereInput[]
  }

  export type ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput = {
    create?: XOR<ReinspectionLinkCreateWithoutNewSessionInput, ReinspectionLinkUncheckedCreateWithoutNewSessionInput>
    connectOrCreate?: ReinspectionLinkCreateOrConnectWithoutNewSessionInput
    upsert?: ReinspectionLinkUpsertWithoutNewSessionInput
    disconnect?: ReinspectionLinkWhereInput | boolean
    delete?: ReinspectionLinkWhereInput | boolean
    connect?: ReinspectionLinkWhereUniqueInput
    update?: XOR<XOR<ReinspectionLinkUpdateToOneWithWhereWithoutNewSessionInput, ReinspectionLinkUpdateWithoutNewSessionInput>, ReinspectionLinkUncheckedUpdateWithoutNewSessionInput>
  }

  export type ReferralUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ReferralCreateWithoutSessionInput, ReferralUncheckedCreateWithoutSessionInput> | ReferralCreateWithoutSessionInput[] | ReferralUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutSessionInput | ReferralCreateOrConnectWithoutSessionInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutSessionInput | ReferralUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ReferralCreateManySessionInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutSessionInput | ReferralUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutSessionInput | ReferralUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type InspectionSessionCreateNestedOneWithoutResultsInput = {
    create?: XOR<InspectionSessionCreateWithoutResultsInput, InspectionSessionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutResultsInput
    connect?: InspectionSessionWhereUniqueInput
  }

  export type InspectionItemCreateNestedOneWithoutResultsInput = {
    create?: XOR<InspectionItemCreateWithoutResultsInput, InspectionItemUncheckedCreateWithoutResultsInput>
    connectOrCreate?: InspectionItemCreateOrConnectWithoutResultsInput
    connect?: InspectionItemWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumResultSeverityFieldUpdateOperationsInput = {
    set?: $Enums.ResultSeverity
  }

  export type InspectionSessionUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutResultsInput, InspectionSessionUncheckedCreateWithoutResultsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutResultsInput
    upsert?: InspectionSessionUpsertWithoutResultsInput
    connect?: InspectionSessionWhereUniqueInput
    update?: XOR<XOR<InspectionSessionUpdateToOneWithWhereWithoutResultsInput, InspectionSessionUpdateWithoutResultsInput>, InspectionSessionUncheckedUpdateWithoutResultsInput>
  }

  export type InspectionItemUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<InspectionItemCreateWithoutResultsInput, InspectionItemUncheckedCreateWithoutResultsInput>
    connectOrCreate?: InspectionItemCreateOrConnectWithoutResultsInput
    upsert?: InspectionItemUpsertWithoutResultsInput
    connect?: InspectionItemWhereUniqueInput
    update?: XOR<XOR<InspectionItemUpdateToOneWithWhereWithoutResultsInput, InspectionItemUpdateWithoutResultsInput>, InspectionItemUncheckedUpdateWithoutResultsInput>
  }

  export type InspectionSessionCreateNestedOneWithoutCertificateInput = {
    create?: XOR<InspectionSessionCreateWithoutCertificateInput, InspectionSessionUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutCertificateInput
    connect?: InspectionSessionWhereUniqueInput
  }

  export type InspectionSessionUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutCertificateInput, InspectionSessionUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutCertificateInput
    upsert?: InspectionSessionUpsertWithoutCertificateInput
    connect?: InspectionSessionWhereUniqueInput
    update?: XOR<XOR<InspectionSessionUpdateToOneWithWhereWithoutCertificateInput, InspectionSessionUpdateWithoutCertificateInput>, InspectionSessionUncheckedUpdateWithoutCertificateInput>
  }

  export type InspectionSessionCreateNestedOneWithoutOriginalReinspectionsInput = {
    create?: XOR<InspectionSessionCreateWithoutOriginalReinspectionsInput, InspectionSessionUncheckedCreateWithoutOriginalReinspectionsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutOriginalReinspectionsInput
    connect?: InspectionSessionWhereUniqueInput
  }

  export type InspectionSessionCreateNestedOneWithoutNewReinspectionInput = {
    create?: XOR<InspectionSessionCreateWithoutNewReinspectionInput, InspectionSessionUncheckedCreateWithoutNewReinspectionInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutNewReinspectionInput
    connect?: InspectionSessionWhereUniqueInput
  }

  export type InspectionSessionUpdateOneRequiredWithoutOriginalReinspectionsNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutOriginalReinspectionsInput, InspectionSessionUncheckedCreateWithoutOriginalReinspectionsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutOriginalReinspectionsInput
    upsert?: InspectionSessionUpsertWithoutOriginalReinspectionsInput
    connect?: InspectionSessionWhereUniqueInput
    update?: XOR<XOR<InspectionSessionUpdateToOneWithWhereWithoutOriginalReinspectionsInput, InspectionSessionUpdateWithoutOriginalReinspectionsInput>, InspectionSessionUncheckedUpdateWithoutOriginalReinspectionsInput>
  }

  export type InspectionSessionUpdateOneRequiredWithoutNewReinspectionNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutNewReinspectionInput, InspectionSessionUncheckedCreateWithoutNewReinspectionInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutNewReinspectionInput
    upsert?: InspectionSessionUpsertWithoutNewReinspectionInput
    connect?: InspectionSessionWhereUniqueInput
    update?: XOR<XOR<InspectionSessionUpdateToOneWithWhereWithoutNewReinspectionInput, InspectionSessionUpdateWithoutNewReinspectionInput>, InspectionSessionUncheckedUpdateWithoutNewReinspectionInput>
  }

  export type InspectionSessionCreateNestedOneWithoutMediaRefsInput = {
    create?: XOR<InspectionSessionCreateWithoutMediaRefsInput, InspectionSessionUncheckedCreateWithoutMediaRefsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutMediaRefsInput
    connect?: InspectionSessionWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type InspectionSessionUpdateOneRequiredWithoutMediaRefsNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutMediaRefsInput, InspectionSessionUncheckedCreateWithoutMediaRefsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutMediaRefsInput
    upsert?: InspectionSessionUpsertWithoutMediaRefsInput
    connect?: InspectionSessionWhereUniqueInput
    update?: XOR<XOR<InspectionSessionUpdateToOneWithWhereWithoutMediaRefsInput, InspectionSessionUpdateWithoutMediaRefsInput>, InspectionSessionUncheckedUpdateWithoutMediaRefsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type InsurerUserCreateNestedManyWithoutInsurerInput = {
    create?: XOR<InsurerUserCreateWithoutInsurerInput, InsurerUserUncheckedCreateWithoutInsurerInput> | InsurerUserCreateWithoutInsurerInput[] | InsurerUserUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: InsurerUserCreateOrConnectWithoutInsurerInput | InsurerUserCreateOrConnectWithoutInsurerInput[]
    createMany?: InsurerUserCreateManyInsurerInputEnvelope
    connect?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutInsurerInput = {
    create?: XOR<ApiKeyCreateWithoutInsurerInput, ApiKeyUncheckedCreateWithoutInsurerInput> | ApiKeyCreateWithoutInsurerInput[] | ApiKeyUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutInsurerInput | ApiKeyCreateOrConnectWithoutInsurerInput[]
    createMany?: ApiKeyCreateManyInsurerInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ApiUsageLogCreateNestedManyWithoutInsurerInput = {
    create?: XOR<ApiUsageLogCreateWithoutInsurerInput, ApiUsageLogUncheckedCreateWithoutInsurerInput> | ApiUsageLogCreateWithoutInsurerInput[] | ApiUsageLogUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutInsurerInput | ApiUsageLogCreateOrConnectWithoutInsurerInput[]
    createMany?: ApiUsageLogCreateManyInsurerInputEnvelope
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutInsurerInput = {
    create?: XOR<AgentCreateWithoutInsurerInput, AgentUncheckedCreateWithoutInsurerInput> | AgentCreateWithoutInsurerInput[] | AgentUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutInsurerInput | AgentCreateOrConnectWithoutInsurerInput[]
    createMany?: AgentCreateManyInsurerInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type InsurerUserUncheckedCreateNestedManyWithoutInsurerInput = {
    create?: XOR<InsurerUserCreateWithoutInsurerInput, InsurerUserUncheckedCreateWithoutInsurerInput> | InsurerUserCreateWithoutInsurerInput[] | InsurerUserUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: InsurerUserCreateOrConnectWithoutInsurerInput | InsurerUserCreateOrConnectWithoutInsurerInput[]
    createMany?: InsurerUserCreateManyInsurerInputEnvelope
    connect?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutInsurerInput = {
    create?: XOR<ApiKeyCreateWithoutInsurerInput, ApiKeyUncheckedCreateWithoutInsurerInput> | ApiKeyCreateWithoutInsurerInput[] | ApiKeyUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutInsurerInput | ApiKeyCreateOrConnectWithoutInsurerInput[]
    createMany?: ApiKeyCreateManyInsurerInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ApiUsageLogUncheckedCreateNestedManyWithoutInsurerInput = {
    create?: XOR<ApiUsageLogCreateWithoutInsurerInput, ApiUsageLogUncheckedCreateWithoutInsurerInput> | ApiUsageLogCreateWithoutInsurerInput[] | ApiUsageLogUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutInsurerInput | ApiUsageLogCreateOrConnectWithoutInsurerInput[]
    createMany?: ApiUsageLogCreateManyInsurerInputEnvelope
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutInsurerInput = {
    create?: XOR<AgentCreateWithoutInsurerInput, AgentUncheckedCreateWithoutInsurerInput> | AgentCreateWithoutInsurerInput[] | AgentUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutInsurerInput | AgentCreateOrConnectWithoutInsurerInput[]
    createMany?: AgentCreateManyInsurerInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type EnumInsurerStatusFieldUpdateOperationsInput = {
    set?: $Enums.InsurerStatus
  }

  export type InsurerUserUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<InsurerUserCreateWithoutInsurerInput, InsurerUserUncheckedCreateWithoutInsurerInput> | InsurerUserCreateWithoutInsurerInput[] | InsurerUserUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: InsurerUserCreateOrConnectWithoutInsurerInput | InsurerUserCreateOrConnectWithoutInsurerInput[]
    upsert?: InsurerUserUpsertWithWhereUniqueWithoutInsurerInput | InsurerUserUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: InsurerUserCreateManyInsurerInputEnvelope
    set?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    disconnect?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    delete?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    connect?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    update?: InsurerUserUpdateWithWhereUniqueWithoutInsurerInput | InsurerUserUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: InsurerUserUpdateManyWithWhereWithoutInsurerInput | InsurerUserUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: InsurerUserScalarWhereInput | InsurerUserScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<ApiKeyCreateWithoutInsurerInput, ApiKeyUncheckedCreateWithoutInsurerInput> | ApiKeyCreateWithoutInsurerInput[] | ApiKeyUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutInsurerInput | ApiKeyCreateOrConnectWithoutInsurerInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutInsurerInput | ApiKeyUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: ApiKeyCreateManyInsurerInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutInsurerInput | ApiKeyUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutInsurerInput | ApiKeyUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ApiUsageLogUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<ApiUsageLogCreateWithoutInsurerInput, ApiUsageLogUncheckedCreateWithoutInsurerInput> | ApiUsageLogCreateWithoutInsurerInput[] | ApiUsageLogUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutInsurerInput | ApiUsageLogCreateOrConnectWithoutInsurerInput[]
    upsert?: ApiUsageLogUpsertWithWhereUniqueWithoutInsurerInput | ApiUsageLogUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: ApiUsageLogCreateManyInsurerInputEnvelope
    set?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    disconnect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    delete?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    update?: ApiUsageLogUpdateWithWhereUniqueWithoutInsurerInput | ApiUsageLogUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: ApiUsageLogUpdateManyWithWhereWithoutInsurerInput | ApiUsageLogUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<AgentCreateWithoutInsurerInput, AgentUncheckedCreateWithoutInsurerInput> | AgentCreateWithoutInsurerInput[] | AgentUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutInsurerInput | AgentCreateOrConnectWithoutInsurerInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutInsurerInput | AgentUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: AgentCreateManyInsurerInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutInsurerInput | AgentUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutInsurerInput | AgentUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type InsurerUserUncheckedUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<InsurerUserCreateWithoutInsurerInput, InsurerUserUncheckedCreateWithoutInsurerInput> | InsurerUserCreateWithoutInsurerInput[] | InsurerUserUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: InsurerUserCreateOrConnectWithoutInsurerInput | InsurerUserCreateOrConnectWithoutInsurerInput[]
    upsert?: InsurerUserUpsertWithWhereUniqueWithoutInsurerInput | InsurerUserUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: InsurerUserCreateManyInsurerInputEnvelope
    set?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    disconnect?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    delete?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    connect?: InsurerUserWhereUniqueInput | InsurerUserWhereUniqueInput[]
    update?: InsurerUserUpdateWithWhereUniqueWithoutInsurerInput | InsurerUserUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: InsurerUserUpdateManyWithWhereWithoutInsurerInput | InsurerUserUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: InsurerUserScalarWhereInput | InsurerUserScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<ApiKeyCreateWithoutInsurerInput, ApiKeyUncheckedCreateWithoutInsurerInput> | ApiKeyCreateWithoutInsurerInput[] | ApiKeyUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutInsurerInput | ApiKeyCreateOrConnectWithoutInsurerInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutInsurerInput | ApiKeyUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: ApiKeyCreateManyInsurerInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutInsurerInput | ApiKeyUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutInsurerInput | ApiKeyUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type ApiUsageLogUncheckedUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<ApiUsageLogCreateWithoutInsurerInput, ApiUsageLogUncheckedCreateWithoutInsurerInput> | ApiUsageLogCreateWithoutInsurerInput[] | ApiUsageLogUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: ApiUsageLogCreateOrConnectWithoutInsurerInput | ApiUsageLogCreateOrConnectWithoutInsurerInput[]
    upsert?: ApiUsageLogUpsertWithWhereUniqueWithoutInsurerInput | ApiUsageLogUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: ApiUsageLogCreateManyInsurerInputEnvelope
    set?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    disconnect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    delete?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    connect?: ApiUsageLogWhereUniqueInput | ApiUsageLogWhereUniqueInput[]
    update?: ApiUsageLogUpdateWithWhereUniqueWithoutInsurerInput | ApiUsageLogUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: ApiUsageLogUpdateManyWithWhereWithoutInsurerInput | ApiUsageLogUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutInsurerNestedInput = {
    create?: XOR<AgentCreateWithoutInsurerInput, AgentUncheckedCreateWithoutInsurerInput> | AgentCreateWithoutInsurerInput[] | AgentUncheckedCreateWithoutInsurerInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutInsurerInput | AgentCreateOrConnectWithoutInsurerInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutInsurerInput | AgentUpsertWithWhereUniqueWithoutInsurerInput[]
    createMany?: AgentCreateManyInsurerInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutInsurerInput | AgentUpdateWithWhereUniqueWithoutInsurerInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutInsurerInput | AgentUpdateManyWithWhereWithoutInsurerInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type InsurerCreateNestedOneWithoutUsersInput = {
    create?: XOR<InsurerCreateWithoutUsersInput, InsurerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutUsersInput
    connect?: InsurerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInsurerUserInput = {
    create?: XOR<UserCreateWithoutInsurerUserInput, UserUncheckedCreateWithoutInsurerUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsurerUserInput
    connect?: UserWhereUniqueInput
  }

  export type InsurerUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<InsurerCreateWithoutUsersInput, InsurerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutUsersInput
    upsert?: InsurerUpsertWithoutUsersInput
    connect?: InsurerWhereUniqueInput
    update?: XOR<XOR<InsurerUpdateToOneWithWhereWithoutUsersInput, InsurerUpdateWithoutUsersInput>, InsurerUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutInsurerUserNestedInput = {
    create?: XOR<UserCreateWithoutInsurerUserInput, UserUncheckedCreateWithoutInsurerUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsurerUserInput
    upsert?: UserUpsertWithoutInsurerUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsurerUserInput, UserUpdateWithoutInsurerUserInput>, UserUncheckedUpdateWithoutInsurerUserInput>
  }

  export type InsurerCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<InsurerCreateWithoutApiKeysInput, InsurerUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutApiKeysInput
    connect?: InsurerWhereUniqueInput
  }

  export type InsurerUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<InsurerCreateWithoutApiKeysInput, InsurerUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutApiKeysInput
    upsert?: InsurerUpsertWithoutApiKeysInput
    connect?: InsurerWhereUniqueInput
    update?: XOR<XOR<InsurerUpdateToOneWithWhereWithoutApiKeysInput, InsurerUpdateWithoutApiKeysInput>, InsurerUncheckedUpdateWithoutApiKeysInput>
  }

  export type InsurerCreateNestedOneWithoutApiUsageLogsInput = {
    create?: XOR<InsurerCreateWithoutApiUsageLogsInput, InsurerUncheckedCreateWithoutApiUsageLogsInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutApiUsageLogsInput
    connect?: InsurerWhereUniqueInput
  }

  export type InsurerUpdateOneRequiredWithoutApiUsageLogsNestedInput = {
    create?: XOR<InsurerCreateWithoutApiUsageLogsInput, InsurerUncheckedCreateWithoutApiUsageLogsInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutApiUsageLogsInput
    upsert?: InsurerUpsertWithoutApiUsageLogsInput
    connect?: InsurerWhereUniqueInput
    update?: XOR<XOR<InsurerUpdateToOneWithWhereWithoutApiUsageLogsInput, InsurerUpdateWithoutApiUsageLogsInput>, InsurerUncheckedUpdateWithoutApiUsageLogsInput>
  }

  export type UserCreateNestedOneWithoutAgentInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    connect?: UserWhereUniqueInput
  }

  export type InsurerCreateNestedOneWithoutAgentsInput = {
    create?: XOR<InsurerCreateWithoutAgentsInput, InsurerUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutAgentsInput
    connect?: InsurerWhereUniqueInput
  }

  export type ReferralCreateNestedManyWithoutAgentInput = {
    create?: XOR<ReferralCreateWithoutAgentInput, ReferralUncheckedCreateWithoutAgentInput> | ReferralCreateWithoutAgentInput[] | ReferralUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAgentInput | ReferralCreateOrConnectWithoutAgentInput[]
    createMany?: ReferralCreateManyAgentInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ReferralCreateWithoutAgentInput, ReferralUncheckedCreateWithoutAgentInput> | ReferralCreateWithoutAgentInput[] | ReferralUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAgentInput | ReferralCreateOrConnectWithoutAgentInput[]
    createMany?: ReferralCreateManyAgentInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAgentNestedInput = {
    create?: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgentInput
    upsert?: UserUpsertWithoutAgentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgentInput, UserUpdateWithoutAgentInput>, UserUncheckedUpdateWithoutAgentInput>
  }

  export type InsurerUpdateOneWithoutAgentsNestedInput = {
    create?: XOR<InsurerCreateWithoutAgentsInput, InsurerUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: InsurerCreateOrConnectWithoutAgentsInput
    upsert?: InsurerUpsertWithoutAgentsInput
    disconnect?: InsurerWhereInput | boolean
    delete?: InsurerWhereInput | boolean
    connect?: InsurerWhereUniqueInput
    update?: XOR<XOR<InsurerUpdateToOneWithWhereWithoutAgentsInput, InsurerUpdateWithoutAgentsInput>, InsurerUncheckedUpdateWithoutAgentsInput>
  }

  export type ReferralUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ReferralCreateWithoutAgentInput, ReferralUncheckedCreateWithoutAgentInput> | ReferralCreateWithoutAgentInput[] | ReferralUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAgentInput | ReferralCreateOrConnectWithoutAgentInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutAgentInput | ReferralUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ReferralCreateManyAgentInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutAgentInput | ReferralUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutAgentInput | ReferralUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ReferralCreateWithoutAgentInput, ReferralUncheckedCreateWithoutAgentInput> | ReferralCreateWithoutAgentInput[] | ReferralUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAgentInput | ReferralCreateOrConnectWithoutAgentInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutAgentInput | ReferralUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ReferralCreateManyAgentInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutAgentInput | ReferralUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutAgentInput | ReferralUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutReferralsInput = {
    create?: XOR<AgentCreateWithoutReferralsInput, AgentUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutReferralsInput
    connect?: AgentWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutReferralsInput = {
    create?: XOR<VehicleCreateWithoutReferralsInput, VehicleUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutReferralsInput
    connect?: VehicleWhereUniqueInput
  }

  export type InspectionSessionCreateNestedOneWithoutReferralsInput = {
    create?: XOR<InspectionSessionCreateWithoutReferralsInput, InspectionSessionUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutReferralsInput
    connect?: InspectionSessionWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<AgentCreateWithoutReferralsInput, AgentUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutReferralsInput
    upsert?: AgentUpsertWithoutReferralsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutReferralsInput, AgentUpdateWithoutReferralsInput>, AgentUncheckedUpdateWithoutReferralsInput>
  }

  export type VehicleUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<VehicleCreateWithoutReferralsInput, VehicleUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutReferralsInput
    upsert?: VehicleUpsertWithoutReferralsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutReferralsInput, VehicleUpdateWithoutReferralsInput>, VehicleUncheckedUpdateWithoutReferralsInput>
  }

  export type InspectionSessionUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<InspectionSessionCreateWithoutReferralsInput, InspectionSessionUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: InspectionSessionCreateOrConnectWithoutReferralsInput
    upsert?: InspectionSessionUpsertWithoutReferralsInput
    disconnect?: InspectionSessionWhereInput | boolean
    delete?: InspectionSessionWhereInput | boolean
    connect?: InspectionSessionWhereUniqueInput
    update?: XOR<XOR<InspectionSessionUpdateToOneWithWhereWithoutReferralsInput, InspectionSessionUpdateWithoutReferralsInput>, InspectionSessionUncheckedUpdateWithoutReferralsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumInspectorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectorStatus | EnumInspectorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectorStatusFilter<$PrismaModel> | $Enums.InspectorStatus
  }

  export type NestedEnumInspectorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectorStatus | EnumInspectorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectorStatus[] | ListEnumInspectorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectorStatusWithAggregatesFilter<$PrismaModel> | $Enums.InspectorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectorStatusFilter<$PrismaModel>
    _max?: NestedEnumInspectorStatusFilter<$PrismaModel>
  }

  export type NestedEnumVehicleCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleCategory | EnumVehicleCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleCategoryFilter<$PrismaModel> | $Enums.VehicleCategory
  }

  export type NestedEnumVehicleCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleCategory | EnumVehicleCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.VehicleCategory[] | ListEnumVehicleCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumVehicleCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VehicleCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleCategoryFilter<$PrismaModel>
    _max?: NestedEnumVehicleCategoryFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumItemGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemGroup | EnumItemGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumItemGroupFilter<$PrismaModel> | $Enums.ItemGroup
  }

  export type NestedEnumItemGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemGroup | EnumItemGroupFieldRefInput<$PrismaModel>
    in?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemGroup[] | ListEnumItemGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumItemGroupWithAggregatesFilter<$PrismaModel> | $Enums.ItemGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemGroupFilter<$PrismaModel>
    _max?: NestedEnumItemGroupFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumInspectionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionType | EnumInspectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionTypeFilter<$PrismaModel> | $Enums.InspectionType
  }

  export type NestedEnumInspectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusFilter<$PrismaModel> | $Enums.InspectionStatus
  }

  export type NestedEnumDefectSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityFilter<$PrismaModel> | $Enums.DefectSeverity
  }

  export type NestedEnumInspectionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionType | EnumInspectionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionType[] | ListEnumInspectionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InspectionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectionTypeFilter<$PrismaModel>
    _max?: NestedEnumInspectionTypeFilter<$PrismaModel>
  }

  export type NestedEnumInspectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InspectionStatus | EnumInspectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InspectionStatus[] | ListEnumInspectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInspectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InspectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInspectionStatusFilter<$PrismaModel>
    _max?: NestedEnumInspectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDefectSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DefectSeverity | EnumDefectSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DefectSeverity[] | ListEnumDefectSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumDefectSeverityWithAggregatesFilter<$PrismaModel> | $Enums.DefectSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDefectSeverityFilter<$PrismaModel>
    _max?: NestedEnumDefectSeverityFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumResultSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultSeverity | EnumResultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumResultSeverityFilter<$PrismaModel> | $Enums.ResultSeverity
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumResultSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultSeverity | EnumResultSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultSeverity[] | ListEnumResultSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumResultSeverityWithAggregatesFilter<$PrismaModel> | $Enums.ResultSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultSeverityFilter<$PrismaModel>
    _max?: NestedEnumResultSeverityFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsurerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsurerStatus | EnumInsurerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsurerStatusFilter<$PrismaModel> | $Enums.InsurerStatus
  }

  export type NestedEnumInsurerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsurerStatus | EnumInsurerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsurerStatus[] | ListEnumInsurerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsurerStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsurerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsurerStatusFilter<$PrismaModel>
    _max?: NestedEnumInsurerStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    inspector?: InspectorCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserCreateNestedOneWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: number
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    inspector?: InspectorUncheckedCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserUncheckedCreateNestedOneWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VehicleCreateWithoutTenantInput = {
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner?: OwnerCreateNestedOneWithoutVehiclesInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionCreateNestedManyWithoutVehicleInput
    referrals?: ReferralCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTenantInput = {
    id?: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutVehicleInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTenantInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput>
  }

  export type VehicleCreateManyTenantInputEnvelope = {
    data: VehicleCreateManyTenantInput | VehicleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutTenantInput = {
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
    sessions?: InspectionSessionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTenantInput = {
    id?: number
    vehicleId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTenantInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput>
  }

  export type BookingCreateManyTenantInputEnvelope = {
    data: BookingCreateManyTenantInput | BookingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InspectionSessionCreateWithoutTenantInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutTenantInput = {
    id?: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutTenantInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutTenantInput, InspectionSessionUncheckedCreateWithoutTenantInput>
  }

  export type InspectionSessionCreateManyTenantInputEnvelope = {
    data: InspectionSessionCreateManyTenantInput | InspectionSessionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: number
    actorUserId?: number | null
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    tenantId?: IntNullableFilter<"User"> | number | null
    fullName?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type VehicleUpsertWithWhereUniqueWithoutTenantInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutTenantInput, VehicleUncheckedUpdateWithoutTenantInput>
    create: XOR<VehicleCreateWithoutTenantInput, VehicleUncheckedCreateWithoutTenantInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutTenantInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutTenantInput, VehicleUncheckedUpdateWithoutTenantInput>
  }

  export type VehicleUpdateManyWithWhereWithoutTenantInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutTenantInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: IntFilter<"Vehicle"> | number
    tenantId?: IntFilter<"Vehicle"> | number
    ownerId?: IntNullableFilter<"Vehicle"> | number | null
    registrationNo?: StringFilter<"Vehicle"> | string
    vin?: StringNullableFilter<"Vehicle"> | string | null
    engineNo?: StringNullableFilter<"Vehicle"> | string | null
    make?: StringNullableFilter<"Vehicle"> | string | null
    model?: StringNullableFilter<"Vehicle"> | string | null
    yearOfMfg?: IntNullableFilter<"Vehicle"> | number | null
    category?: EnumVehicleCategoryFilter<"Vehicle"> | $Enums.VehicleCategory
    tareWeightKg?: IntNullableFilter<"Vehicle"> | number | null
    engineCc?: IntNullableFilter<"Vehicle"> | number | null
    evBatteryKwh?: IntNullableFilter<"Vehicle"> | number | null
    telematicsImei?: StringNullableFilter<"Vehicle"> | string | null
    speedGovernorSerial?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutTenantInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTenantInput, BookingUncheckedUpdateWithoutTenantInput>
    create: XOR<BookingCreateWithoutTenantInput, BookingUncheckedCreateWithoutTenantInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTenantInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTenantInput, BookingUncheckedUpdateWithoutTenantInput>
  }

  export type BookingUpdateManyWithWhereWithoutTenantInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTenantInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    tenantId?: IntFilter<"Booking"> | number
    vehicleId?: IntFilter<"Booking"> | number
    bookingRef?: StringNullableFilter<"Booking"> | string | null
    bookingFeePaid?: BoolFilter<"Booking"> | boolean
    bookingFeeReceiptNo?: StringNullableFilter<"Booking"> | string | null
    bookedForDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type InspectionSessionUpsertWithWhereUniqueWithoutTenantInput = {
    where: InspectionSessionWhereUniqueInput
    update: XOR<InspectionSessionUpdateWithoutTenantInput, InspectionSessionUncheckedUpdateWithoutTenantInput>
    create: XOR<InspectionSessionCreateWithoutTenantInput, InspectionSessionUncheckedCreateWithoutTenantInput>
  }

  export type InspectionSessionUpdateWithWhereUniqueWithoutTenantInput = {
    where: InspectionSessionWhereUniqueInput
    data: XOR<InspectionSessionUpdateWithoutTenantInput, InspectionSessionUncheckedUpdateWithoutTenantInput>
  }

  export type InspectionSessionUpdateManyWithWhereWithoutTenantInput = {
    where: InspectionSessionScalarWhereInput
    data: XOR<InspectionSessionUpdateManyMutationInput, InspectionSessionUncheckedUpdateManyWithoutTenantInput>
  }

  export type InspectionSessionScalarWhereInput = {
    AND?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
    OR?: InspectionSessionScalarWhereInput[]
    NOT?: InspectionSessionScalarWhereInput | InspectionSessionScalarWhereInput[]
    id?: IntFilter<"InspectionSession"> | number
    tenantId?: IntFilter<"InspectionSession"> | number
    vehicleId?: IntFilter<"InspectionSession"> | number
    bookingId?: IntNullableFilter<"InspectionSession"> | number | null
    inspectorId?: IntNullableFilter<"InspectionSession"> | number | null
    inspectedAt?: DateTimeNullableFilter<"InspectionSession"> | Date | string | null
    inspectionType?: EnumInspectionTypeFilter<"InspectionSession"> | $Enums.InspectionType
    odometerKm?: IntNullableFilter<"InspectionSession"> | number | null
    notes?: StringNullableFilter<"InspectionSession"> | string | null
    status?: EnumInspectionStatusFilter<"InspectionSession"> | $Enums.InspectionStatus
    passThreshold?: IntFilter<"InspectionSession"> | number
    totalScore?: IntFilter<"InspectionSession"> | number
    defectSeverity?: EnumDefectSeverityFilter<"InspectionSession"> | $Enums.DefectSeverity
    createdAt?: DateTimeFilter<"InspectionSession"> | Date | string
    updatedAt?: DateTimeFilter<"InspectionSession"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    tenantId?: IntFilter<"AuditLog"> | number
    actorUserId?: IntNullableFilter<"AuditLog"> | number | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    ip?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    beforeJson?: JsonNullableFilter<"AuditLog">
    afterJson?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type InspectorCreateWithoutUserInput = {
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
    sessions?: InspectionSessionCreateNestedManyWithoutInspectorInput
  }

  export type InspectorUncheckedCreateWithoutUserInput = {
    id?: number
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutInspectorInput
  }

  export type InspectorCreateOrConnectWithoutUserInput = {
    where: InspectorWhereUniqueInput
    create: XOR<InspectorCreateWithoutUserInput, InspectorUncheckedCreateWithoutUserInput>
  }

  export type InsurerUserCreateWithoutUserInput = {
    insurer: InsurerCreateNestedOneWithoutUsersInput
  }

  export type InsurerUserUncheckedCreateWithoutUserInput = {
    id?: number
    insurerId: number
  }

  export type InsurerUserCreateOrConnectWithoutUserInput = {
    where: InsurerUserWhereUniqueInput
    create: XOR<InsurerUserCreateWithoutUserInput, InsurerUserUncheckedCreateWithoutUserInput>
  }

  export type AgentCreateWithoutUserInput = {
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    insurer?: InsurerCreateNestedOneWithoutAgentsInput
    referrals?: ReferralCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutUserInput = {
    id?: number
    insurerId?: number | null
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    referrals?: ReferralUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutUserInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutActorInput = {
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: number
    tenantId: number
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InspectorUpsertWithoutUserInput = {
    update: XOR<InspectorUpdateWithoutUserInput, InspectorUncheckedUpdateWithoutUserInput>
    create: XOR<InspectorCreateWithoutUserInput, InspectorUncheckedCreateWithoutUserInput>
    where?: InspectorWhereInput
  }

  export type InspectorUpdateToOneWithWhereWithoutUserInput = {
    where?: InspectorWhereInput
    data: XOR<InspectorUpdateWithoutUserInput, InspectorUncheckedUpdateWithoutUserInput>
  }

  export type InspectorUpdateWithoutUserInput = {
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
    sessions?: InspectionSessionUpdateManyWithoutInspectorNestedInput
  }

  export type InspectorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
    sessions?: InspectionSessionUncheckedUpdateManyWithoutInspectorNestedInput
  }

  export type InsurerUserUpsertWithoutUserInput = {
    update: XOR<InsurerUserUpdateWithoutUserInput, InsurerUserUncheckedUpdateWithoutUserInput>
    create: XOR<InsurerUserCreateWithoutUserInput, InsurerUserUncheckedCreateWithoutUserInput>
    where?: InsurerUserWhereInput
  }

  export type InsurerUserUpdateToOneWithWhereWithoutUserInput = {
    where?: InsurerUserWhereInput
    data: XOR<InsurerUserUpdateWithoutUserInput, InsurerUserUncheckedUpdateWithoutUserInput>
  }

  export type InsurerUserUpdateWithoutUserInput = {
    insurer?: InsurerUpdateOneRequiredWithoutUsersNestedInput
  }

  export type InsurerUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: IntFieldUpdateOperationsInput | number
  }

  export type AgentUpsertWithoutUserInput = {
    update: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
    create: XOR<AgentCreateWithoutUserInput, AgentUncheckedCreateWithoutUserInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutUserInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutUserInput, AgentUncheckedUpdateWithoutUserInput>
  }

  export type AgentUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    insurer?: InsurerUpdateOneWithoutAgentsNestedInput
    referrals?: ReferralUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    insurerId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    referrals?: ReferralUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type UserCreateWithoutInspectorInput = {
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    insurerUser?: InsurerUserCreateNestedOneWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutInspectorInput = {
    id?: number
    tenantId?: number | null
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    insurerUser?: InsurerUserUncheckedCreateNestedOneWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutInspectorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInspectorInput, UserUncheckedCreateWithoutInspectorInput>
  }

  export type InspectionSessionCreateWithoutInspectorInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutInspectorInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutInspectorInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutInspectorInput, InspectionSessionUncheckedCreateWithoutInspectorInput>
  }

  export type InspectionSessionCreateManyInspectorInputEnvelope = {
    data: InspectionSessionCreateManyInspectorInput | InspectionSessionCreateManyInspectorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInspectorInput = {
    update: XOR<UserUpdateWithoutInspectorInput, UserUncheckedUpdateWithoutInspectorInput>
    create: XOR<UserCreateWithoutInspectorInput, UserUncheckedCreateWithoutInspectorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInspectorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInspectorInput, UserUncheckedUpdateWithoutInspectorInput>
  }

  export type UserUpdateWithoutInspectorInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    insurerUser?: InsurerUserUpdateOneWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutInspectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insurerUser?: InsurerUserUncheckedUpdateOneWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type InspectionSessionUpsertWithWhereUniqueWithoutInspectorInput = {
    where: InspectionSessionWhereUniqueInput
    update: XOR<InspectionSessionUpdateWithoutInspectorInput, InspectionSessionUncheckedUpdateWithoutInspectorInput>
    create: XOR<InspectionSessionCreateWithoutInspectorInput, InspectionSessionUncheckedCreateWithoutInspectorInput>
  }

  export type InspectionSessionUpdateWithWhereUniqueWithoutInspectorInput = {
    where: InspectionSessionWhereUniqueInput
    data: XOR<InspectionSessionUpdateWithoutInspectorInput, InspectionSessionUncheckedUpdateWithoutInspectorInput>
  }

  export type InspectionSessionUpdateManyWithWhereWithoutInspectorInput = {
    where: InspectionSessionScalarWhereInput
    data: XOR<InspectionSessionUpdateManyMutationInput, InspectionSessionUncheckedUpdateManyWithoutInspectorInput>
  }

  export type VehicleCreateWithoutOwnerInput = {
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVehiclesInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionCreateNestedManyWithoutVehicleInput
    referrals?: ReferralCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutOwnerInput = {
    id?: number
    tenantId: number
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutVehicleInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutOwnerInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutOwnerInput, VehicleUncheckedCreateWithoutOwnerInput>
  }

  export type VehicleCreateManyOwnerInputEnvelope = {
    data: VehicleCreateManyOwnerInput | VehicleCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type VehicleUpsertWithWhereUniqueWithoutOwnerInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutOwnerInput, VehicleUncheckedUpdateWithoutOwnerInput>
    create: XOR<VehicleCreateWithoutOwnerInput, VehicleUncheckedCreateWithoutOwnerInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutOwnerInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutOwnerInput, VehicleUncheckedUpdateWithoutOwnerInput>
  }

  export type VehicleUpdateManyWithWhereWithoutOwnerInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TenantCreateWithoutVehiclesInput = {
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVehiclesInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVehiclesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
  }

  export type OwnerCreateWithoutVehiclesInput = {
    fullName: string
    idNo?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
  }

  export type OwnerUncheckedCreateWithoutVehiclesInput = {
    id?: number
    fullName: string
    idNo?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
  }

  export type OwnerCreateOrConnectWithoutVehiclesInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutVehiclesInput, OwnerUncheckedCreateWithoutVehiclesInput>
  }

  export type BookingCreateWithoutVehicleInput = {
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    sessions?: InspectionSessionCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutVehicleInput = {
    id?: number
    tenantId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput>
  }

  export type BookingCreateManyVehicleInputEnvelope = {
    data: BookingCreateManyVehicleInput | BookingCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type InspectionSessionCreateWithoutVehicleInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutVehicleInput = {
    id?: number
    tenantId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutVehicleInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutVehicleInput, InspectionSessionUncheckedCreateWithoutVehicleInput>
  }

  export type InspectionSessionCreateManyVehicleInputEnvelope = {
    data: InspectionSessionCreateManyVehicleInput | InspectionSessionCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutVehicleInput = {
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
    agent: AgentCreateNestedOneWithoutReferralsInput
    session?: InspectionSessionCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutVehicleInput = {
    id?: number
    agentId: number
    sessionId?: number | null
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type ReferralCreateOrConnectWithoutVehicleInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutVehicleInput, ReferralUncheckedCreateWithoutVehicleInput>
  }

  export type ReferralCreateManyVehicleInputEnvelope = {
    data: ReferralCreateManyVehicleInput | ReferralCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutVehiclesInput = {
    update: XOR<TenantUpdateWithoutVehiclesInput, TenantUncheckedUpdateWithoutVehiclesInput>
    create: XOR<TenantCreateWithoutVehiclesInput, TenantUncheckedCreateWithoutVehiclesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVehiclesInput, TenantUncheckedUpdateWithoutVehiclesInput>
  }

  export type TenantUpdateWithoutVehiclesInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVehiclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OwnerUpsertWithoutVehiclesInput = {
    update: XOR<OwnerUpdateWithoutVehiclesInput, OwnerUncheckedUpdateWithoutVehiclesInput>
    create: XOR<OwnerCreateWithoutVehiclesInput, OwnerUncheckedCreateWithoutVehiclesInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutVehiclesInput, OwnerUncheckedUpdateWithoutVehiclesInput>
  }

  export type OwnerUpdateWithoutVehiclesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    idNo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OwnerUncheckedUpdateWithoutVehiclesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    idNo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVehicleInput, BookingUncheckedUpdateWithoutVehicleInput>
    create: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVehicleInput, BookingUncheckedUpdateWithoutVehicleInput>
  }

  export type BookingUpdateManyWithWhereWithoutVehicleInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVehicleInput>
  }

  export type InspectionSessionUpsertWithWhereUniqueWithoutVehicleInput = {
    where: InspectionSessionWhereUniqueInput
    update: XOR<InspectionSessionUpdateWithoutVehicleInput, InspectionSessionUncheckedUpdateWithoutVehicleInput>
    create: XOR<InspectionSessionCreateWithoutVehicleInput, InspectionSessionUncheckedCreateWithoutVehicleInput>
  }

  export type InspectionSessionUpdateWithWhereUniqueWithoutVehicleInput = {
    where: InspectionSessionWhereUniqueInput
    data: XOR<InspectionSessionUpdateWithoutVehicleInput, InspectionSessionUncheckedUpdateWithoutVehicleInput>
  }

  export type InspectionSessionUpdateManyWithWhereWithoutVehicleInput = {
    where: InspectionSessionScalarWhereInput
    data: XOR<InspectionSessionUpdateManyMutationInput, InspectionSessionUncheckedUpdateManyWithoutVehicleInput>
  }

  export type ReferralUpsertWithWhereUniqueWithoutVehicleInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutVehicleInput, ReferralUncheckedUpdateWithoutVehicleInput>
    create: XOR<ReferralCreateWithoutVehicleInput, ReferralUncheckedCreateWithoutVehicleInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutVehicleInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutVehicleInput, ReferralUncheckedUpdateWithoutVehicleInput>
  }

  export type ReferralUpdateManyWithWhereWithoutVehicleInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutVehicleInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: IntFilter<"Referral"> | number
    agentId?: IntFilter<"Referral"> | number
    vehicleId?: IntFilter<"Referral"> | number
    sessionId?: IntNullableFilter<"Referral"> | number | null
    referredAt?: DateTimeFilter<"Referral"> | Date | string
    convertedToPolicy?: BoolFilter<"Referral"> | boolean
    notes?: StringNullableFilter<"Referral"> | string | null
  }

  export type TenantCreateWithoutBookingsInput = {
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBookingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
  }

  export type VehicleCreateWithoutBookingsInput = {
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVehiclesInput
    owner?: OwnerCreateNestedOneWithoutVehiclesInput
    sessions?: InspectionSessionCreateNestedManyWithoutVehicleInput
    referrals?: ReferralCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutBookingsInput = {
    id?: number
    tenantId: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutVehicleInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutBookingsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
  }

  export type InspectionSessionCreateWithoutBookingInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutBookingInput = {
    id?: number
    tenantId: number
    vehicleId: number
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutBookingInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutBookingInput, InspectionSessionUncheckedCreateWithoutBookingInput>
  }

  export type InspectionSessionCreateManyBookingInputEnvelope = {
    data: InspectionSessionCreateManyBookingInput | InspectionSessionCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBookingsInput = {
    update: XOR<TenantUpdateWithoutBookingsInput, TenantUncheckedUpdateWithoutBookingsInput>
    create: XOR<TenantCreateWithoutBookingsInput, TenantUncheckedCreateWithoutBookingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBookingsInput, TenantUncheckedUpdateWithoutBookingsInput>
  }

  export type TenantUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VehicleUpsertWithoutBookingsInput = {
    update: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateWithoutBookingsInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVehiclesNestedInput
    owner?: OwnerUpdateOneWithoutVehiclesNestedInput
    sessions?: InspectionSessionUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InspectionSessionUncheckedUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type InspectionSessionUpsertWithWhereUniqueWithoutBookingInput = {
    where: InspectionSessionWhereUniqueInput
    update: XOR<InspectionSessionUpdateWithoutBookingInput, InspectionSessionUncheckedUpdateWithoutBookingInput>
    create: XOR<InspectionSessionCreateWithoutBookingInput, InspectionSessionUncheckedCreateWithoutBookingInput>
  }

  export type InspectionSessionUpdateWithWhereUniqueWithoutBookingInput = {
    where: InspectionSessionWhereUniqueInput
    data: XOR<InspectionSessionUpdateWithoutBookingInput, InspectionSessionUncheckedUpdateWithoutBookingInput>
  }

  export type InspectionSessionUpdateManyWithWhereWithoutBookingInput = {
    where: InspectionSessionScalarWhereInput
    data: XOR<InspectionSessionUpdateManyMutationInput, InspectionSessionUncheckedUpdateManyWithoutBookingInput>
  }

  export type InspectionResultCreateWithoutItemInput = {
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
    session: InspectionSessionCreateNestedOneWithoutResultsInput
  }

  export type InspectionResultUncheckedCreateWithoutItemInput = {
    id?: number
    sessionId: number
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
  }

  export type InspectionResultCreateOrConnectWithoutItemInput = {
    where: InspectionResultWhereUniqueInput
    create: XOR<InspectionResultCreateWithoutItemInput, InspectionResultUncheckedCreateWithoutItemInput>
  }

  export type InspectionResultCreateManyItemInputEnvelope = {
    data: InspectionResultCreateManyItemInput | InspectionResultCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InspectionResultUpsertWithWhereUniqueWithoutItemInput = {
    where: InspectionResultWhereUniqueInput
    update: XOR<InspectionResultUpdateWithoutItemInput, InspectionResultUncheckedUpdateWithoutItemInput>
    create: XOR<InspectionResultCreateWithoutItemInput, InspectionResultUncheckedCreateWithoutItemInput>
  }

  export type InspectionResultUpdateWithWhereUniqueWithoutItemInput = {
    where: InspectionResultWhereUniqueInput
    data: XOR<InspectionResultUpdateWithoutItemInput, InspectionResultUncheckedUpdateWithoutItemInput>
  }

  export type InspectionResultUpdateManyWithWhereWithoutItemInput = {
    where: InspectionResultScalarWhereInput
    data: XOR<InspectionResultUpdateManyMutationInput, InspectionResultUncheckedUpdateManyWithoutItemInput>
  }

  export type InspectionResultScalarWhereInput = {
    AND?: InspectionResultScalarWhereInput | InspectionResultScalarWhereInput[]
    OR?: InspectionResultScalarWhereInput[]
    NOT?: InspectionResultScalarWhereInput | InspectionResultScalarWhereInput[]
    id?: IntFilter<"InspectionResult"> | number
    sessionId?: IntFilter<"InspectionResult"> | number
    itemId?: IntFilter<"InspectionResult"> | number
    measuredValueNum?: DecimalNullableFilter<"InspectionResult"> | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: StringNullableFilter<"InspectionResult"> | string | null
    pass?: BoolFilter<"InspectionResult"> | boolean
    severity?: EnumResultSeverityFilter<"InspectionResult"> | $Enums.ResultSeverity
    remarks?: StringNullableFilter<"InspectionResult"> | string | null
    createdAt?: DateTimeFilter<"InspectionResult"> | Date | string
  }

  export type TenantCreateWithoutSessionsInput = {
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSessionsInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSessionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
  }

  export type VehicleCreateWithoutSessionsInput = {
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVehiclesInput
    owner?: OwnerCreateNestedOneWithoutVehiclesInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    referrals?: ReferralCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutSessionsInput = {
    id?: number
    tenantId: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutSessionsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutSessionsInput, VehicleUncheckedCreateWithoutSessionsInput>
  }

  export type BookingCreateWithoutSessionsInput = {
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBookingsInput
    vehicle: VehicleCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutSessionsInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutSessionsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutSessionsInput, BookingUncheckedCreateWithoutSessionsInput>
  }

  export type InspectorCreateWithoutSessionsInput = {
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
    user: UserCreateNestedOneWithoutInspectorInput
  }

  export type InspectorUncheckedCreateWithoutSessionsInput = {
    id?: number
    userId: number
    licenceNo: string
    licenceExpiry: Date | string
    qualification?: string | null
    yearsExperience?: number | null
    status?: $Enums.InspectorStatus
  }

  export type InspectorCreateOrConnectWithoutSessionsInput = {
    where: InspectorWhereUniqueInput
    create: XOR<InspectorCreateWithoutSessionsInput, InspectorUncheckedCreateWithoutSessionsInput>
  }

  export type CertificateCreateWithoutSessionInput = {
    certificateNo: string
    issuedAt?: Date | string
    expiresAt: Date | string
    stickerNo?: string | null
    reportPdfUrl?: string | null
    verificationHash: string
  }

  export type CertificateUncheckedCreateWithoutSessionInput = {
    id?: number
    certificateNo: string
    issuedAt?: Date | string
    expiresAt: Date | string
    stickerNo?: string | null
    reportPdfUrl?: string | null
    verificationHash: string
  }

  export type CertificateCreateOrConnectWithoutSessionInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutSessionInput, CertificateUncheckedCreateWithoutSessionInput>
  }

  export type InspectionResultCreateWithoutSessionInput = {
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
    item: InspectionItemCreateNestedOneWithoutResultsInput
  }

  export type InspectionResultUncheckedCreateWithoutSessionInput = {
    id?: number
    itemId: number
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
  }

  export type InspectionResultCreateOrConnectWithoutSessionInput = {
    where: InspectionResultWhereUniqueInput
    create: XOR<InspectionResultCreateWithoutSessionInput, InspectionResultUncheckedCreateWithoutSessionInput>
  }

  export type InspectionResultCreateManySessionInputEnvelope = {
    data: InspectionResultCreateManySessionInput | InspectionResultCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type MediaRefCreateWithoutSessionInput = {
    type: $Enums.MediaType
    storageUrl: string
    sha256?: string | null
    capturedAt?: Date | string
    cctvCameraId?: string | null
    cctvStartTs?: Date | string | null
    cctvEndTs?: Date | string | null
  }

  export type MediaRefUncheckedCreateWithoutSessionInput = {
    id?: number
    type: $Enums.MediaType
    storageUrl: string
    sha256?: string | null
    capturedAt?: Date | string
    cctvCameraId?: string | null
    cctvStartTs?: Date | string | null
    cctvEndTs?: Date | string | null
  }

  export type MediaRefCreateOrConnectWithoutSessionInput = {
    where: MediaRefWhereUniqueInput
    create: XOR<MediaRefCreateWithoutSessionInput, MediaRefUncheckedCreateWithoutSessionInput>
  }

  export type MediaRefCreateManySessionInputEnvelope = {
    data: MediaRefCreateManySessionInput | MediaRefCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ReinspectionLinkCreateWithoutOriginalSessionInput = {
    freeWithin14Days?: boolean
    reason?: string | null
    newSession: InspectionSessionCreateNestedOneWithoutNewReinspectionInput
  }

  export type ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput = {
    id?: number
    newSessionId: number
    freeWithin14Days?: boolean
    reason?: string | null
  }

  export type ReinspectionLinkCreateOrConnectWithoutOriginalSessionInput = {
    where: ReinspectionLinkWhereUniqueInput
    create: XOR<ReinspectionLinkCreateWithoutOriginalSessionInput, ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput>
  }

  export type ReinspectionLinkCreateManyOriginalSessionInputEnvelope = {
    data: ReinspectionLinkCreateManyOriginalSessionInput | ReinspectionLinkCreateManyOriginalSessionInput[]
    skipDuplicates?: boolean
  }

  export type ReinspectionLinkCreateWithoutNewSessionInput = {
    freeWithin14Days?: boolean
    reason?: string | null
    originalSession: InspectionSessionCreateNestedOneWithoutOriginalReinspectionsInput
  }

  export type ReinspectionLinkUncheckedCreateWithoutNewSessionInput = {
    id?: number
    originalSessionId: number
    freeWithin14Days?: boolean
    reason?: string | null
  }

  export type ReinspectionLinkCreateOrConnectWithoutNewSessionInput = {
    where: ReinspectionLinkWhereUniqueInput
    create: XOR<ReinspectionLinkCreateWithoutNewSessionInput, ReinspectionLinkUncheckedCreateWithoutNewSessionInput>
  }

  export type ReferralCreateWithoutSessionInput = {
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
    agent: AgentCreateNestedOneWithoutReferralsInput
    vehicle: VehicleCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutSessionInput = {
    id?: number
    agentId: number
    vehicleId: number
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type ReferralCreateOrConnectWithoutSessionInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutSessionInput, ReferralUncheckedCreateWithoutSessionInput>
  }

  export type ReferralCreateManySessionInputEnvelope = {
    data: ReferralCreateManySessionInput | ReferralCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSessionsInput = {
    update: XOR<TenantUpdateWithoutSessionsInput, TenantUncheckedUpdateWithoutSessionsInput>
    create: XOR<TenantCreateWithoutSessionsInput, TenantUncheckedCreateWithoutSessionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSessionsInput, TenantUncheckedUpdateWithoutSessionsInput>
  }

  export type TenantUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VehicleUpsertWithoutSessionsInput = {
    update: XOR<VehicleUpdateWithoutSessionsInput, VehicleUncheckedUpdateWithoutSessionsInput>
    create: XOR<VehicleCreateWithoutSessionsInput, VehicleUncheckedCreateWithoutSessionsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutSessionsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutSessionsInput, VehicleUncheckedUpdateWithoutSessionsInput>
  }

  export type VehicleUpdateWithoutSessionsInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVehiclesNestedInput
    owner?: OwnerUpdateOneWithoutVehiclesNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type BookingUpsertWithoutSessionsInput = {
    update: XOR<BookingUpdateWithoutSessionsInput, BookingUncheckedUpdateWithoutSessionsInput>
    create: XOR<BookingCreateWithoutSessionsInput, BookingUncheckedCreateWithoutSessionsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutSessionsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutSessionsInput, BookingUncheckedUpdateWithoutSessionsInput>
  }

  export type BookingUpdateWithoutSessionsInput = {
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectorUpsertWithoutSessionsInput = {
    update: XOR<InspectorUpdateWithoutSessionsInput, InspectorUncheckedUpdateWithoutSessionsInput>
    create: XOR<InspectorCreateWithoutSessionsInput, InspectorUncheckedCreateWithoutSessionsInput>
    where?: InspectorWhereInput
  }

  export type InspectorUpdateToOneWithWhereWithoutSessionsInput = {
    where?: InspectorWhereInput
    data: XOR<InspectorUpdateWithoutSessionsInput, InspectorUncheckedUpdateWithoutSessionsInput>
  }

  export type InspectorUpdateWithoutSessionsInput = {
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
    user?: UserUpdateOneRequiredWithoutInspectorNestedInput
  }

  export type InspectorUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    licenceNo?: StringFieldUpdateOperationsInput | string
    licenceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    yearsExperience?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumInspectorStatusFieldUpdateOperationsInput | $Enums.InspectorStatus
  }

  export type CertificateUpsertWithoutSessionInput = {
    update: XOR<CertificateUpdateWithoutSessionInput, CertificateUncheckedUpdateWithoutSessionInput>
    create: XOR<CertificateCreateWithoutSessionInput, CertificateUncheckedCreateWithoutSessionInput>
    where?: CertificateWhereInput
  }

  export type CertificateUpdateToOneWithWhereWithoutSessionInput = {
    where?: CertificateWhereInput
    data: XOR<CertificateUpdateWithoutSessionInput, CertificateUncheckedUpdateWithoutSessionInput>
  }

  export type CertificateUpdateWithoutSessionInput = {
    certificateNo?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickerNo?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationHash?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    certificateNo?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stickerNo?: NullableStringFieldUpdateOperationsInput | string | null
    reportPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationHash?: StringFieldUpdateOperationsInput | string
  }

  export type InspectionResultUpsertWithWhereUniqueWithoutSessionInput = {
    where: InspectionResultWhereUniqueInput
    update: XOR<InspectionResultUpdateWithoutSessionInput, InspectionResultUncheckedUpdateWithoutSessionInput>
    create: XOR<InspectionResultCreateWithoutSessionInput, InspectionResultUncheckedCreateWithoutSessionInput>
  }

  export type InspectionResultUpdateWithWhereUniqueWithoutSessionInput = {
    where: InspectionResultWhereUniqueInput
    data: XOR<InspectionResultUpdateWithoutSessionInput, InspectionResultUncheckedUpdateWithoutSessionInput>
  }

  export type InspectionResultUpdateManyWithWhereWithoutSessionInput = {
    where: InspectionResultScalarWhereInput
    data: XOR<InspectionResultUpdateManyMutationInput, InspectionResultUncheckedUpdateManyWithoutSessionInput>
  }

  export type MediaRefUpsertWithWhereUniqueWithoutSessionInput = {
    where: MediaRefWhereUniqueInput
    update: XOR<MediaRefUpdateWithoutSessionInput, MediaRefUncheckedUpdateWithoutSessionInput>
    create: XOR<MediaRefCreateWithoutSessionInput, MediaRefUncheckedCreateWithoutSessionInput>
  }

  export type MediaRefUpdateWithWhereUniqueWithoutSessionInput = {
    where: MediaRefWhereUniqueInput
    data: XOR<MediaRefUpdateWithoutSessionInput, MediaRefUncheckedUpdateWithoutSessionInput>
  }

  export type MediaRefUpdateManyWithWhereWithoutSessionInput = {
    where: MediaRefScalarWhereInput
    data: XOR<MediaRefUpdateManyMutationInput, MediaRefUncheckedUpdateManyWithoutSessionInput>
  }

  export type MediaRefScalarWhereInput = {
    AND?: MediaRefScalarWhereInput | MediaRefScalarWhereInput[]
    OR?: MediaRefScalarWhereInput[]
    NOT?: MediaRefScalarWhereInput | MediaRefScalarWhereInput[]
    id?: IntFilter<"MediaRef"> | number
    sessionId?: IntFilter<"MediaRef"> | number
    type?: EnumMediaTypeFilter<"MediaRef"> | $Enums.MediaType
    storageUrl?: StringFilter<"MediaRef"> | string
    sha256?: StringNullableFilter<"MediaRef"> | string | null
    capturedAt?: DateTimeFilter<"MediaRef"> | Date | string
    cctvCameraId?: StringNullableFilter<"MediaRef"> | string | null
    cctvStartTs?: DateTimeNullableFilter<"MediaRef"> | Date | string | null
    cctvEndTs?: DateTimeNullableFilter<"MediaRef"> | Date | string | null
  }

  export type ReinspectionLinkUpsertWithWhereUniqueWithoutOriginalSessionInput = {
    where: ReinspectionLinkWhereUniqueInput
    update: XOR<ReinspectionLinkUpdateWithoutOriginalSessionInput, ReinspectionLinkUncheckedUpdateWithoutOriginalSessionInput>
    create: XOR<ReinspectionLinkCreateWithoutOriginalSessionInput, ReinspectionLinkUncheckedCreateWithoutOriginalSessionInput>
  }

  export type ReinspectionLinkUpdateWithWhereUniqueWithoutOriginalSessionInput = {
    where: ReinspectionLinkWhereUniqueInput
    data: XOR<ReinspectionLinkUpdateWithoutOriginalSessionInput, ReinspectionLinkUncheckedUpdateWithoutOriginalSessionInput>
  }

  export type ReinspectionLinkUpdateManyWithWhereWithoutOriginalSessionInput = {
    where: ReinspectionLinkScalarWhereInput
    data: XOR<ReinspectionLinkUpdateManyMutationInput, ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionInput>
  }

  export type ReinspectionLinkScalarWhereInput = {
    AND?: ReinspectionLinkScalarWhereInput | ReinspectionLinkScalarWhereInput[]
    OR?: ReinspectionLinkScalarWhereInput[]
    NOT?: ReinspectionLinkScalarWhereInput | ReinspectionLinkScalarWhereInput[]
    id?: IntFilter<"ReinspectionLink"> | number
    originalSessionId?: IntFilter<"ReinspectionLink"> | number
    newSessionId?: IntFilter<"ReinspectionLink"> | number
    freeWithin14Days?: BoolFilter<"ReinspectionLink"> | boolean
    reason?: StringNullableFilter<"ReinspectionLink"> | string | null
  }

  export type ReinspectionLinkUpsertWithoutNewSessionInput = {
    update: XOR<ReinspectionLinkUpdateWithoutNewSessionInput, ReinspectionLinkUncheckedUpdateWithoutNewSessionInput>
    create: XOR<ReinspectionLinkCreateWithoutNewSessionInput, ReinspectionLinkUncheckedCreateWithoutNewSessionInput>
    where?: ReinspectionLinkWhereInput
  }

  export type ReinspectionLinkUpdateToOneWithWhereWithoutNewSessionInput = {
    where?: ReinspectionLinkWhereInput
    data: XOR<ReinspectionLinkUpdateWithoutNewSessionInput, ReinspectionLinkUncheckedUpdateWithoutNewSessionInput>
  }

  export type ReinspectionLinkUpdateWithoutNewSessionInput = {
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    originalSession?: InspectionSessionUpdateOneRequiredWithoutOriginalReinspectionsNestedInput
  }

  export type ReinspectionLinkUncheckedUpdateWithoutNewSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalSessionId?: IntFieldUpdateOperationsInput | number
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralUpsertWithWhereUniqueWithoutSessionInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutSessionInput, ReferralUncheckedUpdateWithoutSessionInput>
    create: XOR<ReferralCreateWithoutSessionInput, ReferralUncheckedCreateWithoutSessionInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutSessionInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutSessionInput, ReferralUncheckedUpdateWithoutSessionInput>
  }

  export type ReferralUpdateManyWithWhereWithoutSessionInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutSessionInput>
  }

  export type InspectionSessionCreateWithoutResultsInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutResultsInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutResultsInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutResultsInput, InspectionSessionUncheckedCreateWithoutResultsInput>
  }

  export type InspectionItemCreateWithoutResultsInput = {
    code: string
    name: string
    group: $Enums.ItemGroup
    weightPct: number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionItemUncheckedCreateWithoutResultsInput = {
    id?: number
    code: string
    name: string
    group: $Enums.ItemGroup
    weightPct: number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionItemCreateOrConnectWithoutResultsInput = {
    where: InspectionItemWhereUniqueInput
    create: XOR<InspectionItemCreateWithoutResultsInput, InspectionItemUncheckedCreateWithoutResultsInput>
  }

  export type InspectionSessionUpsertWithoutResultsInput = {
    update: XOR<InspectionSessionUpdateWithoutResultsInput, InspectionSessionUncheckedUpdateWithoutResultsInput>
    create: XOR<InspectionSessionCreateWithoutResultsInput, InspectionSessionUncheckedCreateWithoutResultsInput>
    where?: InspectionSessionWhereInput
  }

  export type InspectionSessionUpdateToOneWithWhereWithoutResultsInput = {
    where?: InspectionSessionWhereInput
    data: XOR<InspectionSessionUpdateWithoutResultsInput, InspectionSessionUncheckedUpdateWithoutResultsInput>
  }

  export type InspectionSessionUpdateWithoutResultsInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionItemUpsertWithoutResultsInput = {
    update: XOR<InspectionItemUpdateWithoutResultsInput, InspectionItemUncheckedUpdateWithoutResultsInput>
    create: XOR<InspectionItemCreateWithoutResultsInput, InspectionItemUncheckedCreateWithoutResultsInput>
    where?: InspectionItemWhereInput
  }

  export type InspectionItemUpdateToOneWithWhereWithoutResultsInput = {
    where?: InspectionItemWhereInput
    data: XOR<InspectionItemUpdateWithoutResultsInput, InspectionItemUncheckedUpdateWithoutResultsInput>
  }

  export type InspectionItemUpdateWithoutResultsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: EnumItemGroupFieldUpdateOperationsInput | $Enums.ItemGroup
    weightPct?: IntFieldUpdateOperationsInput | number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionItemUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    group?: EnumItemGroupFieldUpdateOperationsInput | $Enums.ItemGroup
    weightPct?: IntFieldUpdateOperationsInput | number
    requiredForCategories?: NullableJsonNullValueInput | InputJsonValue
  }

  export type InspectionSessionCreateWithoutCertificateInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutCertificateInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutCertificateInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutCertificateInput, InspectionSessionUncheckedCreateWithoutCertificateInput>
  }

  export type InspectionSessionUpsertWithoutCertificateInput = {
    update: XOR<InspectionSessionUpdateWithoutCertificateInput, InspectionSessionUncheckedUpdateWithoutCertificateInput>
    create: XOR<InspectionSessionCreateWithoutCertificateInput, InspectionSessionUncheckedCreateWithoutCertificateInput>
    where?: InspectionSessionWhereInput
  }

  export type InspectionSessionUpdateToOneWithWhereWithoutCertificateInput = {
    where?: InspectionSessionWhereInput
    data: XOR<InspectionSessionUpdateWithoutCertificateInput, InspectionSessionUncheckedUpdateWithoutCertificateInput>
  }

  export type InspectionSessionUpdateWithoutCertificateInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutCertificateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionCreateWithoutOriginalReinspectionsInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutOriginalReinspectionsInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutOriginalReinspectionsInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutOriginalReinspectionsInput, InspectionSessionUncheckedCreateWithoutOriginalReinspectionsInput>
  }

  export type InspectionSessionCreateWithoutNewReinspectionInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutNewReinspectionInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutNewReinspectionInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutNewReinspectionInput, InspectionSessionUncheckedCreateWithoutNewReinspectionInput>
  }

  export type InspectionSessionUpsertWithoutOriginalReinspectionsInput = {
    update: XOR<InspectionSessionUpdateWithoutOriginalReinspectionsInput, InspectionSessionUncheckedUpdateWithoutOriginalReinspectionsInput>
    create: XOR<InspectionSessionCreateWithoutOriginalReinspectionsInput, InspectionSessionUncheckedCreateWithoutOriginalReinspectionsInput>
    where?: InspectionSessionWhereInput
  }

  export type InspectionSessionUpdateToOneWithWhereWithoutOriginalReinspectionsInput = {
    where?: InspectionSessionWhereInput
    data: XOR<InspectionSessionUpdateWithoutOriginalReinspectionsInput, InspectionSessionUncheckedUpdateWithoutOriginalReinspectionsInput>
  }

  export type InspectionSessionUpdateWithoutOriginalReinspectionsInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutOriginalReinspectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUpsertWithoutNewReinspectionInput = {
    update: XOR<InspectionSessionUpdateWithoutNewReinspectionInput, InspectionSessionUncheckedUpdateWithoutNewReinspectionInput>
    create: XOR<InspectionSessionCreateWithoutNewReinspectionInput, InspectionSessionUncheckedCreateWithoutNewReinspectionInput>
    where?: InspectionSessionWhereInput
  }

  export type InspectionSessionUpdateToOneWithWhereWithoutNewReinspectionInput = {
    where?: InspectionSessionWhereInput
    data: XOR<InspectionSessionUpdateWithoutNewReinspectionInput, InspectionSessionUncheckedUpdateWithoutNewReinspectionInput>
  }

  export type InspectionSessionUpdateWithoutNewReinspectionInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutNewReinspectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionCreateWithoutMediaRefsInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutMediaRefsInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutMediaRefsInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutMediaRefsInput, InspectionSessionUncheckedCreateWithoutMediaRefsInput>
  }

  export type InspectionSessionUpsertWithoutMediaRefsInput = {
    update: XOR<InspectionSessionUpdateWithoutMediaRefsInput, InspectionSessionUncheckedUpdateWithoutMediaRefsInput>
    create: XOR<InspectionSessionCreateWithoutMediaRefsInput, InspectionSessionUncheckedCreateWithoutMediaRefsInput>
    where?: InspectionSessionWhereInput
  }

  export type InspectionSessionUpdateToOneWithWhereWithoutMediaRefsInput = {
    where?: InspectionSessionWhereInput
    data: XOR<InspectionSessionUpdateWithoutMediaRefsInput, InspectionSessionUncheckedUpdateWithoutMediaRefsInput>
  }

  export type InspectionSessionUpdateWithoutMediaRefsInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutMediaRefsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    vehicles?: VehicleCreateNestedManyWithoutTenantInput
    bookings?: BookingCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    name: string
    county?: string | null
    cluster?: number | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    vehicles?: VehicleUncheckedCreateNestedManyWithoutTenantInput
    bookings?: BookingUncheckedCreateNestedManyWithoutTenantInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    inspector?: InspectorCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserCreateNestedOneWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    tenantId?: number | null
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    inspector?: InspectorUncheckedCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserUncheckedCreateNestedOneWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUpdateManyWithoutTenantNestedInput
    bookings?: BookingUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    county?: NullableStringFieldUpdateOperationsInput | string | null
    cluster?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    vehicles?: VehicleUncheckedUpdateManyWithoutTenantNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutTenantNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    inspector?: InspectorUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUpdateOneWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: InspectorUncheckedUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUncheckedUpdateOneWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InsurerUserCreateWithoutInsurerInput = {
    user: UserCreateNestedOneWithoutInsurerUserInput
  }

  export type InsurerUserUncheckedCreateWithoutInsurerInput = {
    id?: number
    userId: number
  }

  export type InsurerUserCreateOrConnectWithoutInsurerInput = {
    where: InsurerUserWhereUniqueInput
    create: XOR<InsurerUserCreateWithoutInsurerInput, InsurerUserUncheckedCreateWithoutInsurerInput>
  }

  export type InsurerUserCreateManyInsurerInputEnvelope = {
    data: InsurerUserCreateManyInsurerInput | InsurerUserCreateManyInsurerInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutInsurerInput = {
    name: string
    keyHash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutInsurerInput = {
    id?: number
    name: string
    keyHash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutInsurerInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutInsurerInput, ApiKeyUncheckedCreateWithoutInsurerInput>
  }

  export type ApiKeyCreateManyInsurerInputEnvelope = {
    data: ApiKeyCreateManyInsurerInput | ApiKeyCreateManyInsurerInput[]
    skipDuplicates?: boolean
  }

  export type ApiUsageLogCreateWithoutInsurerInput = {
    endpoint: string
    vehicleId?: number | null
    statusCode: number
    responseMs: number
    createdAt?: Date | string
  }

  export type ApiUsageLogUncheckedCreateWithoutInsurerInput = {
    id?: number
    endpoint: string
    vehicleId?: number | null
    statusCode: number
    responseMs: number
    createdAt?: Date | string
  }

  export type ApiUsageLogCreateOrConnectWithoutInsurerInput = {
    where: ApiUsageLogWhereUniqueInput
    create: XOR<ApiUsageLogCreateWithoutInsurerInput, ApiUsageLogUncheckedCreateWithoutInsurerInput>
  }

  export type ApiUsageLogCreateManyInsurerInputEnvelope = {
    data: ApiUsageLogCreateManyInsurerInput | ApiUsageLogCreateManyInsurerInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutInsurerInput = {
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    user?: UserCreateNestedOneWithoutAgentInput
    referrals?: ReferralCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutInsurerInput = {
    id?: number
    userId?: number | null
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    referrals?: ReferralUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutInsurerInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutInsurerInput, AgentUncheckedCreateWithoutInsurerInput>
  }

  export type AgentCreateManyInsurerInputEnvelope = {
    data: AgentCreateManyInsurerInput | AgentCreateManyInsurerInput[]
    skipDuplicates?: boolean
  }

  export type InsurerUserUpsertWithWhereUniqueWithoutInsurerInput = {
    where: InsurerUserWhereUniqueInput
    update: XOR<InsurerUserUpdateWithoutInsurerInput, InsurerUserUncheckedUpdateWithoutInsurerInput>
    create: XOR<InsurerUserCreateWithoutInsurerInput, InsurerUserUncheckedCreateWithoutInsurerInput>
  }

  export type InsurerUserUpdateWithWhereUniqueWithoutInsurerInput = {
    where: InsurerUserWhereUniqueInput
    data: XOR<InsurerUserUpdateWithoutInsurerInput, InsurerUserUncheckedUpdateWithoutInsurerInput>
  }

  export type InsurerUserUpdateManyWithWhereWithoutInsurerInput = {
    where: InsurerUserScalarWhereInput
    data: XOR<InsurerUserUpdateManyMutationInput, InsurerUserUncheckedUpdateManyWithoutInsurerInput>
  }

  export type InsurerUserScalarWhereInput = {
    AND?: InsurerUserScalarWhereInput | InsurerUserScalarWhereInput[]
    OR?: InsurerUserScalarWhereInput[]
    NOT?: InsurerUserScalarWhereInput | InsurerUserScalarWhereInput[]
    id?: IntFilter<"InsurerUser"> | number
    insurerId?: IntFilter<"InsurerUser"> | number
    userId?: IntFilter<"InsurerUser"> | number
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutInsurerInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutInsurerInput, ApiKeyUncheckedUpdateWithoutInsurerInput>
    create: XOR<ApiKeyCreateWithoutInsurerInput, ApiKeyUncheckedCreateWithoutInsurerInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutInsurerInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutInsurerInput, ApiKeyUncheckedUpdateWithoutInsurerInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutInsurerInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutInsurerInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    insurerId?: IntFilter<"ApiKey"> | number
    name?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    scopes?: JsonNullableFilter<"ApiKey">
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type ApiUsageLogUpsertWithWhereUniqueWithoutInsurerInput = {
    where: ApiUsageLogWhereUniqueInput
    update: XOR<ApiUsageLogUpdateWithoutInsurerInput, ApiUsageLogUncheckedUpdateWithoutInsurerInput>
    create: XOR<ApiUsageLogCreateWithoutInsurerInput, ApiUsageLogUncheckedCreateWithoutInsurerInput>
  }

  export type ApiUsageLogUpdateWithWhereUniqueWithoutInsurerInput = {
    where: ApiUsageLogWhereUniqueInput
    data: XOR<ApiUsageLogUpdateWithoutInsurerInput, ApiUsageLogUncheckedUpdateWithoutInsurerInput>
  }

  export type ApiUsageLogUpdateManyWithWhereWithoutInsurerInput = {
    where: ApiUsageLogScalarWhereInput
    data: XOR<ApiUsageLogUpdateManyMutationInput, ApiUsageLogUncheckedUpdateManyWithoutInsurerInput>
  }

  export type ApiUsageLogScalarWhereInput = {
    AND?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
    OR?: ApiUsageLogScalarWhereInput[]
    NOT?: ApiUsageLogScalarWhereInput | ApiUsageLogScalarWhereInput[]
    id?: IntFilter<"ApiUsageLog"> | number
    insurerId?: IntFilter<"ApiUsageLog"> | number
    endpoint?: StringFilter<"ApiUsageLog"> | string
    vehicleId?: IntNullableFilter<"ApiUsageLog"> | number | null
    statusCode?: IntFilter<"ApiUsageLog"> | number
    responseMs?: IntFilter<"ApiUsageLog"> | number
    createdAt?: DateTimeFilter<"ApiUsageLog"> | Date | string
  }

  export type AgentUpsertWithWhereUniqueWithoutInsurerInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutInsurerInput, AgentUncheckedUpdateWithoutInsurerInput>
    create: XOR<AgentCreateWithoutInsurerInput, AgentUncheckedCreateWithoutInsurerInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutInsurerInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutInsurerInput, AgentUncheckedUpdateWithoutInsurerInput>
  }

  export type AgentUpdateManyWithWhereWithoutInsurerInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutInsurerInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: IntFilter<"Agent"> | number
    userId?: IntNullableFilter<"Agent"> | number | null
    insurerId?: IntNullableFilter<"Agent"> | number | null
    fullName?: StringFilter<"Agent"> | string
    phone?: StringNullableFilter<"Agent"> | string | null
    email?: StringNullableFilter<"Agent"> | string | null
    status?: StringFilter<"Agent"> | string
  }

  export type InsurerCreateWithoutUsersInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    apiKeys?: ApiKeyCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogCreateNestedManyWithoutInsurerInput
    agents?: AgentCreateNestedManyWithoutInsurerInput
  }

  export type InsurerUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutInsurerInput
    agents?: AgentUncheckedCreateNestedManyWithoutInsurerInput
  }

  export type InsurerCreateOrConnectWithoutUsersInput = {
    where: InsurerWhereUniqueInput
    create: XOR<InsurerCreateWithoutUsersInput, InsurerUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutInsurerUserInput = {
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    inspector?: InspectorCreateNestedOneWithoutUserInput
    agent?: AgentCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutInsurerUserInput = {
    id?: number
    tenantId?: number | null
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    inspector?: InspectorUncheckedCreateNestedOneWithoutUserInput
    agent?: AgentUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutInsurerUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsurerUserInput, UserUncheckedCreateWithoutInsurerUserInput>
  }

  export type InsurerUpsertWithoutUsersInput = {
    update: XOR<InsurerUpdateWithoutUsersInput, InsurerUncheckedUpdateWithoutUsersInput>
    create: XOR<InsurerCreateWithoutUsersInput, InsurerUncheckedCreateWithoutUsersInput>
    where?: InsurerWhereInput
  }

  export type InsurerUpdateToOneWithWhereWithoutUsersInput = {
    where?: InsurerWhereInput
    data: XOR<InsurerUpdateWithoutUsersInput, InsurerUncheckedUpdateWithoutUsersInput>
  }

  export type InsurerUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    apiKeys?: ApiKeyUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUpdateManyWithoutInsurerNestedInput
    agents?: AgentUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUncheckedUpdateManyWithoutInsurerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutInsurerNestedInput
  }

  export type UserUpsertWithoutInsurerUserInput = {
    update: XOR<UserUpdateWithoutInsurerUserInput, UserUncheckedUpdateWithoutInsurerUserInput>
    create: XOR<UserCreateWithoutInsurerUserInput, UserUncheckedCreateWithoutInsurerUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsurerUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsurerUserInput, UserUncheckedUpdateWithoutInsurerUserInput>
  }

  export type UserUpdateWithoutInsurerUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    inspector?: InspectorUpdateOneWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutInsurerUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: InspectorUncheckedUpdateOneWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type InsurerCreateWithoutApiKeysInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogCreateNestedManyWithoutInsurerInput
    agents?: AgentCreateNestedManyWithoutInsurerInput
  }

  export type InsurerUncheckedCreateWithoutApiKeysInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserUncheckedCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutInsurerInput
    agents?: AgentUncheckedCreateNestedManyWithoutInsurerInput
  }

  export type InsurerCreateOrConnectWithoutApiKeysInput = {
    where: InsurerWhereUniqueInput
    create: XOR<InsurerCreateWithoutApiKeysInput, InsurerUncheckedCreateWithoutApiKeysInput>
  }

  export type InsurerUpsertWithoutApiKeysInput = {
    update: XOR<InsurerUpdateWithoutApiKeysInput, InsurerUncheckedUpdateWithoutApiKeysInput>
    create: XOR<InsurerCreateWithoutApiKeysInput, InsurerUncheckedCreateWithoutApiKeysInput>
    where?: InsurerWhereInput
  }

  export type InsurerUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: InsurerWhereInput
    data: XOR<InsurerUpdateWithoutApiKeysInput, InsurerUncheckedUpdateWithoutApiKeysInput>
  }

  export type InsurerUpdateWithoutApiKeysInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUpdateManyWithoutInsurerNestedInput
    agents?: AgentUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerUncheckedUpdateWithoutApiKeysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUncheckedUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUncheckedUpdateManyWithoutInsurerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerCreateWithoutApiUsageLogsInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserCreateNestedManyWithoutInsurerInput
    apiKeys?: ApiKeyCreateNestedManyWithoutInsurerInput
    agents?: AgentCreateNestedManyWithoutInsurerInput
  }

  export type InsurerUncheckedCreateWithoutApiUsageLogsInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserUncheckedCreateNestedManyWithoutInsurerInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutInsurerInput
    agents?: AgentUncheckedCreateNestedManyWithoutInsurerInput
  }

  export type InsurerCreateOrConnectWithoutApiUsageLogsInput = {
    where: InsurerWhereUniqueInput
    create: XOR<InsurerCreateWithoutApiUsageLogsInput, InsurerUncheckedCreateWithoutApiUsageLogsInput>
  }

  export type InsurerUpsertWithoutApiUsageLogsInput = {
    update: XOR<InsurerUpdateWithoutApiUsageLogsInput, InsurerUncheckedUpdateWithoutApiUsageLogsInput>
    create: XOR<InsurerCreateWithoutApiUsageLogsInput, InsurerUncheckedCreateWithoutApiUsageLogsInput>
    where?: InsurerWhereInput
  }

  export type InsurerUpdateToOneWithWhereWithoutApiUsageLogsInput = {
    where?: InsurerWhereInput
    data: XOR<InsurerUpdateWithoutApiUsageLogsInput, InsurerUncheckedUpdateWithoutApiUsageLogsInput>
  }

  export type InsurerUpdateWithoutApiUsageLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUpdateManyWithoutInsurerNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutInsurerNestedInput
    agents?: AgentUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerUncheckedUpdateWithoutApiUsageLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUncheckedUpdateManyWithoutInsurerNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutInsurerNestedInput
    agents?: AgentUncheckedUpdateManyWithoutInsurerNestedInput
  }

  export type UserCreateWithoutAgentInput = {
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    inspector?: InspectorCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutAgentInput = {
    id?: number
    tenantId?: number | null
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    inspector?: InspectorUncheckedCreateNestedOneWithoutUserInput
    insurerUser?: InsurerUserUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutAgentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
  }

  export type InsurerCreateWithoutAgentsInput = {
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserCreateNestedManyWithoutInsurerInput
    apiKeys?: ApiKeyCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogCreateNestedManyWithoutInsurerInput
  }

  export type InsurerUncheckedCreateWithoutAgentsInput = {
    id?: number
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    status?: $Enums.InsurerStatus
    users?: InsurerUserUncheckedCreateNestedManyWithoutInsurerInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutInsurerInput
    apiUsageLogs?: ApiUsageLogUncheckedCreateNestedManyWithoutInsurerInput
  }

  export type InsurerCreateOrConnectWithoutAgentsInput = {
    where: InsurerWhereUniqueInput
    create: XOR<InsurerCreateWithoutAgentsInput, InsurerUncheckedCreateWithoutAgentsInput>
  }

  export type ReferralCreateWithoutAgentInput = {
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
    vehicle: VehicleCreateNestedOneWithoutReferralsInput
    session?: InspectionSessionCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutAgentInput = {
    id?: number
    vehicleId: number
    sessionId?: number | null
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type ReferralCreateOrConnectWithoutAgentInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutAgentInput, ReferralUncheckedCreateWithoutAgentInput>
  }

  export type ReferralCreateManyAgentInputEnvelope = {
    data: ReferralCreateManyAgentInput | ReferralCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAgentInput = {
    update: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
    create: XOR<UserCreateWithoutAgentInput, UserUncheckedCreateWithoutAgentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgentInput, UserUncheckedUpdateWithoutAgentInput>
  }

  export type UserUpdateWithoutAgentInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    inspector?: InspectorUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: InspectorUncheckedUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type InsurerUpsertWithoutAgentsInput = {
    update: XOR<InsurerUpdateWithoutAgentsInput, InsurerUncheckedUpdateWithoutAgentsInput>
    create: XOR<InsurerCreateWithoutAgentsInput, InsurerUncheckedCreateWithoutAgentsInput>
    where?: InsurerWhereInput
  }

  export type InsurerUpdateToOneWithWhereWithoutAgentsInput = {
    where?: InsurerWhereInput
    data: XOR<InsurerUpdateWithoutAgentsInput, InsurerUncheckedUpdateWithoutAgentsInput>
  }

  export type InsurerUpdateWithoutAgentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUpdateManyWithoutInsurerNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUpdateManyWithoutInsurerNestedInput
  }

  export type InsurerUncheckedUpdateWithoutAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsurerStatusFieldUpdateOperationsInput | $Enums.InsurerStatus
    users?: InsurerUserUncheckedUpdateManyWithoutInsurerNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutInsurerNestedInput
    apiUsageLogs?: ApiUsageLogUncheckedUpdateManyWithoutInsurerNestedInput
  }

  export type ReferralUpsertWithWhereUniqueWithoutAgentInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutAgentInput, ReferralUncheckedUpdateWithoutAgentInput>
    create: XOR<ReferralCreateWithoutAgentInput, ReferralUncheckedCreateWithoutAgentInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutAgentInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutAgentInput, ReferralUncheckedUpdateWithoutAgentInput>
  }

  export type ReferralUpdateManyWithWhereWithoutAgentInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentCreateWithoutReferralsInput = {
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
    user?: UserCreateNestedOneWithoutAgentInput
    insurer?: InsurerCreateNestedOneWithoutAgentsInput
  }

  export type AgentUncheckedCreateWithoutReferralsInput = {
    id?: number
    userId?: number | null
    insurerId?: number | null
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
  }

  export type AgentCreateOrConnectWithoutReferralsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutReferralsInput, AgentUncheckedCreateWithoutReferralsInput>
  }

  export type VehicleCreateWithoutReferralsInput = {
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVehiclesInput
    owner?: OwnerCreateNestedOneWithoutVehiclesInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutReferralsInput = {
    id?: number
    tenantId: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    sessions?: InspectionSessionUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutReferralsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutReferralsInput, VehicleUncheckedCreateWithoutReferralsInput>
  }

  export type InspectionSessionCreateWithoutReferralsInput = {
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSessionsInput
    vehicle: VehicleCreateNestedOneWithoutSessionsInput
    booking?: BookingCreateNestedOneWithoutSessionsInput
    inspector?: InspectorCreateNestedOneWithoutSessionsInput
    certificate?: CertificateCreateNestedOneWithoutSessionInput
    results?: InspectionResultCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkCreateNestedOneWithoutNewSessionInput
  }

  export type InspectionSessionUncheckedCreateWithoutReferralsInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
    certificate?: CertificateUncheckedCreateNestedOneWithoutSessionInput
    results?: InspectionResultUncheckedCreateNestedManyWithoutSessionInput
    mediaRefs?: MediaRefUncheckedCreateNestedManyWithoutSessionInput
    originalReinspections?: ReinspectionLinkUncheckedCreateNestedManyWithoutOriginalSessionInput
    newReinspection?: ReinspectionLinkUncheckedCreateNestedOneWithoutNewSessionInput
  }

  export type InspectionSessionCreateOrConnectWithoutReferralsInput = {
    where: InspectionSessionWhereUniqueInput
    create: XOR<InspectionSessionCreateWithoutReferralsInput, InspectionSessionUncheckedCreateWithoutReferralsInput>
  }

  export type AgentUpsertWithoutReferralsInput = {
    update: XOR<AgentUpdateWithoutReferralsInput, AgentUncheckedUpdateWithoutReferralsInput>
    create: XOR<AgentCreateWithoutReferralsInput, AgentUncheckedCreateWithoutReferralsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutReferralsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutReferralsInput, AgentUncheckedUpdateWithoutReferralsInput>
  }

  export type AgentUpdateWithoutReferralsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutAgentNestedInput
    insurer?: InsurerUpdateOneWithoutAgentsNestedInput
  }

  export type AgentUncheckedUpdateWithoutReferralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    insurerId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleUpsertWithoutReferralsInput = {
    update: XOR<VehicleUpdateWithoutReferralsInput, VehicleUncheckedUpdateWithoutReferralsInput>
    create: XOR<VehicleCreateWithoutReferralsInput, VehicleUncheckedCreateWithoutReferralsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutReferralsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutReferralsInput, VehicleUncheckedUpdateWithoutReferralsInput>
  }

  export type VehicleUpdateWithoutReferralsInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVehiclesNestedInput
    owner?: OwnerUpdateOneWithoutVehiclesNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutReferralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type InspectionSessionUpsertWithoutReferralsInput = {
    update: XOR<InspectionSessionUpdateWithoutReferralsInput, InspectionSessionUncheckedUpdateWithoutReferralsInput>
    create: XOR<InspectionSessionCreateWithoutReferralsInput, InspectionSessionUncheckedCreateWithoutReferralsInput>
    where?: InspectionSessionWhereInput
  }

  export type InspectionSessionUpdateToOneWithWhereWithoutReferralsInput = {
    where?: InspectionSessionWhereInput
    data: XOR<InspectionSessionUpdateWithoutReferralsInput, InspectionSessionUncheckedUpdateWithoutReferralsInput>
  }

  export type InspectionSessionUpdateWithoutReferralsInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutReferralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: number
    fullName: string
    email?: string | null
    phone?: string | null
    passwordHash: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleCreateManyTenantInput = {
    id?: number
    ownerId?: number | null
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyTenantInput = {
    id?: number
    vehicleId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionSessionCreateManyTenantInput = {
    id?: number
    vehicleId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: number
    actorUserId?: number | null
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: InspectorUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUpdateOneWithoutUserNestedInput
    agent?: AgentUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: InspectorUncheckedUpdateOneWithoutUserNestedInput
    insurerUser?: InsurerUserUncheckedUpdateOneWithoutUserNestedInput
    agent?: AgentUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUpdateWithoutTenantInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneWithoutVehiclesNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutTenantInput = {
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutBookingsNestedInput
    sessions?: InspectionSessionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InspectionSessionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionSessionUpdateWithoutTenantInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: number
    tenantId: number
    action: string
    entityType: string
    entityId: string
    ip?: string | null
    userAgent?: string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionSessionCreateManyInspectorInput = {
    id?: number
    tenantId: number
    vehicleId: number
    bookingId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionSessionUpdateWithoutInspectorInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutInspectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateManyWithoutInspectorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyOwnerInput = {
    id?: number
    tenantId: number
    registrationNo: string
    vin?: string | null
    engineNo?: string | null
    make?: string | null
    model?: string | null
    yearOfMfg?: number | null
    category: $Enums.VehicleCategory
    tareWeightKg?: number | null
    engineCc?: number | null
    evBatteryKwh?: number | null
    telematicsImei?: string | null
    speedGovernorSerial?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateWithoutOwnerInput = {
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVehiclesNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    sessions?: InspectionSessionUncheckedUpdateManyWithoutVehicleNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    registrationNo?: StringFieldUpdateOperationsInput | string
    vin?: NullableStringFieldUpdateOperationsInput | string | null
    engineNo?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    yearOfMfg?: NullableIntFieldUpdateOperationsInput | number | null
    category?: EnumVehicleCategoryFieldUpdateOperationsInput | $Enums.VehicleCategory
    tareWeightKg?: NullableIntFieldUpdateOperationsInput | number | null
    engineCc?: NullableIntFieldUpdateOperationsInput | number | null
    evBatteryKwh?: NullableIntFieldUpdateOperationsInput | number | null
    telematicsImei?: NullableStringFieldUpdateOperationsInput | string | null
    speedGovernorSerial?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyVehicleInput = {
    id?: number
    tenantId: number
    bookingRef?: string | null
    bookingFeePaid?: boolean
    bookingFeeReceiptNo?: string | null
    bookedForDate?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionSessionCreateManyVehicleInput = {
    id?: number
    tenantId: number
    bookingId?: number | null
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyVehicleInput = {
    id?: number
    agentId: number
    sessionId?: number | null
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type BookingUpdateWithoutVehicleInput = {
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBookingsNestedInput
    sessions?: InspectionSessionUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InspectionSessionUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    bookingRef?: NullableStringFieldUpdateOperationsInput | string | null
    bookingFeePaid?: BoolFieldUpdateOperationsInput | boolean
    bookingFeeReceiptNo?: NullableStringFieldUpdateOperationsInput | string | null
    bookedForDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionSessionUpdateWithoutVehicleInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    booking?: BookingUpdateOneWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    bookingId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutVehicleInput = {
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutReferralsNestedInput
    session?: InspectionSessionUpdateOneWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralUncheckedUpdateManyWithoutVehicleInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InspectionSessionCreateManyBookingInput = {
    id?: number
    tenantId: number
    vehicleId: number
    inspectorId?: number | null
    inspectedAt?: Date | string | null
    inspectionType: $Enums.InspectionType
    odometerKm?: number | null
    notes?: string | null
    status?: $Enums.InspectionStatus
    passThreshold?: number
    totalScore?: number
    defectSeverity?: $Enums.DefectSeverity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InspectionSessionUpdateWithoutBookingInput = {
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSessionsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutSessionsNestedInput
    inspector?: InspectorUpdateOneWithoutSessionsNestedInput
    certificate?: CertificateUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: CertificateUncheckedUpdateOneWithoutSessionNestedInput
    results?: InspectionResultUncheckedUpdateManyWithoutSessionNestedInput
    mediaRefs?: MediaRefUncheckedUpdateManyWithoutSessionNestedInput
    originalReinspections?: ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionNestedInput
    newReinspection?: ReinspectionLinkUncheckedUpdateOneWithoutNewSessionNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InspectionSessionUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    tenantId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    inspectorId?: NullableIntFieldUpdateOperationsInput | number | null
    inspectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionType?: EnumInspectionTypeFieldUpdateOperationsInput | $Enums.InspectionType
    odometerKm?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInspectionStatusFieldUpdateOperationsInput | $Enums.InspectionStatus
    passThreshold?: IntFieldUpdateOperationsInput | number
    totalScore?: IntFieldUpdateOperationsInput | number
    defectSeverity?: EnumDefectSeverityFieldUpdateOperationsInput | $Enums.DefectSeverity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultCreateManyItemInput = {
    id?: number
    sessionId: number
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
  }

  export type InspectionResultUpdateWithoutItemInput = {
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: InspectionSessionUpdateOneRequiredWithoutResultsNestedInput
  }

  export type InspectionResultUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultCreateManySessionInput = {
    id?: number
    itemId: number
    measuredValueNum?: Decimal | DecimalJsLike | number | string | null
    measuredValueText?: string | null
    pass: boolean
    severity?: $Enums.ResultSeverity
    remarks?: string | null
    createdAt?: Date | string
  }

  export type MediaRefCreateManySessionInput = {
    id?: number
    type: $Enums.MediaType
    storageUrl: string
    sha256?: string | null
    capturedAt?: Date | string
    cctvCameraId?: string | null
    cctvStartTs?: Date | string | null
    cctvEndTs?: Date | string | null
  }

  export type ReinspectionLinkCreateManyOriginalSessionInput = {
    id?: number
    newSessionId: number
    freeWithin14Days?: boolean
    reason?: string | null
  }

  export type ReferralCreateManySessionInput = {
    id?: number
    agentId: number
    vehicleId: number
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type InspectionResultUpdateWithoutSessionInput = {
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InspectionItemUpdateOneRequiredWithoutResultsNestedInput
  }

  export type InspectionResultUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InspectionResultUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    measuredValueNum?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    measuredValueText?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: BoolFieldUpdateOperationsInput | boolean
    severity?: EnumResultSeverityFieldUpdateOperationsInput | $Enums.ResultSeverity
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaRefUpdateWithoutSessionInput = {
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaRefUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaRefUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    storageUrl?: StringFieldUpdateOperationsInput | string
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cctvCameraId?: NullableStringFieldUpdateOperationsInput | string | null
    cctvStartTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cctvEndTs?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReinspectionLinkUpdateWithoutOriginalSessionInput = {
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    newSession?: InspectionSessionUpdateOneRequiredWithoutNewReinspectionNestedInput
  }

  export type ReinspectionLinkUncheckedUpdateWithoutOriginalSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    newSessionId?: IntFieldUpdateOperationsInput | number
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReinspectionLinkUncheckedUpdateManyWithoutOriginalSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    newSessionId?: IntFieldUpdateOperationsInput | number
    freeWithin14Days?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralUpdateWithoutSessionInput = {
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: AgentUpdateOneRequiredWithoutReferralsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InsurerUserCreateManyInsurerInput = {
    id?: number
    userId: number
  }

  export type ApiKeyCreateManyInsurerInput = {
    id?: number
    name: string
    keyHash: string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: Date | string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApiUsageLogCreateManyInsurerInput = {
    id?: number
    endpoint: string
    vehicleId?: number | null
    statusCode: number
    responseMs: number
    createdAt?: Date | string
  }

  export type AgentCreateManyInsurerInput = {
    id?: number
    userId?: number | null
    fullName: string
    phone?: string | null
    email?: string | null
    status?: string
  }

  export type InsurerUserUpdateWithoutInsurerInput = {
    user?: UserUpdateOneRequiredWithoutInsurerUserNestedInput
  }

  export type InsurerUserUncheckedUpdateWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type InsurerUserUncheckedUpdateManyWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ApiKeyUpdateWithoutInsurerInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    scopes?: NullableJsonNullValueInput | InputJsonValue
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUpdateWithoutInsurerInput = {
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUncheckedUpdateWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiUsageLogUncheckedUpdateManyWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    endpoint?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableIntFieldUpdateOperationsInput | number | null
    statusCode?: IntFieldUpdateOperationsInput | number
    responseMs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutInsurerInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutAgentNestedInput
    referrals?: ReferralUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    referrals?: ReferralUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutInsurerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    fullName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralCreateManyAgentInput = {
    id?: number
    vehicleId: number
    sessionId?: number | null
    referredAt?: Date | string
    convertedToPolicy?: boolean
    notes?: string | null
  }

  export type ReferralUpdateWithoutAgentInput = {
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle?: VehicleUpdateOneRequiredWithoutReferralsNestedInput
    session?: InspectionSessionUpdateOneWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReferralUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    vehicleId?: IntFieldUpdateOperationsInput | number
    sessionId?: NullableIntFieldUpdateOperationsInput | number | null
    referredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convertedToPolicy?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectorCountOutputTypeDefaultArgs instead
     */
    export type InspectorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerCountOutputTypeDefaultArgs instead
     */
    export type OwnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleCountOutputTypeDefaultArgs instead
     */
    export type VehicleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingCountOutputTypeDefaultArgs instead
     */
    export type BookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectionItemCountOutputTypeDefaultArgs instead
     */
    export type InspectionItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectionItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectionSessionCountOutputTypeDefaultArgs instead
     */
    export type InspectionSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectionSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsurerCountOutputTypeDefaultArgs instead
     */
    export type InsurerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsurerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentCountOutputTypeDefaultArgs instead
     */
    export type AgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectorDefaultArgs instead
     */
    export type InspectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OwnerDefaultArgs instead
     */
    export type OwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OwnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDefaultArgs instead
     */
    export type VehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectionItemDefaultArgs instead
     */
    export type InspectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectionItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectionSessionDefaultArgs instead
     */
    export type InspectionSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectionSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InspectionResultDefaultArgs instead
     */
    export type InspectionResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InspectionResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReinspectionLinkDefaultArgs instead
     */
    export type ReinspectionLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReinspectionLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaRefDefaultArgs instead
     */
    export type MediaRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaRefDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsurerDefaultArgs instead
     */
    export type InsurerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsurerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsurerUserDefaultArgs instead
     */
    export type InsurerUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsurerUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiUsageLogDefaultArgs instead
     */
    export type ApiUsageLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiUsageLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentDefaultArgs instead
     */
    export type AgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}